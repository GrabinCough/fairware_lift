// lib/src/features/dxg/domain/exercise_instance.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'dart:convert';
import 'package:drift/drift.dart';
import 'package:json_annotation/json_annotation.dart';
import 'package:collection/collection.dart';

// --- FIX ---
// This file no longer uses the freezed code generator. It will only generate
// a `.g.dart` file for JSON serialization.
part 'exercise_instance.g.dart';

// -----------------------------------------------------------------------------
// --- EXERCISE INSTANCE DATA MODEL --------------------------------------------
// -----------------------------------------------------------------------------
// This model represents a canonical exercise that has been used at least once
// and is therefore persisted to the local database. It is now a standard,
// immutable Dart class to bypass the `freezed` generator crash.
// -----------------------------------------------------------------------------

@JsonSerializable()
class ExerciseInstance {
  /// The stable, unique identifier for this exercise combination.
  /// e.g., "press.dumbbell.incline.bilateral.supine"
  final String slug;

  /// The ID of the parent family, e.g., "press".
  final String familyId;

  /// The human-readable name generated by the DXG engine.
  /// e.g., "Incline Dumbbell Press"
  final String displayName;

  /// The map of selected discriminators that define this unique exercise.
  final Map<String, String> discriminators;

  /// The timestamp of when this exercise was first logged.
  final DateTime firstSeenAt;

  const ExerciseInstance({
    required this.slug,
    required this.familyId,
    required this.displayName,
    required this.discriminators,
    required this.firstSeenAt,
  });

  /// Factory constructor for creating a new ExerciseInstance instance from a map.
  /// This is used by the `json_serializable` package.
  factory ExerciseInstance.fromJson(Map<String, dynamic> json) =>
      _$ExerciseInstanceFromJson(json);

  /// Converts this ExerciseInstance instance to a map.
  /// This is used by the `json_serializable` package.
  Map<String, dynamic> toJson() => _$ExerciseInstanceToJson(this);

  /// Manually implemented `hashCode` for value equality.
  /// It uses `DeepCollectionEquality` to correctly hash the `discriminators` map.
  @override
  int get hashCode => Object.hash(
        slug,
        familyId,
        displayName,
        const DeepCollectionEquality().hash(discriminators),
        firstSeenAt,
      );

  /// Manually implemented `operator ==` for value equality.
  /// It uses `DeepCollectionEquality` to correctly compare the `discriminators` map.
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is ExerciseInstance &&
        other.slug == slug &&
        other.familyId == familyId &&
        other.displayName == displayName &&
        const DeepCollectionEquality()
            .equals(other.discriminators, discriminators) &&
        other.firstSeenAt == firstSeenAt;
  }
}

// -----------------------------------------------------------------------------
// --- DRIFT TYPE CONVERTER ----------------------------------------------------
// -----------------------------------------------------------------------------
// This converter is unchanged and works with the new class definition.
// It handles the conversion between the Map<String, String> and a JSON string
// for storage in the Drift database.
// -----------------------------------------------------------------------------

class DiscriminatorsConverter extends TypeConverter<Map<String, String>, String> {
  const DiscriminatorsConverter();

  @override
  Map<String, String> fromSql(String fromDb) {
    final decodedMap = json.decode(fromDb) as Map<String, dynamic>;
    return decodedMap.map((key, value) => MapEntry(key, value.toString()));
  }

  @override
  String toSql(Map<String, String> value) {
    return json.encode(value);
  }
}