===== TREES ===== 
Folder PATH listing for volume DATA1
Volume serial number is 247C-8FD2
D:\FAIRWARE_LIFT\LIB
|   firebase_options.dart
|   main.dart
|   
\---src
    +---app
    |       shell.dart
    |       
    +---core
    |   +---services
    |   |       alert_service.dart
    |   |       
    |   \---theme
    |       |   app_theme.dart
    |       |   
    |       \---data
    |           \---local
    |                   database.dart
    |                   database.g.dart
    |                   
    \---features
        +---dxg
        |   +---application
        |   |       dxg_state.dart
        |   |       dxg_state.freezed.dart
        |   |       guardrail_service.dart
        |   |       name_slug_service.dart
        |   |       warmup_service.dart
        |   |       
        |   +---domain
        |   |       dxg_enums.dart
        |   |       exercise_instance.dart
        |   |       exercise_instance.g.dart
        |   |       movement_family.dart
        |   |       movement_family.freezed.dart
        |   |       movement_family.g.dart
        |   |       warmup_item.dart
        |   |       warmup_item.freezed.dart
        |   |       warmup_item.g.dart
        |   |       
        |   \---presentation
        |           dxg_exercise_picker_screen.dart
        |           
        +---exercises
        |   +---data
        |   |   |   exercise_repository.dart
        |   |   |   
        |   |   \---presentation
        |   |           exercise_picker_screen.dart
        |   |           
        |   \---domain
        |           exercise.dart
        |           
        +---history
        |   +---application
        |   |       history_state.dart
        |   |       
        |   \---presentation
        |           history_screen.dart
        |           
        +---llm_prompting
        |   +---application
        |   |       prompt_generation_service.dart
        |   |       
        |   \---presentation
        |           llm_intake_screen.dart
        |           
        +---measurements
        |   +---data
        |   |       measurements_repository.dart
        |   |       
        |   \---presentation
        |           add_measurement_sheet.dart
        |           measurements_screen.dart
        |           
        +---programs
        |   \---presentation
        |           programs_screen.dart
        |           
        +---prompt_studio
        |   +---application
        |   |       prompt_compiler.dart
        |   |       
        |   \---presentation
        |       |   prompt_studio_page.dart
        |       |   
        |       +---sheets
        |       |       coach_setup_sheet.dart
        |       |       coach_switchboard_sheet.dart
        |       |       data_whisperer_sheet.dart
        |       |       
        |       \---widgets
        |               prompt_card.dart
        |               
        +---settings
        |   +---application
        |   |       settings_provider.dart
        |   |       
        |   \---presentation
        |           settings_screen.dart
        |           
        +---today
        |   +---application
        |   |       today_state.dart
        |   |       
        |   \---presentation
        |       |   today_screen.dart
        |       |   
        |       \---widgets
        |               last_workout_preview.dart
        |               llm_prompt_builder_card.dart
        |               prs_badge.dart
        |               session_preview.dart
        |               start_continue_cta.dart
        |               today_header.dart
        |               
        +---user_profile
        |   +---application
        |   |       user_profile_service.dart
        |   |       
        |   \---domain
        |           user_profile.dart
        |           user_profile.freezed.dart
        |           user_profile.g.dart
        |           
        +---workout
        |   +---application
        |   |       session_state.dart
        |   |       timer_state.dart
        |   |       wear_timer_sync_service.dart
        |   |       
        |   +---domain
        |   |       logged_set.dart
        |   |       session_item.dart
        |   |       session_item.freezed.dart
        |   |       
        |   \---presentation
        |       |   session_screen.dart
        |       |   start_workout_options_screen.dart
        |       |   workout_summary_screen.dart
        |       |   
        |       \---widgets
        |               duration_picker_sheet.dart
        |               exercise_list_item.dart
        |               keypad_duration_picker.dart
        |               reps_only_set_sheet.dart
        |               set_sheet.dart
        |               timed_set_sheet.dart
        |               warmup_list_item.dart
        |               workout_dock.dart
        |               
        \---workout_import
            +---application
            |       lift_dsl_schema.dart
            |       lift_dsl_validator.dart
            |       lift_hash.dart
            |       lift_importer.dart
            |       lift_matcher.dart
            |       lift_normalizer.dart
            |       text_norm.dart
            |       
            +---domain
            |       lift_dsl.dart
            |       
            \---presentation
                    paste_workout_screen.dart
                    
Folder PATH listing for volume DATA1
Volume serial number is 247C-8FD2
D:\FAIRWARE_LIFT\ANDROID
|   .gitignore
|   build.gradle.kts
|   fairware_lift_android.iml
|   gradle.properties
|   gradlew
|   gradlew.bat
|   local.properties
|   settings.gradle.kts
|   tasks.txt
|   
+---.gradle
|   |   file-system.probe
|   |   
|   +---8.12
|   |   |   gc.properties
|   |   |   
|   |   +---checksums
|   |   |       checksums.lock
|   |   |       md5-checksums.bin
|   |   |       sha1-checksums.bin
|   |   |       
|   |   +---executionHistory
|   |   |       executionHistory.bin
|   |   |       executionHistory.lock
|   |   |       
|   |   +---expanded
|   |   +---fileChanges
|   |   |       last-build.bin
|   |   |       
|   |   +---fileHashes
|   |   |       fileHashes.bin
|   |   |       fileHashes.lock
|   |   |       resourceHashesCache.bin
|   |   |       
|   |   \---vcsMetadata
|   +---buildOutputCleanup
|   |       buildOutputCleanup.lock
|   |       cache.properties
|   |       outputFiles.bin
|   |       
|   +---noVersion
|   |       buildLogic.lock
|   |       
|   \---vcs-1
|           gc.properties
|           
+---.kotlin
|   \---sessions
+---app
|   |   build.gradle.kts
|   |   google-services.json
|   |   
|   +---.cxx
|   |   \---Debug
|   |       \---3gw3g4t4
|   |           |   hash_key.txt
|   |           |   
|   |           +---arm64-v8a
|   |           |   |   additional_project_files.txt
|   |           |   |   android_gradle_build.json
|   |           |   |   android_gradle_build_mini.json
|   |           |   |   build.ninja
|   |           |   |   build_file_index.txt
|   |           |   |   CMakeCache.txt
|   |           |   |   cmake_install.cmake
|   |           |   |   configure_fingerprint.bin
|   |           |   |   metadata_generation_command.txt
|   |           |   |   prefab_config.json
|   |           |   |   symbol_folder_index.txt
|   |           |   |   
|   |           |   +---.cmake
|   |           |   |   \---api
|   |           |   |       \---v1
|   |           |   |           +---query
|   |           |   |           |   \---client-agp
|   |           |   |           |           cache-v2
|   |           |   |           |           cmakeFiles-v1
|   |           |   |           |           codemodel-v2
|   |           |   |           |           
|   |           |   |           \---reply
|   |           |   |                   cache-v2-ed91cef8e79a5d03039f.json
|   |           |   |                   cmakeFiles-v1-380acb5f09261f724488.json
|   |           |   |                   codemodel-v2-a6f38aae93741e5470c8.json
|   |           |   |                   directory-.-Debug-d0094a50bb2071803777.json
|   |           |   |                   index-2025-10-28T18-22-34-0984.json
|   |           |   |                   
|   |           |   \---CMakeFiles
|   |           |       |   cmake.check_cache
|   |           |       |   CMakeOutput.log
|   |           |       |   rules.ninja
|   |           |       |   TargetDirectories.txt
|   |           |       |   
|   |           |       +---3.22.1-g37088a8-dirty
|   |           |       |   |   CMakeCCompiler.cmake
|   |           |       |   |   CMakeCXXCompiler.cmake
|   |           |       |   |   CMakeDetermineCompilerABI_C.bin
|   |           |       |   |   CMakeDetermineCompilerABI_CXX.bin
|   |           |       |   |   CMakeSystem.cmake
|   |           |       |   |   
|   |           |       |   +---CompilerIdC
|   |           |       |   |   |   CMakeCCompilerId.c
|   |           |       |   |   |   CMakeCCompilerId.o
|   |           |       |   |   |   
|   |           |       |   |   \---tmp
|   |           |       |   \---CompilerIdCXX
|   |           |       |       |   CMakeCXXCompilerId.cpp
|   |           |       |       |   CMakeCXXCompilerId.o
|   |           |       |       |   
|   |           |       |       \---tmp
|   |           |       \---CMakeTmp
|   |           +---armeabi-v7a
|   |           |   |   additional_project_files.txt
|   |           |   |   android_gradle_build.json
|   |           |   |   android_gradle_build_mini.json
|   |           |   |   build.ninja
|   |           |   |   build_file_index.txt
|   |           |   |   CMakeCache.txt
|   |           |   |   cmake_install.cmake
|   |           |   |   configure_fingerprint.bin
|   |           |   |   metadata_generation_command.txt
|   |           |   |   prefab_config.json
|   |           |   |   symbol_folder_index.txt
|   |           |   |   
|   |           |   +---.cmake
|   |           |   |   \---api
|   |           |   |       \---v1
|   |           |   |           +---query
|   |           |   |           |   \---client-agp
|   |           |   |           |           cache-v2
|   |           |   |           |           cmakeFiles-v1
|   |           |   |           |           codemodel-v2
|   |           |   |           |           
|   |           |   |           \---reply
|   |           |   |                   cache-v2-5fa26a31e4ee0d62f7f1.json
|   |           |   |                   cmakeFiles-v1-48739be3ae577d90e5eb.json
|   |           |   |                   codemodel-v2-c47b7d9dbc1e3eb3925d.json
|   |           |   |                   directory-.-Debug-d0094a50bb2071803777.json
|   |           |   |                   index-2025-10-28T18-22-36-0033.json
|   |           |   |                   
|   |           |   \---CMakeFiles
|   |           |       |   cmake.check_cache
|   |           |       |   CMakeOutput.log
|   |           |       |   rules.ninja
|   |           |       |   TargetDirectories.txt
|   |           |       |   
|   |           |       +---3.22.1-g37088a8-dirty
|   |           |       |   |   CMakeCCompiler.cmake
|   |           |       |   |   CMakeCXXCompiler.cmake
|   |           |       |   |   CMakeDetermineCompilerABI_C.bin
|   |           |       |   |   CMakeDetermineCompilerABI_CXX.bin
|   |           |       |   |   CMakeSystem.cmake
|   |           |       |   |   
|   |           |       |   +---CompilerIdC
|   |           |       |   |   |   CMakeCCompilerId.c
|   |           |       |   |   |   CMakeCCompilerId.o
|   |           |       |   |   |   
|   |           |       |   |   \---tmp
|   |           |       |   \---CompilerIdCXX
|   |           |       |       |   CMakeCXXCompilerId.cpp
|   |           |       |       |   CMakeCXXCompilerId.o
|   |           |       |       |   
|   |           |       |       \---tmp
|   |           |       \---CMakeTmp
|   |           +---x86
|   |           |   |   additional_project_files.txt
|   |           |   |   android_gradle_build.json
|   |           |   |   android_gradle_build_mini.json
|   |           |   |   build.ninja
|   |           |   |   build_file_index.txt
|   |           |   |   CMakeCache.txt
|   |           |   |   cmake_install.cmake
|   |           |   |   configure_fingerprint.bin
|   |           |   |   metadata_generation_command.txt
|   |           |   |   prefab_config.json
|   |           |   |   symbol_folder_index.txt
|   |           |   |   
|   |           |   +---.cmake
|   |           |   |   \---api
|   |           |   |       \---v1
|   |           |   |           +---query
|   |           |   |           |   \---client-agp
|   |           |   |           |           cache-v2
|   |           |   |           |           cmakeFiles-v1
|   |           |   |           |           codemodel-v2
|   |           |   |           |           
|   |           |   |           \---reply
|   |           |   |                   cache-v2-0f4b2b076beb113634ce.json
|   |           |   |                   cmakeFiles-v1-01389aa4e06e9a4ff7e8.json
|   |           |   |                   codemodel-v2-3d95a4b02e4841e9e0e6.json
|   |           |   |                   directory-.-Debug-d0094a50bb2071803777.json
|   |           |   |                   index-2025-10-28T18-22-36-0814.json
|   |           |   |                   
|   |           |   \---CMakeFiles
|   |           |       |   cmake.check_cache
|   |           |       |   CMakeOutput.log
|   |           |       |   rules.ninja
|   |           |       |   TargetDirectories.txt
|   |           |       |   
|   |           |       +---3.22.1-g37088a8-dirty
|   |           |       |   |   CMakeCCompiler.cmake
|   |           |       |   |   CMakeCXXCompiler.cmake
|   |           |       |   |   CMakeDetermineCompilerABI_C.bin
|   |           |       |   |   CMakeDetermineCompilerABI_CXX.bin
|   |           |       |   |   CMakeSystem.cmake
|   |           |       |   |   
|   |           |       |   +---CompilerIdC
|   |           |       |   |   |   CMakeCCompilerId.c
|   |           |       |   |   |   CMakeCCompilerId.o
|   |           |       |   |   |   
|   |           |       |   |   \---tmp
|   |           |       |   \---CompilerIdCXX
|   |           |       |       |   CMakeCXXCompilerId.cpp
|   |           |       |       |   CMakeCXXCompilerId.o
|   |           |       |       |   
|   |           |       |       \---tmp
|   |           |       \---CMakeTmp
|   |           \---x86_64
|   |               |   additional_project_files.txt
|   |               |   android_gradle_build.json
|   |               |   android_gradle_build_mini.json
|   |               |   build.ninja
|   |               |   build_file_index.txt
|   |               |   CMakeCache.txt
|   |               |   cmake_install.cmake
|   |               |   configure_fingerprint.bin
|   |               |   metadata_generation_command.txt
|   |               |   prefab_config.json
|   |               |   symbol_folder_index.txt
|   |               |   
|   |               +---.cmake
|   |               |   \---api
|   |               |       \---v1
|   |               |           +---query
|   |               |           |   \---client-agp
|   |               |           |           cache-v2
|   |               |           |           cmakeFiles-v1
|   |               |           |           codemodel-v2
|   |               |           |           
|   |               |           \---reply
|   |               |                   cache-v2-80231ba64168f88f8c5f.json
|   |               |                   cmakeFiles-v1-a1a2fbd356543e868185.json
|   |               |                   codemodel-v2-afcc34498d251bcea0a0.json
|   |               |                   directory-.-Debug-d0094a50bb2071803777.json
|   |               |                   index-2025-10-28T18-22-37-0520.json
|   |               |                   
|   |               \---CMakeFiles
|   |                   |   cmake.check_cache
|   |                   |   CMakeOutput.log
|   |                   |   rules.ninja
|   |                   |   TargetDirectories.txt
|   |                   |   
|   |                   +---3.22.1-g37088a8-dirty
|   |                   |   |   CMakeCCompiler.cmake
|   |                   |   |   CMakeCXXCompiler.cmake
|   |                   |   |   CMakeDetermineCompilerABI_C.bin
|   |                   |   |   CMakeDetermineCompilerABI_CXX.bin
|   |                   |   |   CMakeSystem.cmake
|   |                   |   |   
|   |                   |   +---CompilerIdC
|   |                   |   |   |   CMakeCCompilerId.c
|   |                   |   |   |   CMakeCCompilerId.o
|   |                   |   |   |   
|   |                   |   |   \---tmp
|   |                   |   \---CompilerIdCXX
|   |                   |       |   CMakeCXXCompilerId.cpp
|   |                   |       |   CMakeCXXCompilerId.o
|   |                   |       |   
|   |                   |       \---tmp
|   |                   \---CMakeTmp
|   +---build
|   |   +---generated
|   |   |   +---ap_generated_sources
|   |   |   |   \---debug
|   |   |   |       \---out
|   |   |   +---crashlytics
|   |   |   |   \---res
|   |   |   |       \---debug
|   |   |   |           \---values
|   |   |   |                   com_crashlytics_build_id.xml
|   |   |   |                   
|   |   |   \---res
|   |   |       +---google-services
|   |   |       |   \---debug
|   |   |       |       \---values
|   |   |       |               values.xml
|   |   |       |               
|   |   |       +---pngs
|   |   |       |   \---debug
|   |   |       \---resValues
|   |   |           \---debug
|   |   +---intermediates
|   |   |   +---aar_metadata_check
|   |   |   |   \---debug
|   |   |   |       \---checkDebugAarMetadata
|   |   |   +---annotation_processor_list
|   |   |   |   \---debug
|   |   |   |       \---javaPreCompileDebug
|   |   |   |               annotationProcessors.json
|   |   |   |               
|   |   |   +---apk_ide_redirect_file
|   |   |   |   \---debug
|   |   |   |       \---createDebugApkListingFileRedirect
|   |   |   |               redirect.txt
|   |   |   |               
|   |   |   +---app_metadata
|   |   |   |   \---debug
|   |   |   |       \---writeDebugAppMetadata
|   |   |   |               app-metadata.properties
|   |   |   |               
|   |   |   +---assets
|   |   |   |   \---debug
|   |   |   |       \---mergeDebugAssets
|   |   |   |           \---flutter_assets
|   |   |   |               |   AssetManifest.bin
|   |   |   |               |   AssetManifest.json
|   |   |   |               |   FontManifest.json
|   |   |   |               |   isolate_snapshot_data
|   |   |   |               |   kernel_blob.bin
|   |   |   |               |   NativeAssetsManifest.json
|   |   |   |               |   NOTICES.Z
|   |   |   |               |   vm_snapshot_data
|   |   |   |               |   
|   |   |   |               +---assets
|   |   |   |               |   +---audio
|   |   |   |               |   |       timer_complete.mp3
|   |   |   |               |   |       timer_warning.mp3
|   |   |   |               |   |       
|   |   |   |               |   +---data
|   |   |   |               |   |       fairware_exercise_library.csv
|   |   |   |               |   |       lift_aliases.json
|   |   |   |               |   |       lift_rules.json
|   |   |   |               |   |       
|   |   |   |               |   \---dxg
|   |   |   |               |           movement_families.seed.json
|   |   |   |               |           synonyms.map.json
|   |   |   |               |           warmup_items.seed.json
|   |   |   |               |           
|   |   |   |               +---fonts
|   |   |   |               |       MaterialIcons-Regular.otf
|   |   |   |               |       
|   |   |   |               \---shaders
|   |   |   |                       ink_sparkle.frag
|   |   |   |                       
|   |   |   +---compatible_screen_manifest
|   |   |   |   \---debug
|   |   |   |       \---createDebugCompatibleScreenManifests
|   |   |   |               output-metadata.json
|   |   |   |               
|   |   |   +---compile_and_runtime_not_namespaced_r_class_jar
|   |   |   |   \---debug
|   |   |   |       \---processDebugResources
|   |   |   |               R.jar
|   |   |   |               
|   |   |   +---compressed_assets
|   |   |   |   \---debug
|   |   |   |       \---compressDebugAssets
|   |   |   |           \---out
|   |   |   |               \---assets
|   |   |   |                   \---flutter_assets
|   |   |   |                       |   AssetManifest.bin.jar
|   |   |   |                       |   AssetManifest.json.jar
|   |   |   |                       |   FontManifest.json.jar
|   |   |   |                       |   isolate_snapshot_data.jar
|   |   |   |                       |   kernel_blob.bin.jar
|   |   |   |                       |   NativeAssetsManifest.json.jar
|   |   |   |                       |   NOTICES.Z.jar
|   |   |   |                       |   vm_snapshot_data.jar
|   |   |   |                       |   
|   |   |   |                       +---assets
|   |   |   |                       |   +---audio
|   |   |   |                       |   |       timer_complete.mp3.jar
|   |   |   |                       |   |       timer_warning.mp3.jar
|   |   |   |                       |   |       
|   |   |   |                       |   +---data
|   |   |   |                       |   |       fairware_exercise_library.csv.jar
|   |   |   |                       |   |       lift_aliases.json.jar
|   |   |   |                       |   |       lift_rules.json.jar
|   |   |   |                       |   |       
|   |   |   |                       |   \---dxg
|   |   |   |                       |           movement_families.seed.json.jar
|   |   |   |                       |           synonyms.map.json.jar
|   |   |   |                       |           warmup_items.seed.json.jar
|   |   |   |                       |           
|   |   |   |                       +---fonts
|   |   |   |                       |       MaterialIcons-Regular.otf.jar
|   |   |   |                       |       
|   |   |   |                       \---shaders
|   |   |   |                               ink_sparkle.frag.jar
|   |   |   |                               
|   |   |   +---cxx
|   |   |   |   \---Debug
|   |   |   |       \---3gw3g4t4
|   |   |   |           +---logs
|   |   |   |           |   +---arm64-v8a
|   |   |   |           |   |       build_model.json
|   |   |   |           |   |       configure_command.bat
|   |   |   |           |   |       configure_stderr.txt
|   |   |   |           |   |       configure_stdout.txt
|   |   |   |           |   |       generate_cxx_metadata_1185_timing.txt
|   |   |   |           |   |       generate_cxx_metadata_604_timing.txt
|   |   |   |           |   |       metadata_generation_record.json
|   |   |   |           |   |       
|   |   |   |           |   +---armeabi-v7a
|   |   |   |           |   |       build_model.json
|   |   |   |           |   |       configure_command.bat
|   |   |   |           |   |       configure_stderr.txt
|   |   |   |           |   |       configure_stdout.txt
|   |   |   |           |   |       generate_cxx_metadata_1174_timing.txt
|   |   |   |           |   |       generate_cxx_metadata_601_timing.txt
|   |   |   |           |   |       metadata_generation_record.json
|   |   |   |           |   |       
|   |   |   |           |   +---x86
|   |   |   |           |   |       build_model.json
|   |   |   |           |   |       configure_command.bat
|   |   |   |           |   |       configure_stderr.txt
|   |   |   |           |   |       configure_stdout.txt
|   |   |   |           |   |       generate_cxx_metadata_1185_timing.txt
|   |   |   |           |   |       generate_cxx_metadata_604_timing.txt
|   |   |   |           |   |       metadata_generation_record.json
|   |   |   |           |   |       
|   |   |   |           |   \---x86_64
|   |   |   |           |           build_model.json
|   |   |   |           |           configure_command.bat
|   |   |   |           |           configure_stderr.txt
|   |   |   |           |           configure_stdout.txt
|   |   |   |           |           generate_cxx_metadata_1174_timing.txt
|   |   |   |           |           generate_cxx_metadata_604_timing.txt
|   |   |   |           |           metadata_generation_record.json
|   |   |   |           |           
|   |   |   |           \---obj
|   |   |   |               +---arm64-v8a
|   |   |   |               +---armeabi-v7a
|   |   |   |               +---x86
|   |   |   |               \---x86_64
|   |   |   +---data_binding_layout_info_type_merge
|   |   |   |   \---debug
|   |   |   |       \---mergeDebugResources
|   |   |   |           \---out
|   |   |   +---data_binding_layout_info_type_package
|   |   |   |   \---debug
|   |   |   |       \---packageDebugResources
|   |   |   |           \---out
|   |   |   +---desugar_graph
|   |   |   |   \---debug
|   |   |   |       \---dexBuilderDebug
|   |   |   |           \---out
|   |   |   |               +---currentProject
|   |   |   |               |   +---dirs_bucket_0
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_1
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_10
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_11
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_12
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_13
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_14
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_15
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_2
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_3
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_4
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_5
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_6
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_7
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_8
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---dirs_bucket_9
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_0
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_1
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_10
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_11
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_12
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_13
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_14
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_15
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_2
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_3
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_4
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_5
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_6
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_7
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   +---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_8
|   |   |   |               |   |       graph.bin
|   |   |   |               |   |       
|   |   |   |               |   \---jar_9a259afed52561c3f941e3342b5dcd64eba5d8b48d959b9354f8c4cd3bd8bad5_bucket_9
|   |   |   |               |           graph.bin
|   |   |   |               |           
|   |   |   |               +---externalLibs
|   |   |   |               +---mixedScopes
|   |   |   |               \---otherProjects
|   |   |   +---desugar_lib_dex
|   |   |   |   \---debug
|   |   |   |       \---l8DexDesugarLibDebug
|   |   |   |               classes1000.dex
|   |   |   |               
|   |   |   +---dex
|   |   |   |   \---debug
|   |   |   |       +---mergeExtDexDebug
|   |   |   |       |       classes.dex
|   |   |   |       |       classes2.dex
|   |   |   |       |       classes3.dex
|   |   |   |       |       
|   |   |   |       +---mergeLibDexDebug
|   |   |   |       |   +---0
|   |   |   |       |   |       classes.dex
|   |   |   |       |   |       
|   |   |   |       |   +---1
|   |   |   |       |   +---10
|   |   |   |       |   +---11
|   |   |   |       |   +---12
|   |   |   |       |   +---13
|   |   |   |       |   +---14
|   |   |   |       |   +---15
|   |   |   |       |   +---2
|   |   |   |       |   +---3
|   |   |   |       |   +---4
|   |   |   |       |   +---5
|   |   |   |       |   +---6
|   |   |   |       |   +---7
|   |   |   |       |   +---8
|   |   |   |       |   \---9
|   |   |   |       \---mergeProjectDexDebug
|   |   |   |           +---0
|   |   |   |           |       classes.dex
|   |   |   |           |       
|   |   |   |           +---1
|   |   |   |           |       classes.dex
|   |   |   |           |       
|   |   |   |           +---10
|   |   |   |           +---11
|   |   |   |           +---12
|   |   |   |           +---13
|   |   |   |           +---14
|   |   |   |           +---15
|   |   |   |           +---2
|   |   |   |           +---3
|   |   |   |           +---4
|   |   |   |           +---5
|   |   |   |           +---6
|   |   |   |           +---7
|   |   |   |           +---8
|   |   |   |           |       classes.dex
|   |   |   |           |       
|   |   |   |           \---9
|   |   |   +---dex_archive_input_jar_hashes
|   |   |   |   \---debug
|   |   |   |       \---dexBuilderDebug
|   |   |   |               out
|   |   |   |               
|   |   |   +---dex_number_of_buckets_file
|   |   |   |   \---debug
|   |   |   |       \---dexBuilderDebug
|   |   |   |               out
|   |   |   |               
|   |   |   +---duplicate_classes_check
|   |   |   |   \---debug
|   |   |   |       \---checkDebugDuplicateClasses
|   |   |   +---external_file_lib_dex_archives
|   |   |   |   \---debug
|   |   |   |       \---desugarDebugFileDependencies
|   |   |   +---external_libs_dex_archive
|   |   |   |   \---debug
|   |   |   |       \---dexBuilderDebug
|   |   |   |           \---out
|   |   |   +---external_libs_dex_archive_with_artifact_transforms
|   |   |   |   \---debug
|   |   |   |       \---dexBuilderDebug
|   |   |   |           \---out
|   |   |   +---flutter
|   |   |   |   \---debug
|   |   |   |       |   .last_build_id
|   |   |   |       |   flutter_build.d
|   |   |   |       |   libs.jar
|   |   |   |       |   
|   |   |   |       \---flutter_assets
|   |   |   |           |   AssetManifest.bin
|   |   |   |           |   AssetManifest.json
|   |   |   |           |   FontManifest.json
|   |   |   |           |   isolate_snapshot_data
|   |   |   |           |   kernel_blob.bin
|   |   |   |           |   NativeAssetsManifest.json
|   |   |   |           |   NOTICES.Z
|   |   |   |           |   vm_snapshot_data
|   |   |   |           |   
|   |   |   |           +---assets
|   |   |   |           |   +---audio
|   |   |   |           |   |       timer_complete.mp3
|   |   |   |           |   |       timer_warning.mp3
|   |   |   |           |   |       
|   |   |   |           |   +---data
|   |   |   |           |   |       fairware_exercise_library.csv
|   |   |   |           |   |       lift_aliases.json
|   |   |   |           |   |       lift_rules.json
|   |   |   |           |   |       
|   |   |   |           |   \---dxg
|   |   |   |           |           movement_families.seed.json
|   |   |   |           |           synonyms.map.json
|   |   |   |           |           warmup_items.seed.json
|   |   |   |           |           
|   |   |   |           +---fonts
|   |   |   |           |       MaterialIcons-Regular.otf
|   |   |   |           |       
|   |   |   |           \---shaders
|   |   |   |                   ink_sparkle.frag
|   |   |   |                   
|   |   |   +---incremental
|   |   |   |   +---debug
|   |   |   |   |   +---mergeDebugResources
|   |   |   |   |   |   |   compile-file-map.properties
|   |   |   |   |   |   |   merger.xml
|   |   |   |   |   |   |   
|   |   |   |   |   |   +---merged.dir
|   |   |   |   |   |   |   +---values
|   |   |   |   |   |   |   |       values.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-af
|   |   |   |   |   |   |   |       values-af.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-am
|   |   |   |   |   |   |   |       values-am.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-ar
|   |   |   |   |   |   |   |       values-ar.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-as
|   |   |   |   |   |   |   |       values-as.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-az
|   |   |   |   |   |   |   |       values-az.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-b+sr+Latn
|   |   |   |   |   |   |   |       values-b+sr+Latn.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-be
|   |   |   |   |   |   |   |       values-be.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-bg
|   |   |   |   |   |   |   |       values-bg.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-bn
|   |   |   |   |   |   |   |       values-bn.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-bs
|   |   |   |   |   |   |   |       values-bs.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-ca
|   |   |   |   |   |   |   |       values-ca.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-cs
|   |   |   |   |   |   |   |       values-cs.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-da
|   |   |   |   |   |   |   |       values-da.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-de
|   |   |   |   |   |   |   |       values-de.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-el
|   |   |   |   |   |   |   |       values-el.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-en-rAU
|   |   |   |   |   |   |   |       values-en-rAU.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-en-rCA
|   |   |   |   |   |   |   |       values-en-rCA.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-en-rGB
|   |   |   |   |   |   |   |       values-en-rGB.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-en-rIN
|   |   |   |   |   |   |   |       values-en-rIN.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-en-rXC
|   |   |   |   |   |   |   |       values-en-rXC.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-es
|   |   |   |   |   |   |   |       values-es.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-es-rUS
|   |   |   |   |   |   |   |       values-es-rUS.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-et
|   |   |   |   |   |   |   |       values-et.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-eu
|   |   |   |   |   |   |   |       values-eu.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-fa
|   |   |   |   |   |   |   |       values-fa.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-fi
|   |   |   |   |   |   |   |       values-fi.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-fr
|   |   |   |   |   |   |   |       values-fr.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-fr-rCA
|   |   |   |   |   |   |   |       values-fr-rCA.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-gl
|   |   |   |   |   |   |   |       values-gl.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-gu
|   |   |   |   |   |   |   |       values-gu.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-h720dp-v13
|   |   |   |   |   |   |   |       values-h720dp-v13.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-hdpi-v4
|   |   |   |   |   |   |   |       values-hdpi-v4.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-hi
|   |   |   |   |   |   |   |       values-hi.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-hr
|   |   |   |   |   |   |   |       values-hr.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-hu
|   |   |   |   |   |   |   |       values-hu.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-hy
|   |   |   |   |   |   |   |       values-hy.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-in
|   |   |   |   |   |   |   |       values-in.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-is
|   |   |   |   |   |   |   |       values-is.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-it
|   |   |   |   |   |   |   |       values-it.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-iw
|   |   |   |   |   |   |   |       values-iw.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-ja
|   |   |   |   |   |   |   |       values-ja.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-ka
|   |   |   |   |   |   |   |       values-ka.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-kk
|   |   |   |   |   |   |   |       values-kk.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-km
|   |   |   |   |   |   |   |       values-km.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-kn
|   |   |   |   |   |   |   |       values-kn.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-ko
|   |   |   |   |   |   |   |       values-ko.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-ky
|   |   |   |   |   |   |   |       values-ky.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-land
|   |   |   |   |   |   |   |       values-land.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-large-v4
|   |   |   |   |   |   |   |       values-large-v4.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-ldltr-v21
|   |   |   |   |   |   |   |       values-ldltr-v21.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-lo
|   |   |   |   |   |   |   |       values-lo.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-lt
|   |   |   |   |   |   |   |       values-lt.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-lv
|   |   |   |   |   |   |   |       values-lv.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-mk
|   |   |   |   |   |   |   |       values-mk.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-ml
|   |   |   |   |   |   |   |       values-ml.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-mn
|   |   |   |   |   |   |   |       values-mn.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-mr
|   |   |   |   |   |   |   |       values-mr.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-ms
|   |   |   |   |   |   |   |       values-ms.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-my
|   |   |   |   |   |   |   |       values-my.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-nb
|   |   |   |   |   |   |   |       values-nb.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-ne
|   |   |   |   |   |   |   |       values-ne.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-night-v8
|   |   |   |   |   |   |   |       values-night-v8.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-nl
|   |   |   |   |   |   |   |       values-nl.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-or
|   |   |   |   |   |   |   |       values-or.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-pa
|   |   |   |   |   |   |   |       values-pa.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-pl
|   |   |   |   |   |   |   |       values-pl.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-port
|   |   |   |   |   |   |   |       values-port.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-pt
|   |   |   |   |   |   |   |       values-pt.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-pt-rBR
|   |   |   |   |   |   |   |       values-pt-rBR.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-pt-rPT
|   |   |   |   |   |   |   |       values-pt-rPT.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-ro
|   |   |   |   |   |   |   |       values-ro.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-ru
|   |   |   |   |   |   |   |       values-ru.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-si
|   |   |   |   |   |   |   |       values-si.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-sk
|   |   |   |   |   |   |   |       values-sk.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-sl
|   |   |   |   |   |   |   |       values-sl.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-sq
|   |   |   |   |   |   |   |       values-sq.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-sr
|   |   |   |   |   |   |   |       values-sr.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-sv
|   |   |   |   |   |   |   |       values-sv.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-sw
|   |   |   |   |   |   |   |       values-sw.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-sw360dp-v13
|   |   |   |   |   |   |   |       values-sw360dp-v13.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-sw600dp-v13
|   |   |   |   |   |   |   |       values-sw600dp-v13.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-ta
|   |   |   |   |   |   |   |       values-ta.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-te
|   |   |   |   |   |   |   |       values-te.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-th
|   |   |   |   |   |   |   |       values-th.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-tl
|   |   |   |   |   |   |   |       values-tl.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-tr
|   |   |   |   |   |   |   |       values-tr.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-uk
|   |   |   |   |   |   |   |       values-uk.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-ur
|   |   |   |   |   |   |   |       values-ur.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-uz
|   |   |   |   |   |   |   |       values-uz.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-v16
|   |   |   |   |   |   |   |       values-v16.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-v17
|   |   |   |   |   |   |   |       values-v17.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-v18
|   |   |   |   |   |   |   |       values-v18.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-v21
|   |   |   |   |   |   |   |       values-v21.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-v22
|   |   |   |   |   |   |   |       values-v22.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-v23
|   |   |   |   |   |   |   |       values-v23.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-v24
|   |   |   |   |   |   |   |       values-v24.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-v25
|   |   |   |   |   |   |   |       values-v25.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-v26
|   |   |   |   |   |   |   |       values-v26.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-v28
|   |   |   |   |   |   |   |       values-v28.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-vi
|   |   |   |   |   |   |   |       values-vi.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-watch-v20
|   |   |   |   |   |   |   |       values-watch-v20.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-watch-v21
|   |   |   |   |   |   |   |       values-watch-v21.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-xlarge-v4
|   |   |   |   |   |   |   |       values-xlarge-v4.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-zh-rCN
|   |   |   |   |   |   |   |       values-zh-rCN.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-zh-rHK
|   |   |   |   |   |   |   |       values-zh-rHK.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   +---values-zh-rTW
|   |   |   |   |   |   |   |       values-zh-rTW.xml
|   |   |   |   |   |   |   |       
|   |   |   |   |   |   |   \---values-zu
|   |   |   |   |   |   |           values-zu.xml
|   |   |   |   |   |   |           
|   |   |   |   |   |   \---stripped.dir
|   |   |   |   |   \---packageDebugResources
|   |   |   |   |       |   compile-file-map.properties
|   |   |   |   |       |   merger.xml
|   |   |   |   |       |   
|   |   |   |   |       +---merged.dir
|   |   |   |   |       |   +---values
|   |   |   |   |       |   |       values.xml
|   |   |   |   |       |   |       
|   |   |   |   |       |   \---values-night-v8
|   |   |   |   |       |           values-night-v8.xml
|   |   |   |   |       |           
|   |   |   |   |       \---stripped.dir
|   |   |   |   +---debug-mergeJavaRes
|   |   |   |   |   |   merge-state
|   |   |   |   |   |   
|   |   |   |   |   \---zip-cache
|   |   |   |   |           +0MJVIZlFwlpPJgD0qCYEpdFfZI=
|   |   |   |   |           0EqimaX+ziQB4UkO7QclLPcAdkY=
|   |   |   |   |           0TnD7fjASX9ed4N32az5hBdG7_Y=
|   |   |   |   |           0_ZzKAO6Vx0pn5glRkqVy+29axo=
|   |   |   |   |           17KEEc2KE4vJFoOoguKMH7kYDLA=
|   |   |   |   |           1tLGUkjkYsOjZmvvyTZMnfEe2lk=
|   |   |   |   |           2SCQ+xh83c9tbaKKy_iRb9LRfOE=
|   |   |   |   |           3haJaQQTth2UZpoF9uEODRXs8L8=
|   |   |   |   |           3PobOgaxSheAcrjDmhqnxtSJ73E=
|   |   |   |   |           48sJav83ZF15cJFSK7hfEbkSBZM=
|   |   |   |   |           6+PJVNpUIs+083RO9hAMtHU0viA=
|   |   |   |   |           6ERfP2n0lhdl4EcrioI5GrOefDg=
|   |   |   |   |           6HOx_TfC0PgTVDkgoBiCg6_5HX8=
|   |   |   |   |           6QHus3xvAEORlFp4Vzteu1F0oZA=
|   |   |   |   |           6uDuN2bSDWhN7A3HBINTMfNhZMw=
|   |   |   |   |           6wJB8RrCRFYrz6iY7Y1wckm7t_A=
|   |   |   |   |           7J2GqVNQVIoGx_WW5vkWSsHF_ss=
|   |   |   |   |           7q6NSbybGymN5_EYBEKGcW1jwcw=
|   |   |   |   |           7SWtEW3D_Dw_99HcrtuyB4J7y_U=
|   |   |   |   |           7YyEktY0jh4TqUWMkXdtY_avIGo=
|   |   |   |   |           83jF6eb_uulVxlg2zVW0xvvnnic=
|   |   |   |   |           8qSVySJInfZ4fFG+mXe7_uE_DZQ=
|   |   |   |   |           8weIFW5QVAZrQ4e_UzM_VneQohY=
|   |   |   |   |           8wxwtHkxWjj7H0zKSLxEWnHisuA=
|   |   |   |   |           9bb+jVZytqRpK81KuVMWEhplSKQ=
|   |   |   |   |           9Lu9KPGVIakOnLjcQ0lAKUdwLRM=
|   |   |   |   |           9tjeQewxoMLJ+EJgxrghMusNul4=
|   |   |   |   |           9TVqF+nbNnkItGyHOd0srsrkdQ8=
|   |   |   |   |           aa+8ii30sZ7N5T64GLF3VBuF4Y4=
|   |   |   |   |           aFG1lGTFp728mdxy7TaWLRfYuJ8=
|   |   |   |   |           aHFlAZcrEjGot6PaI4ITEHRwrCk=
|   |   |   |   |           AKcENtdKokpyi+279dyt2e21KK0=
|   |   |   |   |           AP1hdJg6cIYmlvtqFHSjRXDkJ6g=
|   |   |   |   |           aUl_r9EFTi5U2LreruN_9htaNSU=
|   |   |   |   |           auRXcqiifmVa5d0XLj61iTPZbVY=
|   |   |   |   |           bc_ozr+XgEav+_O0qDYDHNmCd8U=
|   |   |   |   |           BFG2LgTqZzGroGAspq9zrrVSZ4s=
|   |   |   |   |           BFRwLrtcbPuAkvSu5QP7HyiOwzY=
|   |   |   |   |           BgW3HGCUwfc0lJ4aDvHTAA5Dk9k=
|   |   |   |   |           BhgCm6Gc0wbdwJfenqRzFf1U3b0=
|   |   |   |   |           bNMdAvHR7XhFGROipgIzWoXCxDM=
|   |   |   |   |           Bo17cCS7sXFrqnELTSL+c2rDwBI=
|   |   |   |   |           br+E_8+WEydjZNt6gjOIlP3ASB0=
|   |   |   |   |           bTAcHvI5XB5Eht0S_SOgk5z8NyM=
|   |   |   |   |           c6EEZUWAkQcQOs5XiwUVs2ufYAI=
|   |   |   |   |           cBDZ1xflGKA0ibzo+G8hicS+I4A=
|   |   |   |   |           CqliOkt0u9cq40fDX2auJCmZtCs=
|   |   |   |   |           c_flIX_U0Fb_0RueASJWge77zso=
|   |   |   |   |           Dczd3_RDP8eq1oLofpzeMlRY+Lw=
|   |   |   |   |           DnufU8t00efizyXtCMFsrYhJeqs=
|   |   |   |   |           eflQtvzljqN3LFIrJlT6rVImW9s=
|   |   |   |   |           EsCI6pGYAw7+VHXGr7irNmhekNE=
|   |   |   |   |           EtdCZyNnaoXmmi4_1YQzAJoai9c=
|   |   |   |   |           ex+QURieO0ZcSVZSdmrfogi8jrw=
|   |   |   |   |           F4TmvFruC0vYnheW5MQuc1NZRJs=
|   |   |   |   |           F59eeTN7s0F+RMZ16HNojwR4twM=
|   |   |   |   |           faiZ5a3bq6+15oBxXR_16KvrM2U=
|   |   |   |   |           fb74v80uT69LZRDCh8pagPIXoLI=
|   |   |   |   |           fCXAy64p_hXBOmYQtTNtSrjEXp0=
|   |   |   |   |           fI38elIQ0ODjkp7HX1sZdOtfaUI=
|   |   |   |   |           fZdcP0EtszZ6Da9dKz5GsEwgAas=
|   |   |   |   |           g8atsXJsWPJJLCe7zz8hy1Lnvzs=
|   |   |   |   |           gkKhWj2Wi7rafkMpn4VKxydHoeQ=
|   |   |   |   |           GKSDWC7_QxMgGImn_2WsjXGNN3k=
|   |   |   |   |           GXdevhLidsugJvOxV90bdrpx7vs=
|   |   |   |   |           GXIs9xfup3xU8N3vocFJVE0H7r8=
|   |   |   |   |           hdhMAPEvYp1jj6D+XW1UNo8qCiM=
|   |   |   |   |           hgTosNGE9TfdX4xzO9jV1MTTa+g=
|   |   |   |   |           HnhHa7SCy540zXzzO_SPW1dTWSs=
|   |   |   |   |           HUm2+n2Cm_jPzEu9cZ2y8f5mKhE=
|   |   |   |   |           HvQVd_CXcc4lNVIunUEQ90REGDI=
|   |   |   |   |           I8UNejaie_Jh94Z8zruDAgrDC5Y=
|   |   |   |   |           IZ5nceUmBs_0p+bWY_c7cyT7ezs=
|   |   |   |   |           J1yCKP8DzJ_E57aWPnImf7Aq53s=
|   |   |   |   |           JgdLAKYxDB_YVQP91uJ8vcqaO_g=
|   |   |   |   |           jGMLC8cjF5W5HvzRb+GYzR7gTvY=
|   |   |   |   |           Jnkf3ftskTlsUmYqQ+qV1p6CNS4=
|   |   |   |   |           KAS5w39ZSbXF8zP0qb1lojo7u7Q=
|   |   |   |   |           kB0+omGr4V0mwc7ybwFxVYv5l_Y=
|   |   |   |   |           KE8IxPJBdgtWeDIZrzSzTMoqyQI=
|   |   |   |   |           kraObhwPCf_Kx3RoBfukW7Szrtk=
|   |   |   |   |           KYnXV+qPu1bAFj+HnPl9UtMU8eg=
|   |   |   |   |           l5iuFlgucG1dSWfJ9Qfkcpe4tpc=
|   |   |   |   |           L66+mdc9uDxWQyCFr6IWXq7cWUQ=
|   |   |   |   |           LEaqOUdtSMbfIV4jRd9cjtboH4I=
|   |   |   |   |           lj5BJ520uGKoxtZuYSQ04vfcdKE=
|   |   |   |   |           lrVvGTkyPFDYE7IiG9LjJjRPNBM=
|   |   |   |   |           LUjKTM3TIO81dA9SiBbTKr05cVk=
|   |   |   |   |           nk1pRW7ozxAhGumLmzpbyr2uIC4=
|   |   |   |   |           nv1wV6a7X4qYpPvj7u2SLIyy7sE=
|   |   |   |   |           nw3Z8q+1Fr1V+6bi5nFO5lDH86c=
|   |   |   |   |           oEk78K8T7OdC1XOVVJUt_G5kzww=
|   |   |   |   |           Ogh9rjRUR67Z8KsaqVm3ioZfTq8=
|   |   |   |   |           OrH5rPC+v3fQ_oP4rN8x1_g5hhM=
|   |   |   |   |           oSJ1DFf2xrMAp_lGUBdwy7tw4BE=
|   |   |   |   |           oYO1hZI7tCSKRBQq_Znl2KlvkIY=
|   |   |   |   |           p+VShmL1_nHgOtj2USbFIxMKGKU=
|   |   |   |   |           PajADh99gD_DeiFn4UguouYOCeI=
|   |   |   |   |           pcKSyKEMwpmazZFiB3eaHYqYKzw=
|   |   |   |   |           PLg4X+q0bjp_6A_QLVvdzIyK07s=
|   |   |   |   |           PORAVBqJptRy6ezoNXLZbKKQP3c=
|   |   |   |   |           pQoHtG5LskAZpuzJs6bkpS5fGAw=
|   |   |   |   |           pT221A3i+u+M9Sm+4zxe3nUtLI8=
|   |   |   |   |           QbwAivfnTkTA9yoR1Vn2zlAH_5I=
|   |   |   |   |           qlvOIJYloDj8H_pwQajifh4ED+s=
|   |   |   |   |           qoeIl9+7KysZy4mNqbrHD92upRk=
|   |   |   |   |           qrMzl1lYzV8neI+AqxsQIM9Dt2s=
|   |   |   |   |           qXOR85LkBNzo0GYH1_l_WiBOnXQ=
|   |   |   |   |           Q_kGE2lOGP_UBVDYJJ1zvvTIAak=
|   |   |   |   |           r3B123Ub3OA2fvVfmRh8b_30I3I=
|   |   |   |   |           rAejmSMxGDnYbfgW0dMToU01gbg=
|   |   |   |   |           rh1haI7kDogQYo+2I64kNQqGyo8=
|   |   |   |   |           rl21s4ZyvAD_0VcJgRKTLhSYMXw=
|   |   |   |   |           rvY7OSDrEV7pJ1Zsge2xZa+bmsw=
|   |   |   |   |           ryTRYICtdQ_YYHotH3fp+IWT38c=
|   |   |   |   |           SHP81USU7FRTuBEaxyu9u6K+Mnw=
|   |   |   |   |           Snzu5+kJie0+733caPrbP+M+6EM=
|   |   |   |   |           SOnLIul_jitHzhiDm8Jl7Bttd8k=
|   |   |   |   |           sTiH1c_wDfKRwoeAzA4tRyu94GU=
|   |   |   |   |           S_B4RXvzM_mdhpRtyG93rTe1yUw=
|   |   |   |   |           taYN8KrysaZXB23fSieAyLwbf7g=
|   |   |   |   |           tDroVxRGk8mMELoWRGNfw56RINM=
|   |   |   |   |           TGCSr_ZSBXkJTVh+pE2qyIXzJLk=
|   |   |   |   |           To2feYDo0az2iAVtNzpQ1wguZxo=
|   |   |   |   |           ToQ5pRPJyBT1A3Tw0sDpnvk6c5E=
|   |   |   |   |           TS02tGYmY8cL323Ck9AEhl21ygA=
|   |   |   |   |           TV5RG1jEFnoL8zJ7YhAyrzltPgY=
|   |   |   |   |           UCDvSRS1Fx0qPgKfOt_GDGT_BzE=
|   |   |   |   |           uIMqtAdpc5rfL5s7TsHG32QS9oE=
|   |   |   |   |           ujwQ6Wws05rO5AucvVFFb8A+EPE=
|   |   |   |   |           uPgeiJoFjZwCnPJe97BujL5xUdw=
|   |   |   |   |           uPXX6ddV0Bz68AKHvyK_X8SEv0g=
|   |   |   |   |           V9ksI1ZinA6HC3LMATZUby_6rdA=
|   |   |   |   |           vQNX0IdW0rAr9aU3gh_4tMlpTX0=
|   |   |   |   |           vzSC91QJ0gfP0yx48prJ9oNBFhw=
|   |   |   |   |           W1Gxk2kUoaay+Ci3vFccKXUGQJ0=
|   |   |   |   |           w64kuqU7_PvwfuTIgpiEdPOvqOA=
|   |   |   |   |           x8L2LT2iGw7vU3Cd6OOvhV5t5IY=
|   |   |   |   |           XhNdSpPFSv8M_PKojc1V4SJngaE=
|   |   |   |   |           XsmGfjTQPNIuXS94+cSNuPHERcE=
|   |   |   |   |           XUTGhdWjf+S1yE_wC2o5aTL6L+0=
|   |   |   |   |           XxNBpuCp3Q4LiwmrjNEKHTEtQ34=
|   |   |   |   |           xySRfpMdEvwtMdjWC6X13FygHX8=
|   |   |   |   |           Y8JF65wuBQCMiWch2zvW7E3tsBo=
|   |   |   |   |           yAIFIqwIJhJwmp6sf8g8iISZ4kI=
|   |   |   |   |           YDD8bkuwO3Y5N_iF+om3UuoNE9Q=
|   |   |   |   |           ykou_L0ixybuzP05D1lwuWtOdqk=
|   |   |   |   |           YQRm5WZyOL925c9E8nKtaJhxsMI=
|   |   |   |   |           YRIDiWEVlSwvdM+NZpY2PFbDn4M=
|   |   |   |   |           YzzKq8X92QbBUQIVclrJn6L3SJ8=
|   |   |   |   |           Z36NGYW4dT6yzWl9w7INyxmOevM=
|   |   |   |   |           _4fUBMqaegjCK46fre7HhM3GvKE=
|   |   |   |   |           _WErXzR57uCETdld+8JjLu9h7Ns=
|   |   |   |   |           
|   |   |   |   +---mergeDebugAssets
|   |   |   |   |       merger.xml
|   |   |   |   |       
|   |   |   |   +---mergeDebugJniLibFolders
|   |   |   |   |       merger.xml
|   |   |   |   |       
|   |   |   |   +---mergeDebugShaders
|   |   |   |   |       merger.xml
|   |   |   |   |       
|   |   |   |   \---packageDebug
|   |   |   |       \---tmp
|   |   |   |           \---debug
|   |   |   |               |   dex-renamer-state.txt
|   |   |   |               |   
|   |   |   |               \---zip-cache
|   |   |   |                       androidResources
|   |   |   |                       javaResources0
|   |   |   |                       
|   |   |   +---javac
|   |   |   |   \---debug
|   |   |   |       \---compileDebugJavaWithJavac
|   |   |   |           \---classes
|   |   |   |               \---io
|   |   |   |                   \---flutter
|   |   |   |                       \---plugins
|   |   |   |                               GeneratedPluginRegistrant.class
|   |   |   |                               
|   |   |   +---java_res
|   |   |   |   \---debug
|   |   |   |       \---processDebugJavaRes
|   |   |   |           \---out
|   |   |   |               +---com
|   |   |   |               |   \---example
|   |   |   |               |       \---fairware_lift
|   |   |   |               \---META-INF
|   |   |   |                       app_debug.kotlin_module
|   |   |   |                       
|   |   |   +---l8_art_profile
|   |   |   |   \---debug
|   |   |   |       \---l8DexDesugarLibDebug
|   |   |   +---linked_resources_binary_format
|   |   |   |   \---debug
|   |   |   |       \---processDebugResources
|   |   |   |               linked-resources-binary-format-debug.ap_
|   |   |   |               output-metadata.json
|   |   |   |               
|   |   |   +---local_only_symbol_list
|   |   |   |   \---debug
|   |   |   |       \---parseDebugLocalResources
|   |   |   |               R-def.txt
|   |   |   |               
|   |   |   +---manifest_merge_blame_file
|   |   |   |   \---debug
|   |   |   |       \---processDebugMainManifest
|   |   |   |               manifest-merger-blame-debug-report.txt
|   |   |   |               
|   |   |   +---merged_java_res
|   |   |   |   \---debug
|   |   |   |       \---mergeDebugJavaResource
|   |   |   |               base.jar
|   |   |   |               
|   |   |   +---merged_jni_libs
|   |   |   |   \---debug
|   |   |   |       \---mergeDebugJniLibFolders
|   |   |   |           \---out
|   |   |   +---merged_manifest
|   |   |   |   \---debug
|   |   |   |       \---processDebugMainManifest
|   |   |   |               AndroidManifest.xml
|   |   |   |               
|   |   |   +---merged_manifests
|   |   |   |   \---debug
|   |   |   |       \---processDebugManifest
|   |   |   |               AndroidManifest.xml
|   |   |   |               output-metadata.json
|   |   |   |               
|   |   |   +---merged_native_libs
|   |   |   |   \---debug
|   |   |   |       \---mergeDebugNativeLibs
|   |   |   |           \---out
|   |   |   |               \---lib
|   |   |   |                   +---arm64-v8a
|   |   |   |                   |       libdatastore_shared_counter.so
|   |   |   |                   |       libflutter.so
|   |   |   |                   |       libsqlite3.so
|   |   |   |                   |       libVkLayer_khronos_validation.so
|   |   |   |                   |       
|   |   |   |                   +---armeabi-v7a
|   |   |   |                   |       libdatastore_shared_counter.so
|   |   |   |                   |       libsqlite3.so
|   |   |   |                   |       
|   |   |   |                   +---x86
|   |   |   |                   |       libdatastore_shared_counter.so
|   |   |   |                   |       
|   |   |   |                   \---x86_64
|   |   |   |                           libdatastore_shared_counter.so
|   |   |   |                           libsqlite3.so
|   |   |   |                           
|   |   |   +---merged_res
|   |   |   |   \---debug
|   |   |   |       \---mergeDebugResources
|   |   |   |               drawable-v21_launch_background.xml.flat
|   |   |   |               mipmap-hdpi_ic_launcher.png.flat
|   |   |   |               mipmap-mdpi_ic_launcher.png.flat
|   |   |   |               mipmap-xhdpi_ic_launcher.png.flat
|   |   |   |               mipmap-xxhdpi_ic_launcher.png.flat
|   |   |   |               mipmap-xxxhdpi_ic_launcher.png.flat
|   |   |   |               values-af_values-af.arsc.flat
|   |   |   |               values-am_values-am.arsc.flat
|   |   |   |               values-ar_values-ar.arsc.flat
|   |   |   |               values-as_values-as.arsc.flat
|   |   |   |               values-az_values-az.arsc.flat
|   |   |   |               values-b+sr+Latn_values-b+sr+Latn.arsc.flat
|   |   |   |               values-be_values-be.arsc.flat
|   |   |   |               values-bg_values-bg.arsc.flat
|   |   |   |               values-bn_values-bn.arsc.flat
|   |   |   |               values-bs_values-bs.arsc.flat
|   |   |   |               values-ca_values-ca.arsc.flat
|   |   |   |               values-cs_values-cs.arsc.flat
|   |   |   |               values-da_values-da.arsc.flat
|   |   |   |               values-de_values-de.arsc.flat
|   |   |   |               values-el_values-el.arsc.flat
|   |   |   |               values-en-rAU_values-en-rAU.arsc.flat
|   |   |   |               values-en-rCA_values-en-rCA.arsc.flat
|   |   |   |               values-en-rGB_values-en-rGB.arsc.flat
|   |   |   |               values-en-rIN_values-en-rIN.arsc.flat
|   |   |   |               values-en-rXC_values-en-rXC.arsc.flat
|   |   |   |               values-es-rUS_values-es-rUS.arsc.flat
|   |   |   |               values-es_values-es.arsc.flat
|   |   |   |               values-et_values-et.arsc.flat
|   |   |   |               values-eu_values-eu.arsc.flat
|   |   |   |               values-fa_values-fa.arsc.flat
|   |   |   |               values-fi_values-fi.arsc.flat
|   |   |   |               values-fr-rCA_values-fr-rCA.arsc.flat
|   |   |   |               values-fr_values-fr.arsc.flat
|   |   |   |               values-gl_values-gl.arsc.flat
|   |   |   |               values-gu_values-gu.arsc.flat
|   |   |   |               values-h720dp-v13_values-h720dp-v13.arsc.flat
|   |   |   |               values-hdpi-v4_values-hdpi-v4.arsc.flat
|   |   |   |               values-hi_values-hi.arsc.flat
|   |   |   |               values-hr_values-hr.arsc.flat
|   |   |   |               values-hu_values-hu.arsc.flat
|   |   |   |               values-hy_values-hy.arsc.flat
|   |   |   |               values-in_values-in.arsc.flat
|   |   |   |               values-is_values-is.arsc.flat
|   |   |   |               values-it_values-it.arsc.flat
|   |   |   |               values-iw_values-iw.arsc.flat
|   |   |   |               values-ja_values-ja.arsc.flat
|   |   |   |               values-ka_values-ka.arsc.flat
|   |   |   |               values-kk_values-kk.arsc.flat
|   |   |   |               values-km_values-km.arsc.flat
|   |   |   |               values-kn_values-kn.arsc.flat
|   |   |   |               values-ko_values-ko.arsc.flat
|   |   |   |               values-ky_values-ky.arsc.flat
|   |   |   |               values-land_values-land.arsc.flat
|   |   |   |               values-large-v4_values-large-v4.arsc.flat
|   |   |   |               values-ldltr-v21_values-ldltr-v21.arsc.flat
|   |   |   |               values-lo_values-lo.arsc.flat
|   |   |   |               values-lt_values-lt.arsc.flat
|   |   |   |               values-lv_values-lv.arsc.flat
|   |   |   |               values-mk_values-mk.arsc.flat
|   |   |   |               values-ml_values-ml.arsc.flat
|   |   |   |               values-mn_values-mn.arsc.flat
|   |   |   |               values-mr_values-mr.arsc.flat
|   |   |   |               values-ms_values-ms.arsc.flat
|   |   |   |               values-my_values-my.arsc.flat
|   |   |   |               values-nb_values-nb.arsc.flat
|   |   |   |               values-ne_values-ne.arsc.flat
|   |   |   |               values-night-v8_values-night-v8.arsc.flat
|   |   |   |               values-nl_values-nl.arsc.flat
|   |   |   |               values-or_values-or.arsc.flat
|   |   |   |               values-pa_values-pa.arsc.flat
|   |   |   |               values-pl_values-pl.arsc.flat
|   |   |   |               values-port_values-port.arsc.flat
|   |   |   |               values-pt-rBR_values-pt-rBR.arsc.flat
|   |   |   |               values-pt-rPT_values-pt-rPT.arsc.flat
|   |   |   |               values-pt_values-pt.arsc.flat
|   |   |   |               values-ro_values-ro.arsc.flat
|   |   |   |               values-ru_values-ru.arsc.flat
|   |   |   |               values-si_values-si.arsc.flat
|   |   |   |               values-sk_values-sk.arsc.flat
|   |   |   |               values-sl_values-sl.arsc.flat
|   |   |   |               values-sq_values-sq.arsc.flat
|   |   |   |               values-sr_values-sr.arsc.flat
|   |   |   |               values-sv_values-sv.arsc.flat
|   |   |   |               values-sw360dp-v13_values-sw360dp-v13.arsc.flat
|   |   |   |               values-sw600dp-v13_values-sw600dp-v13.arsc.flat
|   |   |   |               values-sw_values-sw.arsc.flat
|   |   |   |               values-ta_values-ta.arsc.flat
|   |   |   |               values-te_values-te.arsc.flat
|   |   |   |               values-th_values-th.arsc.flat
|   |   |   |               values-tl_values-tl.arsc.flat
|   |   |   |               values-tr_values-tr.arsc.flat
|   |   |   |               values-uk_values-uk.arsc.flat
|   |   |   |               values-ur_values-ur.arsc.flat
|   |   |   |               values-uz_values-uz.arsc.flat
|   |   |   |               values-v16_values-v16.arsc.flat
|   |   |   |               values-v17_values-v17.arsc.flat
|   |   |   |               values-v18_values-v18.arsc.flat
|   |   |   |               values-v21_values-v21.arsc.flat
|   |   |   |               values-v22_values-v22.arsc.flat
|   |   |   |               values-v23_values-v23.arsc.flat
|   |   |   |               values-v24_values-v24.arsc.flat
|   |   |   |               values-v25_values-v25.arsc.flat
|   |   |   |               values-v26_values-v26.arsc.flat
|   |   |   |               values-v28_values-v28.arsc.flat
|   |   |   |               values-vi_values-vi.arsc.flat
|   |   |   |               values-watch-v20_values-watch-v20.arsc.flat
|   |   |   |               values-watch-v21_values-watch-v21.arsc.flat
|   |   |   |               values-xlarge-v4_values-xlarge-v4.arsc.flat
|   |   |   |               values-zh-rCN_values-zh-rCN.arsc.flat
|   |   |   |               values-zh-rHK_values-zh-rHK.arsc.flat
|   |   |   |               values-zh-rTW_values-zh-rTW.arsc.flat
|   |   |   |               values-zu_values-zu.arsc.flat
|   |   |   |               values_values.arsc.flat
|   |   |   |               
|   |   |   +---merged_res_blame_folder
|   |   |   |   \---debug
|   |   |   |       \---mergeDebugResources
|   |   |   |           \---out
|   |   |   |               +---multi-v2
|   |   |   |               |       mergeDebugResources.json
|   |   |   |               |       values-af.json
|   |   |   |               |       values-am.json
|   |   |   |               |       values-ar.json
|   |   |   |               |       values-as.json
|   |   |   |               |       values-az.json
|   |   |   |               |       values-b+sr+Latn.json
|   |   |   |               |       values-be.json
|   |   |   |               |       values-bg.json
|   |   |   |               |       values-bn.json
|   |   |   |               |       values-bs.json
|   |   |   |               |       values-ca.json
|   |   |   |               |       values-cs.json
|   |   |   |               |       values-da.json
|   |   |   |               |       values-de.json
|   |   |   |               |       values-el.json
|   |   |   |               |       values-en-rAU.json
|   |   |   |               |       values-en-rCA.json
|   |   |   |               |       values-en-rGB.json
|   |   |   |               |       values-en-rIN.json
|   |   |   |               |       values-en-rXC.json
|   |   |   |               |       values-es-rUS.json
|   |   |   |               |       values-es.json
|   |   |   |               |       values-et.json
|   |   |   |               |       values-eu.json
|   |   |   |               |       values-fa.json
|   |   |   |               |       values-fi.json
|   |   |   |               |       values-fr-rCA.json
|   |   |   |               |       values-fr.json
|   |   |   |               |       values-gl.json
|   |   |   |               |       values-gu.json
|   |   |   |               |       values-h720dp-v13.json
|   |   |   |               |       values-hdpi-v4.json
|   |   |   |               |       values-hi.json
|   |   |   |               |       values-hr.json
|   |   |   |               |       values-hu.json
|   |   |   |               |       values-hy.json
|   |   |   |               |       values-in.json
|   |   |   |               |       values-is.json
|   |   |   |               |       values-it.json
|   |   |   |               |       values-iw.json
|   |   |   |               |       values-ja.json
|   |   |   |               |       values-ka.json
|   |   |   |               |       values-kk.json
|   |   |   |               |       values-km.json
|   |   |   |               |       values-kn.json
|   |   |   |               |       values-ko.json
|   |   |   |               |       values-ky.json
|   |   |   |               |       values-land.json
|   |   |   |               |       values-large-v4.json
|   |   |   |               |       values-ldltr-v21.json
|   |   |   |               |       values-lo.json
|   |   |   |               |       values-lt.json
|   |   |   |               |       values-lv.json
|   |   |   |               |       values-mk.json
|   |   |   |               |       values-ml.json
|   |   |   |               |       values-mn.json
|   |   |   |               |       values-mr.json
|   |   |   |               |       values-ms.json
|   |   |   |               |       values-my.json
|   |   |   |               |       values-nb.json
|   |   |   |               |       values-ne.json
|   |   |   |               |       values-night-v8.json
|   |   |   |               |       values-nl.json
|   |   |   |               |       values-or.json
|   |   |   |               |       values-pa.json
|   |   |   |               |       values-pl.json
|   |   |   |               |       values-port.json
|   |   |   |               |       values-pt-rBR.json
|   |   |   |               |       values-pt-rPT.json
|   |   |   |               |       values-pt.json
|   |   |   |               |       values-ro.json
|   |   |   |               |       values-ru.json
|   |   |   |               |       values-si.json
|   |   |   |               |       values-sk.json
|   |   |   |               |       values-sl.json
|   |   |   |               |       values-sq.json
|   |   |   |               |       values-sr.json
|   |   |   |               |       values-sv.json
|   |   |   |               |       values-sw.json
|   |   |   |               |       values-sw360dp-v13.json
|   |   |   |               |       values-sw600dp-v13.json
|   |   |   |               |       values-ta.json
|   |   |   |               |       values-te.json
|   |   |   |               |       values-th.json
|   |   |   |               |       values-tl.json
|   |   |   |               |       values-tr.json
|   |   |   |               |       values-uk.json
|   |   |   |               |       values-ur.json
|   |   |   |               |       values-uz.json
|   |   |   |               |       values-v16.json
|   |   |   |               |       values-v17.json
|   |   |   |               |       values-v18.json
|   |   |   |               |       values-v21.json
|   |   |   |               |       values-v22.json
|   |   |   |               |       values-v23.json
|   |   |   |               |       values-v24.json
|   |   |   |               |       values-v25.json
|   |   |   |               |       values-v26.json
|   |   |   |               |       values-v28.json
|   |   |   |               |       values-vi.json
|   |   |   |               |       values-watch-v20.json
|   |   |   |               |       values-watch-v21.json
|   |   |   |               |       values-xlarge-v4.json
|   |   |   |               |       values-zh-rCN.json
|   |   |   |               |       values-zh-rHK.json
|   |   |   |               |       values-zh-rTW.json
|   |   |   |               |       values-zu.json
|   |   |   |               |       values.json
|   |   |   |               |       
|   |   |   |               \---single
|   |   |   |                       mergeDebugResources.json
|   |   |   |                       
|   |   |   +---merged_shaders
|   |   |   |   \---debug
|   |   |   |       \---mergeDebugShaders
|   |   |   |           \---out
|   |   |   +---merged_test_only_native_libs
|   |   |   |   \---debug
|   |   |   |       \---mergeDebugNativeLibs
|   |   |   |           \---out
|   |   |   +---mixed_scope_dex_archive
|   |   |   |   \---debug
|   |   |   |       \---dexBuilderDebug
|   |   |   |           \---out
|   |   |   +---navigation_json
|   |   |   |   \---debug
|   |   |   |       \---extractDeepLinksDebug
|   |   |   |               navigation.json
|   |   |   |               
|   |   |   +---nested_resources_validation_report
|   |   |   |   \---debug
|   |   |   |       \---generateDebugResources
|   |   |   |               nestedResourcesValidationReport.txt
|   |   |   |               
|   |   |   +---packaged_manifests
|   |   |   |   \---debug
|   |   |   |       \---processDebugManifestForPackage
|   |   |   |               AndroidManifest.xml
|   |   |   |               output-metadata.json
|   |   |   |               
|   |   |   +---packaged_res
|   |   |   |   \---debug
|   |   |   |       \---packageDebugResources
|   |   |   |           +---drawable-v21
|   |   |   |           |       launch_background.xml
|   |   |   |           |       
|   |   |   |           +---mipmap-hdpi-v4
|   |   |   |           |       ic_launcher.png
|   |   |   |           |       
|   |   |   |           +---mipmap-mdpi-v4
|   |   |   |           |       ic_launcher.png
|   |   |   |           |       
|   |   |   |           +---mipmap-xhdpi-v4
|   |   |   |           |       ic_launcher.png
|   |   |   |           |       
|   |   |   |           +---mipmap-xxhdpi-v4
|   |   |   |           |       ic_launcher.png
|   |   |   |           |       
|   |   |   |           +---mipmap-xxxhdpi-v4
|   |   |   |           |       ic_launcher.png
|   |   |   |           |       
|   |   |   |           +---values
|   |   |   |           |       values.xml
|   |   |   |           |       
|   |   |   |           \---values-night-v8
|   |   |   |                   values-night-v8.xml
|   |   |   |                   
|   |   |   +---project_dex_archive
|   |   |   |   \---debug
|   |   |   |       \---dexBuilderDebug
|   |   |   |           \---out
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_0.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_1.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_10.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_11.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_12.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_13.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_14.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_15.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_2.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_3.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_4.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_5.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_6.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_7.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_8.jar
|   |   |   |               |   c729eb15711cd69df49752625dfa51d0f0491b8e221fcb56c1dfe8b826290dbf_9.jar
|   |   |   |               |   
|   |   |   |               +---com
|   |   |   |               |   \---example
|   |   |   |               |       \---fairware_lift
|   |   |   |               |               MainActivity.dex
|   |   |   |               |               
|   |   |   |               \---io
|   |   |   |                   \---flutter
|   |   |   |                       \---plugins
|   |   |   |                               GeneratedPluginRegistrant.dex
|   |   |   |                               
|   |   |   +---runtime_symbol_list
|   |   |   |   \---debug
|   |   |   |       \---processDebugResources
|   |   |   |               R.txt
|   |   |   |               
|   |   |   +---signing_config_versions
|   |   |   |   \---debug
|   |   |   |       \---writeDebugSigningConfigVersions
|   |   |   |               signing-config-versions.json
|   |   |   |               
|   |   |   +---source_set_path_map
|   |   |   |   \---debug
|   |   |   |       \---mapDebugSourceSetPaths
|   |   |   |               file-map.txt
|   |   |   |               
|   |   |   +---stable_resource_ids_file
|   |   |   |   \---debug
|   |   |   |       \---processDebugResources
|   |   |   |               stableIds.txt
|   |   |   |               
|   |   |   +---stripped_native_libs
|   |   |   |   \---debug
|   |   |   |       \---stripDebugDebugSymbols
|   |   |   |           \---out
|   |   |   |               \---lib
|   |   |   |                   +---arm64-v8a
|   |   |   |                   |       libdatastore_shared_counter.so
|   |   |   |                   |       libflutter.so
|   |   |   |                   |       libsqlite3.so
|   |   |   |                   |       libVkLayer_khronos_validation.so
|   |   |   |                   |       
|   |   |   |                   +---armeabi-v7a
|   |   |   |                   |       libdatastore_shared_counter.so
|   |   |   |                   |       libsqlite3.so
|   |   |   |                   |       
|   |   |   |                   +---x86
|   |   |   |                   |       libdatastore_shared_counter.so
|   |   |   |                   |       
|   |   |   |                   \---x86_64
|   |   |   |                           libdatastore_shared_counter.so
|   |   |   |                           libsqlite3.so
|   |   |   |                           
|   |   |   +---sub_project_dex_archive
|   |   |   |   \---debug
|   |   |   |       \---dexBuilderDebug
|   |   |   |           \---out
|   |   |   +---symbol_list_with_package_name
|   |   |   |   \---debug
|   |   |   |       \---processDebugResources
|   |   |   |               package-aware-r.txt
|   |   |   |               
|   |   |   \---validate_signing_config
|   |   |       \---debug
|   |   |           \---validateSigningDebug
|   |   +---kotlin
|   |   |   \---compileDebugKotlin
|   |   |       +---cacheable
|   |   |       |   |   last-build.bin
|   |   |       |   |   
|   |   |       |   \---caches-jvm
|   |   |       |       +---inputs
|   |   |       |       |       source-to-output.tab
|   |   |       |       |       source-to-output.tab.keystream
|   |   |       |       |       source-to-output.tab.keystream.len
|   |   |       |       |       source-to-output.tab.len
|   |   |       |       |       source-to-output.tab.values.at
|   |   |       |       |       source-to-output.tab_i
|   |   |       |       |       source-to-output.tab_i.len
|   |   |       |       |       
|   |   |       |       +---jvm
|   |   |       |       |   \---kotlin
|   |   |       |       |           class-attributes.tab
|   |   |       |       |           class-attributes.tab.keystream
|   |   |       |       |           class-attributes.tab.keystream.len
|   |   |       |       |           class-attributes.tab.len
|   |   |       |       |           class-attributes.tab.values.at
|   |   |       |       |           class-attributes.tab_i
|   |   |       |       |           class-attributes.tab_i.len
|   |   |       |       |           class-fq-name-to-source.tab
|   |   |       |       |           class-fq-name-to-source.tab.keystream
|   |   |       |       |           class-fq-name-to-source.tab.keystream.len
|   |   |       |       |           class-fq-name-to-source.tab.len
|   |   |       |       |           class-fq-name-to-source.tab.values.at
|   |   |       |       |           class-fq-name-to-source.tab_i
|   |   |       |       |           class-fq-name-to-source.tab_i.len
|   |   |       |       |           internal-name-to-source.tab
|   |   |       |       |           internal-name-to-source.tab.keystream
|   |   |       |       |           internal-name-to-source.tab.keystream.len
|   |   |       |       |           internal-name-to-source.tab.len
|   |   |       |       |           internal-name-to-source.tab.values.at
|   |   |       |       |           internal-name-to-source.tab_i
|   |   |       |       |           internal-name-to-source.tab_i.len
|   |   |       |       |           proto.tab
|   |   |       |       |           proto.tab.keystream
|   |   |       |       |           proto.tab.keystream.len
|   |   |       |       |           proto.tab.len
|   |   |       |       |           proto.tab.values.at
|   |   |       |       |           proto.tab_i
|   |   |       |       |           proto.tab_i.len
|   |   |       |       |           source-to-classes.tab
|   |   |       |       |           source-to-classes.tab.keystream
|   |   |       |       |           source-to-classes.tab.keystream.len
|   |   |       |       |           source-to-classes.tab.len
|   |   |       |       |           source-to-classes.tab.values.at
|   |   |       |       |           source-to-classes.tab_i
|   |   |       |       |           source-to-classes.tab_i.len
|   |   |       |       |           subtypes.tab
|   |   |       |       |           subtypes.tab.keystream
|   |   |       |       |           subtypes.tab.keystream.len
|   |   |       |       |           subtypes.tab.len
|   |   |       |       |           subtypes.tab.values.at
|   |   |       |       |           subtypes.tab_i
|   |   |       |       |           subtypes.tab_i.len
|   |   |       |       |           supertypes.tab
|   |   |       |       |           supertypes.tab.keystream
|   |   |       |       |           supertypes.tab.keystream.len
|   |   |       |       |           supertypes.tab.len
|   |   |       |       |           supertypes.tab.values.at
|   |   |       |       |           supertypes.tab_i
|   |   |       |       |           supertypes.tab_i.len
|   |   |       |       |           
|   |   |       |       \---lookups
|   |   |       |               counters.tab
|   |   |       |               file-to-id.tab
|   |   |       |               file-to-id.tab.keystream
|   |   |       |               file-to-id.tab.keystream.len
|   |   |       |               file-to-id.tab.len
|   |   |       |               file-to-id.tab.values.at
|   |   |       |               file-to-id.tab_i
|   |   |       |               file-to-id.tab_i.len
|   |   |       |               id-to-file.tab
|   |   |       |               id-to-file.tab.keystream
|   |   |       |               id-to-file.tab.keystream.len
|   |   |       |               id-to-file.tab.len
|   |   |       |               id-to-file.tab.values.at
|   |   |       |               id-to-file.tab_i.len
|   |   |       |               lookups.tab
|   |   |       |               lookups.tab.keystream
|   |   |       |               lookups.tab.keystream.len
|   |   |       |               lookups.tab.len
|   |   |       |               lookups.tab.values.at
|   |   |       |               lookups.tab_i
|   |   |       |               lookups.tab_i.len
|   |   |       |               
|   |   |       +---classpath-snapshot
|   |   |       |       shrunk-classpath-snapshot.bin
|   |   |       |       
|   |   |       \---local-state
|   |   |               build-history.bin
|   |   |               
|   |   +---outputs
|   |   |   +---apk
|   |   |   |   \---debug
|   |   |   |           app-debug.apk
|   |   |   |           output-metadata.json
|   |   |   |           
|   |   |   +---flutter-apk
|   |   |   |       app-debug.apk
|   |   |   |       
|   |   |   \---logs
|   |   |           manifest-merger-debug-report.txt
|   |   |           
|   |   \---tmp
|   |       +---compileDebugJavaWithJavac
|   |       |       previous-compilation-data.bin
|   |       |       
|   |       +---kotlin-classes
|   |       |   \---debug
|   |       |       +---com
|   |       |       |   \---example
|   |       |       |       \---fairware_lift
|   |       |       |               MainActivity.class
|   |       |       |               
|   |       |       \---META-INF
|   |       |               app_debug.kotlin_module
|   |       |               
|   |       \---packJniLibsflutterBuildDebug
|   |               MANIFEST.MF
|   |               
|   \---src
|       +---debug
|       |       AndroidManifest.xml
|       |       
|       +---main
|       |   |   AndroidManifest.xml
|       |   |   
|       |   +---java
|       |   |   \---io
|       |   |       \---flutter
|       |   |           \---plugins
|       |   |                   GeneratedPluginRegistrant.java
|       |   |                   
|       |   +---kotlin
|       |   |   \---com
|       |   |       \---example
|       |   |           \---fairware_lift
|       |   |                   MainActivity.kt
|       |   |                   
|       |   \---res
|       |       +---drawable
|       |       |       launch_background.xml
|       |       |       
|       |       +---drawable-v21
|       |       |       launch_background.xml
|       |       |       
|       |       +---mipmap-hdpi
|       |       |       ic_launcher.png
|       |       |       
|       |       +---mipmap-mdpi
|       |       |       ic_launcher.png
|       |       |       
|       |       +---mipmap-xhdpi
|       |       |       ic_launcher.png
|       |       |       
|       |       +---mipmap-xxhdpi
|       |       |       ic_launcher.png
|       |       |       
|       |       +---mipmap-xxxhdpi
|       |       |       ic_launcher.png
|       |       |       
|       |       +---values
|       |       |       styles.xml
|       |       |       
|       |       \---values-night
|       |               styles.xml
|       |               
|       \---profile
|               AndroidManifest.xml
|               
+---build
|   \---reports
|       \---problems
|               problems-report.html
|               
\---gradle
    \---wrapper
            gradle-wrapper.jar
            gradle-wrapper.properties
            
Folder PATH listing for volume DATA1
Volume serial number is 247C-8FD2
D:\FAIRWARE_LIFT\ASSETS
+---audio
|       timer_complete.mp3
|       timer_warning.mp3
|       
+---data
|       fairware_exercise_library.csv
|       lift_aliases.json
|       lift_rules.json
|       
+---dxg
|       movement_families.seed.json
|       synonyms.map.json
|       warmup_items.seed.json
|       
\---icons
        app_icon.png
        
 
===== FILE CONTENTS ===== 
----- pubspec.yaml ----- 
# This is the final, corrected pubspec.yaml combining the best research.
name: fairware_lift
description: "A privacy-first workout tracker with offline-first data and world-class exports."
publish_to: 'none'
version: 1.0.0+1

# Corrected SDK environment from LLM #2 to support new package versions.
environment:
  sdk: '>=3.5.0 <4.0.0'
  flutter: ">=3.32.0"

# Comprehensive dependency list from LLM #1's research.
dependencies:
  flutter:
    sdk: flutter

  # --- CORRECTED: Use the right package AND version for communication ---
  watch_connectivity: ^0.2.3
  # --- FIX: Added the missing Wear OS connectivity package ---
  flutter_wear_os_connectivity: ^1.0.0

  # Firebase - Unchanged
  firebase_core: ^3.3.0
  firebase_auth: ^5.2.0
  cloud_firestore: ^5.1.0
  firebase_storage: ^12.1.0
  firebase_crashlytics: ^4.1.0

  # State Management & DB - Unchanged
  flutter_riverpod: ^2.6.0
  drift: ^2.28.0
  sqlite3_flutter_libs: ^0.5.40
  path: ^1.8.2

  # --- V2 EMBEDDING COMPATIBILITY UPGRADES ---
  path_provider: ^2.1.5         # For modern Flutter/AGP compatibility.
  flutter_local_notifications: ^17.2.1 # Already v2 compatible.
  workmanager: ^0.9.0+3          # CRITICAL FIX: Removes V1 APIs and fixes Registrar/shim errors.
  vibration: ^3.1.3              # CRITICAL FIX: Uses modern Android Embedding v2.
  audioplayers: ^6.5.1           # Upgrade to current stable v2 version.
  image_picker: ^1.1.2           # Proactive fix for known v1 embedding build errors.
  file_picker: ^8.3.5            # Upgrade to current stable to avoid build issues.
  open_filex: ^4.7.0             # Upgrade to latest with modern Gradle compatibility.

  # Pure Dart / Already Compatible
  uuid: ^4.4.0
  pdf: ^3.10.4
  printing: ^5.11.0
  csv: ^6.0.0
  fl_chart: ^0.68.0
  permission_handler: ^11.0.1
  shared_preferences: ^2.1.0
  collection: ^1.18.0
  characters: ^1.3.0 # For robust string normalization

  # --- NEW: For Workout DSL Importer ---
  crypto: ^3.0.3                 # For SHA1 hashing (exercise_hash).
  url_launcher: ^6.3.1           # For opening web/video links from info sheet.

  # Code Gen - Unchanged
  freezed_annotation: ^2.4.1
  json_annotation: ^4.8.1
  intl: ^0.20.2

dev_dependencies:
  flutter_test:
    sdk: flutter
  build_runner: ^2.4.5
  drift_dev: ^2.28.0
  freezed: ^2.4.5
  json_serializable: ^6.7.1
  flutter_lints: ^4.0.0
  flutter_launcher_icons: ^0.14.4

flutter_launcher_icons:
  android: true
  image_path: assets/icons/app_icon.png

flutter:
  uses-material-design: true

  # This section declares the asset folders so Flutter can find the files.
  assets:
    - assets/audio/
    - assets/data/
    - assets/dxg/----- D:\fairware_lift\lib\firebase_options.dart ----- 
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      throw UnsupportedError(
        'DefaultFirebaseOptions have not been configured for web - '
        'you can reconfigure this by running the FlutterFire CLI again.',
      );
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for ios - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyDQ1sHvdiNgkOzsU8KD076g97uA95dmrtQ',
    appId: '1:2182695689:android:69f96335cc844bc47d21d8',
    messagingSenderId: '2182695689',
    projectId: 'fairware-lift',
    storageBucket: 'fairware-lift.firebasestorage.app',
  );

}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\main.dart ----- 
// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

// Core Flutter material design library.
import 'package:flutter/material.dart';

// Firebase core for initialization.
import 'package:firebase_core/firebase_core.dart';

// Riverpod for state management.
import 'package:flutter_riverpod/flutter_riverpod.dart';

// The Firebase configuration file generated by the FlutterFire CLI.
import 'firebase_options.dart';

// Our custom design tokens and theme constants.
import 'src/core/theme/app_theme.dart';

// The main application shell widget which contains the bottom navigation.
import 'src/app/shell.dart';

// --- NEW IMPORTS ---
import 'dart:io'; // Used to check the operating system.
import 'src/features/workout/application/wear_timer_sync_service.dart';

// -----------------------------------------------------------------------------
// --- APP ENTRY POINT (MODIFIED) ----------------------------------------------
// -----------------------------------------------------------------------------

/// The main function is the entry point for the application.
Future<void> main() async {
  // Ensure that the Flutter binding is initialized before calling native code.
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase using the platform-specific options.
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // --- NEW: Initialize Riverpod container and services ---
  // Create a ProviderContainer to manage our application's state.
  final container = ProviderContainer();

  // Initialize the Wear OS sync service only on the Android platform.
  // This prevents errors when running on iOS in the future.
  if (Platform.isAndroid) {
    // We read the provider to create the service instance and then call its
    // async init() method to configure the underlying native APIs.
    await container.read(wearTimerSyncServiceProvider).init();
  }

  // Run the app within an UncontrolledProviderScope to use the pre-initialized container.
  runApp(
    UncontrolledProviderScope(
      container: container,
      child: const FairwareLiftApp(),
    ),
  );
}

// -----------------------------------------------------------------------------
// --- ROOT WIDGET -------------------------------------------------------------
// -----------------------------------------------------------------------------

/// The root widget of the Fairware Lift application.
/// This widget sets up the MaterialApp and defines the global theme.
class FairwareLiftApp extends StatelessWidget {
  const FairwareLiftApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // --- THEME CONFIGURATION (from SSOT) ---
      // We use the ThemeData.dark() constructor as a base and then override
      // it with the specific colors and typography from our AppTheme class.
      theme: ThemeData.dark().copyWith(
        // Background and surface colors.
        scaffoldBackgroundColor: AppTheme.colors.background,
        appBarTheme: AppBarTheme(
          backgroundColor: AppTheme.colors.surface,
          elevation: 0,
        ),
        cardColor: AppTheme.colors.surface,

        // Primary accent color.
        colorScheme: ColorScheme.dark(
          primary: AppTheme.colors.accent,
          secondary: AppTheme.colors.accent,
          surface: AppTheme.colors.surface,
          background: AppTheme.colors.background,
          error: AppTheme.colors.danger,
        ),

        // Text theme.
        textTheme: TextTheme(
          displayLarge: AppTheme.typography.display,
          titleLarge: AppTheme.typography.title,
          bodyLarge: AppTheme.typography.body,
          bodyMedium: AppTheme.typography.body.copyWith(fontSize: 14),
          labelLarge: AppTheme.typography.body.copyWith(fontWeight: FontWeight.bold),
          bodySmall: AppTheme.typography.caption,
        ),

        // Component themes.
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: AppTheme.colors.accent,
            foregroundColor: AppTheme.colors.textPrimary,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(AppTheme.sizing.buttonRadius),
            ),
            padding: EdgeInsets.symmetric(
              vertical: AppTheme.sizing.baseGrid * 1.5, // 12pt
              horizontal: AppTheme.sizing.verticalRhythm, // 24pt
            ),
          ),
        ),
      ),

      // --- HOME SCREEN ---
      // The 'home' is now our AppShell, which handles the main navigation.
      home: const AppShell(),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\app\shell.dart ----- 
// lib/src/app/shell.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/today/presentation/today_screen.dart';
import 'package:fairware_lift/src/features/programs/presentation/programs_screen.dart';
import 'package:fairware_lift/src/features/measurements/presentation/measurements_screen.dart';
import 'package:fairware_lift/src/features/settings/presentation/settings_screen.dart';
import 'package:fairware_lift/src/features/workout/presentation/start_workout_options_screen.dart';
// --- NEW IMPORT ---
import 'package:fairware_lift/src/features/prompt_studio/presentation/prompt_studio_page.dart';

// -----------------------------------------------------------------------------
// --- APP SHELL WIDGET --------------------------------------------------------
// -----------------------------------------------------------------------------

/// A stateful widget that acts as the main application shell.
///
/// This widget is responsible for creating and managing the primary UI
/// structure, including the BottomNavigationBar and the central Floating Action Button.
class AppShell extends StatefulWidget {
  const AppShell({super.key});

  @override
  State<AppShell> createState() => _AppShellState();
}

class _AppShellState extends State<AppShell> {
  // ---------------------------------------------------------------------------
  // --- STATE -----------------------------------------------------------------
  // ---------------------------------------------------------------------------

  int _selectedIndex = 0;

  // --- MODIFIED: Added PromptStudioPage to the list of screens ---
  static const List<Widget> _widgetOptions = <Widget>[
    TodayScreen(),
    ProgramsScreen(),
    PromptStudioPage(),
    MeasurementsScreen(),
    SettingsScreen(),
  ];

  // ---------------------------------------------------------------------------
  // --- METHODS ---------------------------------------------------------------
  // ---------------------------------------------------------------------------

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  void _onStartWorkoutPressed() {
    showModalBottomSheet(
      context: context,
      backgroundColor: AppTheme.colors.surface,
      builder: (context) => const StartWorkoutOptionsScreen(),
    );
  }

  // ---------------------------------------------------------------------------
  // --- BUILD METHOD ----------------------------------------------------------
  // ---------------------------------------------------------------------------

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: _widgetOptions.elementAt(_selectedIndex),
      ),
      // --- MODIFIED: Changed to centerFloat as per SSOT ---
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
      floatingActionButton: FloatingActionButton(
        onPressed: _onStartWorkoutPressed,
        backgroundColor: AppTheme.colors.accent,
        foregroundColor: AppTheme.colors.textPrimary,
        elevation: 4.0,
        child: const Icon(Icons.play_arrow_rounded),
      ),
      // --- MODIFIED: Replaced BottomAppBar with BottomNavigationBar ---
      bottomNavigationBar: BottomNavigationBar(
        items: const <BottomNavigationBarItem>[
          BottomNavigationBarItem(
            icon: Icon(Icons.today_rounded),
            label: 'Today',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.list_alt_rounded),
            label: 'Workouts',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.psychology_alt_rounded), // For 'Prompt Studio'
            label: 'Studio',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.monitor_weight_rounded),
            label: 'Progress',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.settings_rounded),
            label: 'Settings',
          ),
        ],
        currentIndex: _selectedIndex,
        onTap: _onItemTapped,
        // --- STYLING TO MATCH APP THEME ---
        backgroundColor: AppTheme.colors.surface,
        type: BottomNavigationBarType.fixed,
        selectedItemColor: AppTheme.colors.accent,
        unselectedItemColor: AppTheme.colors.textMuted,
        showUnselectedLabels: true,
        selectedFontSize: 12.0,
        unselectedFontSize: 12.0,
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\core\services\alert_service.dart ----- 
// lib/src/core/services/alert_service.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:vibration/vibration.dart';

// -----------------------------------------------------------------------------
// --- ALERT SERVICE CLASS -----------------------------------------------------
// -----------------------------------------------------------------------------

/// A service class responsible for providing user alerts, such as sounds and
/// haptic feedback, for events like timer completion.
class AlertService {
  final AudioPlayer _audioPlayer;

  AlertService(this._audioPlayer) {
    // Configure the audio player as soon as the service is created.
    _configureAudioPlayer();
  }

  /// Configures the global audio context for the app's sound effects.
  Future<void> _configureAudioPlayer() async {
    final audioContext = AudioContext(
      // iOS Configuration
      iOS: AudioContextIOS(
        category: AVAudioSessionCategory.playback,
        // --- FIX ---
        // The `options` parameter requires a Set {}, not a List [].
        // This has been corrected.
        options: {
          AVAudioSessionOptions.duckOthers,
        },
      ),
      // Android Configuration
      android: AudioContextAndroid(
        isSpeakerphoneOn: true,
        audioFocus: AndroidAudioFocus.gainTransient,
        usageType: AndroidUsageType.alarm,
      ),
    );
    // Apply the configuration to our audio player instance.
    await _audioPlayer.setAudioContext(audioContext);
  }

  /// Triggers only a warning sound, without haptic feedback.
  Future<void> triggerTimerWarningAlert() async {
    await _audioPlayer.play(AssetSource('audio/timer_warning.mp3'));
  }

  /// Triggers a combination of haptic feedback and an audible alert to notify
  /// the user that their rest timer has finished.
  Future<void> triggerTimerCompletionAlert() async {
    final bool? hasVibrator = await Vibration.hasVibrator();
    if (hasVibrator ?? false) {
      Vibration.vibrate();
    }
    await _audioPlayer.play(AssetSource('audio/timer_complete.mp3'));
  }
}

// -----------------------------------------------------------------------------
// --- PROVIDERS ---------------------------------------------------------------
// -----------------------------------------------------------------------------

final _audioPlayerProvider = Provider<AudioPlayer>((ref) {
  final player = AudioPlayer();
  ref.onDispose(() => player.dispose());
  return player;
});

final alertServiceProvider = Provider<AlertService>((ref) {
  return AlertService(ref.watch(_audioPlayerProvider));
});----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\core\theme\app_theme.dart ----- 
// lib/src/core/theme/app_theme.dart

// ignore_for_file: public_member_api_docs

import 'package:flutter/material.dart';

/// This class holds all the design tokens for the Fairware Lift application.
class AppTheme {
  // Private constructor to prevent instantiation.
  AppTheme._();

  // ---------------------------------------------------------------------------
  // --- COLOR PALETTE ---------------------------------------------------------
  // ---------------------------------------------------------------------------
  static const _colors = _AppColors(
    background: Color(0xFF0f0f0f), // Updated to match design
    surface: Color(0xFF1E1E24),
    surfaceAlt: Color(0xFF181818),
    textPrimary: Color(0xFFEEF0F3),
    textSecondary: Color(0xFFB9BEC8),
    textMuted: Color(0xFF8C919B),
    accent: Color(0xFFBA39FF),
    accentPressed: Color(0xFFA02DDC),
    chipInfo: Color(0xFF231E2D),
    warning: Color(0xFFFFC857),
    danger: Color(0xFFF06272),
    infoBlue: Color(0xFF2AA1E9),

    // --- NEW: Prompt Studio Accent Colors ---
    accentRust: Color(0xFFD26B35),
    accentTeal: Color(0xFF00BFFF), // Placeholder
    accentSilver: Color(0xFFC0C0C0), // Placeholder
  );

  // ---------------------------------------------------------------------------
  // --- TYPOGRAPHY ------------------------------------------------------------
  // ---------------------------------------------------------------------------
  static final _typography = _AppTypography(
    display: TextStyle(
      fontSize: 34,
      fontWeight: FontWeight.w600,
      color: _colors.textPrimary,
    ),
    title: TextStyle(
      fontSize: 22,
      fontWeight: FontWeight.w500,
      color: _colors.textPrimary,
    ),
    body: TextStyle(
      fontSize: 16,
      fontWeight: FontWeight.w400,
      color: _colors.textSecondary,
    ),
    caption: TextStyle(
      fontSize: 12,
      fontWeight: FontWeight.w400,
      color: _colors.textMuted,
    ),
    number: TextStyle(
      fontSize: 34,
      fontWeight: FontWeight.w600,
      color: _colors.textPrimary,
    ),
  );

  // ---------------------------------------------------------------------------
  // --- COMPONENTS & SIZING ---------------------------------------------------
  // ---------------------------------------------------------------------------
  static const _sizing = _AppSizing(
    cardRadius: 20.0, // Updated to match design (radius.lg)
    buttonRadius: 20.0,
    chipRadius: 14.0,
    touchTargetMinimum: 44.0,
    baseGrid: 8.0,
    verticalRhythm: 24.0,
  );

  // ---------------------------------------------------------------------------
  // --- PUBLIC ACCESSORS ------------------------------------------------------
  // ---------------------------------------------------------------------------
  static _AppColors get colors => _colors;
  static _AppTypography get typography => _typography;
  static _AppSizing get sizing => _sizing;
}

// --- Private helper classes for organization ---

class _AppColors {
  const _AppColors({
    required this.background,
    required this.surface,
    required this.surfaceAlt,
    required this.textPrimary,
    required this.textSecondary,
    required this.textMuted,
    required this.accent,
    required this.accentPressed,
    required this.chipInfo,
    required this.warning,
    required this.danger,
    required this.infoBlue,
    required this.accentRust,
    required this.accentTeal,
    required this.accentSilver,
  });

  // Backgrounds
  final Color background;
  final Color surface;
  final Color surfaceAlt;

  // Text
  final Color textPrimary;
  final Color textSecondary;
  final Color textMuted;

  // Main Accent
  final Color accent;
  final Color accentPressed;

  // Prompt Studio Accents
  final Color accentRust;
  final Color accentTeal;
  final Color accentSilver;

  // Components
  final Color chipInfo;

  // Status
  final Color warning;
  final Color danger;
  final Color infoBlue;
}

class _AppTypography {
  const _AppTypography({
    required this.display,
    required this.title,
    required this.body,
    required this.caption,
    required this.number,
  });

  final TextStyle display;
  final TextStyle title;
  final TextStyle body;
  final TextStyle caption;
  final TextStyle number;
}

class _AppSizing {
  const _AppSizing({
    required this.cardRadius,
    required this.buttonRadius,
    required this.chipRadius,
    required this.touchTargetMinimum,
    required this.baseGrid,
    required this.verticalRhythm,
  });

  final double cardRadius;
  final double buttonRadius;
  final double chipRadius;
  final double touchTargetMinimum;
  final double baseGrid;
  final double verticalRhythm;
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\core\theme\data\local\database.dart ----- 
// lib/src/core/theme/data/local/database.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'dart:convert';
import 'dart:io';
import 'package:collection/collection.dart';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:fairware_lift/src/features/dxg/domain/exercise_instance.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';

part 'database.g.dart';

// -----------------------------------------------------------------------------
// --- DATA CLASSES FOR QUERIES ------------------------------------------------
// -----------------------------------------------------------------------------

class FullWorkoutSession {
  final Session session;
  final List<SetEntryWithExercise> sets;
  final List<SavedWarmup> warmups;

  FullWorkoutSession({
    required this.session,
    required this.sets,
    required this.warmups,
  });
}

class SetEntryWithExercise {
  final SetEntry set;
  final ExerciseInstance exercise;

  SetEntryWithExercise({required this.set, required this.exercise});
}

// -----------------------------------------------------------------------------
// --- TABLE DEFINITIONS -------------------------------------------------------
// -----------------------------------------------------------------------------

@DataClassName('Session')
class Sessions extends Table {
  TextColumn get id => text()();
  DateTimeColumn get sessionDateTime => dateTime().named('date_time')();
  IntColumn get totalDurationSeconds =>
      integer().named('total_duration_seconds').nullable()();
  IntColumn get totalActivitySeconds =>
      integer().named('total_activity_seconds').nullable()();
  IntColumn get totalRestSeconds =>
      integer().named('total_rest_seconds').nullable()();
  TextColumn get notes => text().named('notes').nullable()();
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get updatedAt => dateTime()();
  @override
  Set<Column> get primaryKey => {id};
}

@DataClassName('SetEntry')
class SetEntries extends Table {
  TextColumn get id => text()();
  TextColumn get sessionId => text().references(Sessions, #id)();
  TextColumn get exerciseSlug =>
      text().references(ExerciseInstances, #slug).named('exercise_slug')();
  IntColumn get setOrder => integer()();
  
  // Original weight/reps columns (kept for backward compatibility)
  RealColumn get weight => real()();
  IntColumn get reps => integer()();

  // --- NEW HYBRID SCHEMA COLUMNS ---
  TextColumn get setType => text().named('set_type').nullable()();
  IntColumn get durationSeconds => integer().named('duration_seconds').nullable()();
  IntColumn get distanceM => integer().named('distance_m').nullable()();
  IntColumn get calories => integer().named('calories').nullable()();
  RealColumn get rpe => real().named('rpe').nullable()();
  TextColumn get metricsJson => text().named('metrics_json').nullable()();
  TextColumn get prescriptionJson => text().named('prescription_json').nullable()();
  
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get updatedAt => dateTime()();
  @override
  Set<Column> get primaryKey => {id};
}

@DataClassName('ExerciseInstance')
class ExerciseInstances extends Table {
  TextColumn get slug => text()();
  TextColumn get familyId => text().named('family_id')();
  TextColumn get displayName => text().named('display_name')();
  TextColumn get discriminators =>
      text().map(const DiscriminatorsConverter())();
  DateTimeColumn get firstSeenAt => dateTime().named('first_seen_at')();
  @override
  Set<Column> get primaryKey => {slug};
}

@DataClassName('SavedWarmup')
class SavedWarmups extends Table {
  TextColumn get id => text()();
  TextColumn get sessionId => text().references(Sessions, #id)();
  TextColumn get warmupId => text().named('warmup_id')();
  TextColumn get displayName => text().named('display_name')();
  TextColumn get parameters => text().map(const DiscriminatorsConverter())();
  DateTimeColumn get createdAt => dateTime()();
  @override
  Set<Column> get primaryKey => {id};
}

// -----------------------------------------------------------------------------
// --- DATABASE CLASS ----------------------------------------------------------
// -----------------------------------------------------------------------------

@DriftDatabase(tables: [
  Sessions,
  SetEntries,
  ExerciseInstances,
  SavedWarmups,
])
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 7;

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (m) => m.createAll(),
      onUpgrade: (migrator, from, to) async {
        if (from < 5) {
          await migrator.addColumn(sessions, sessions.totalDurationSeconds);
          await migrator.addColumn(sessions, sessions.totalRestSeconds);
        }
        if (from < 6) {
          await migrator.addColumn(sessions, sessions.totalActivitySeconds);
        }
        if (from < 7) {
          await migrator.addColumn(setEntries, setEntries.setType);
          await migrator.addColumn(setEntries, setEntries.durationSeconds);
          await migrator.addColumn(setEntries, setEntries.distanceM);
          await migrator.addColumn(setEntries, setEntries.calories);
          await migrator.addColumn(setEntries, setEntries.rpe);
          await migrator.addColumn(setEntries, setEntries.metricsJson);
          await migrator.addColumn(setEntries, setEntries.prescriptionJson);
          
          await customStatement('CREATE INDEX IF NOT EXISTS idx_setentries_set_type ON set_entries(set_type);');
          await customStatement('CREATE INDEX IF NOT EXISTS idx_setentries_duration_seconds ON set_entries(duration_seconds);');
          await customStatement('CREATE INDEX IF NOT EXISTS idx_setentries_distance_m ON set_entries(distance_m);');
          await customStatement('CREATE INDEX IF NOT EXISTS idx_setentries_calories ON set_entries(calories);');
        }
      },
    );
  }

  Future<FullWorkoutSession?> getLatestWorkout() async {
    final latestSessionQuery = select(sessions)
      ..orderBy([(t) => OrderingTerm.desc(t.sessionDateTime)])
      ..limit(1);

    final sessionResult = await latestSessionQuery.getSingleOrNull();

    if (sessionResult == null) {
      return null;
    }

    final history = await getWorkoutHistory(limit: 1);
    return history.isNotEmpty ? history.first : null;
  }

  Future<List<FullWorkoutSession>> getWorkoutHistory({int? limit}) async {
    final query = select(sessions)
      ..orderBy([(t) => OrderingTerm.desc(t.sessionDateTime)]);

    if (limit != null) {
      query.limit(limit);
    }

    final sessionsResult = await query.get();
    if (sessionsResult.isEmpty) return [];

    final sessionIds = sessionsResult.map((s) => s.id).toList();

    final setsQuery = select(setEntries).join([
      innerJoin(exerciseInstances,
          exerciseInstances.slug.equalsExp(setEntries.exerciseSlug)),
    ])
      ..where(setEntries.sessionId.isIn(sessionIds));

    final warmupsQuery =
        select(savedWarmups)..where((tbl) => tbl.sessionId.isIn(sessionIds));

    final setsResult = await setsQuery.get();
    final warmupsResult = await warmupsQuery.get();

    final setsBySession =
        groupBy(setsResult, (row) => row.readTable(setEntries).sessionId);
    final warmupsBySession =
        groupBy(warmupsResult, (warmup) => warmup.sessionId);

    return sessionsResult.map((session) {
      final setsForSession = setsBySession[session.id] ?? [];
      final setsWithExercise = setsForSession.map((row) {
        return SetEntryWithExercise(
          set: row.readTable(setEntries),
          exercise: row.readTable(exerciseInstances),
        );
      }).toList();

      final warmupsForSession = warmupsBySession[session.id] ?? [];

      return FullWorkoutSession(
        session: session,
        sets: setsWithExercise,
        warmups: warmupsForSession,
      );
    }).toList();
  }

  Future<void> deleteWorkoutSession(String sessionId) async {
    await transaction(() async {
      await (delete(savedWarmups)..where((tbl) => tbl.sessionId.equals(sessionId)))
          .go();
      await (delete(setEntries)..where((tbl) => tbl.sessionId.equals(sessionId)))
          .go();
      await (delete(sessions)..where((tbl) => tbl.id.equals(sessionId))).go();
    });
  }
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'fairware_lift.db'));
    return NativeDatabase(file);
  });
}

// -----------------------------------------------------------------------------
// --- PROVIDER ----------------------------------------------------------------
// -----------------------------------------------------------------------------

final databaseProvider = Provider<AppDatabase>((ref) {
  final db = AppDatabase();
  ref.onDispose(() => db.close());
  return db;
});----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\core\theme\data\local\database.g.dart ----- 
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $SessionsTable extends Sessions with TableInfo<$SessionsTable, Session> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SessionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _sessionDateTimeMeta =
      const VerificationMeta('sessionDateTime');
  @override
  late final GeneratedColumn<DateTime> sessionDateTime =
      GeneratedColumn<DateTime>('date_time', aliasedName, false,
          type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _totalDurationSecondsMeta =
      const VerificationMeta('totalDurationSeconds');
  @override
  late final GeneratedColumn<int> totalDurationSeconds = GeneratedColumn<int>(
      'total_duration_seconds', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _totalActivitySecondsMeta =
      const VerificationMeta('totalActivitySeconds');
  @override
  late final GeneratedColumn<int> totalActivitySeconds = GeneratedColumn<int>(
      'total_activity_seconds', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _totalRestSecondsMeta =
      const VerificationMeta('totalRestSeconds');
  @override
  late final GeneratedColumn<int> totalRestSeconds = GeneratedColumn<int>(
      'total_rest_seconds', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        sessionDateTime,
        totalDurationSeconds,
        totalActivitySeconds,
        totalRestSeconds,
        notes,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sessions';
  @override
  VerificationContext validateIntegrity(Insertable<Session> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('date_time')) {
      context.handle(
          _sessionDateTimeMeta,
          sessionDateTime.isAcceptableOrUnknown(
              data['date_time']!, _sessionDateTimeMeta));
    } else if (isInserting) {
      context.missing(_sessionDateTimeMeta);
    }
    if (data.containsKey('total_duration_seconds')) {
      context.handle(
          _totalDurationSecondsMeta,
          totalDurationSeconds.isAcceptableOrUnknown(
              data['total_duration_seconds']!, _totalDurationSecondsMeta));
    }
    if (data.containsKey('total_activity_seconds')) {
      context.handle(
          _totalActivitySecondsMeta,
          totalActivitySeconds.isAcceptableOrUnknown(
              data['total_activity_seconds']!, _totalActivitySecondsMeta));
    }
    if (data.containsKey('total_rest_seconds')) {
      context.handle(
          _totalRestSecondsMeta,
          totalRestSeconds.isAcceptableOrUnknown(
              data['total_rest_seconds']!, _totalRestSecondsMeta));
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Session map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Session(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      sessionDateTime: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date_time'])!,
      totalDurationSeconds: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}total_duration_seconds']),
      totalActivitySeconds: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}total_activity_seconds']),
      totalRestSeconds: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}total_rest_seconds']),
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $SessionsTable createAlias(String alias) {
    return $SessionsTable(attachedDatabase, alias);
  }
}

class Session extends DataClass implements Insertable<Session> {
  final String id;
  final DateTime sessionDateTime;
  final int? totalDurationSeconds;
  final int? totalActivitySeconds;
  final int? totalRestSeconds;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Session(
      {required this.id,
      required this.sessionDateTime,
      this.totalDurationSeconds,
      this.totalActivitySeconds,
      this.totalRestSeconds,
      this.notes,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['date_time'] = Variable<DateTime>(sessionDateTime);
    if (!nullToAbsent || totalDurationSeconds != null) {
      map['total_duration_seconds'] = Variable<int>(totalDurationSeconds);
    }
    if (!nullToAbsent || totalActivitySeconds != null) {
      map['total_activity_seconds'] = Variable<int>(totalActivitySeconds);
    }
    if (!nullToAbsent || totalRestSeconds != null) {
      map['total_rest_seconds'] = Variable<int>(totalRestSeconds);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  SessionsCompanion toCompanion(bool nullToAbsent) {
    return SessionsCompanion(
      id: Value(id),
      sessionDateTime: Value(sessionDateTime),
      totalDurationSeconds: totalDurationSeconds == null && nullToAbsent
          ? const Value.absent()
          : Value(totalDurationSeconds),
      totalActivitySeconds: totalActivitySeconds == null && nullToAbsent
          ? const Value.absent()
          : Value(totalActivitySeconds),
      totalRestSeconds: totalRestSeconds == null && nullToAbsent
          ? const Value.absent()
          : Value(totalRestSeconds),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Session.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Session(
      id: serializer.fromJson<String>(json['id']),
      sessionDateTime: serializer.fromJson<DateTime>(json['sessionDateTime']),
      totalDurationSeconds:
          serializer.fromJson<int?>(json['totalDurationSeconds']),
      totalActivitySeconds:
          serializer.fromJson<int?>(json['totalActivitySeconds']),
      totalRestSeconds: serializer.fromJson<int?>(json['totalRestSeconds']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'sessionDateTime': serializer.toJson<DateTime>(sessionDateTime),
      'totalDurationSeconds': serializer.toJson<int?>(totalDurationSeconds),
      'totalActivitySeconds': serializer.toJson<int?>(totalActivitySeconds),
      'totalRestSeconds': serializer.toJson<int?>(totalRestSeconds),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Session copyWith(
          {String? id,
          DateTime? sessionDateTime,
          Value<int?> totalDurationSeconds = const Value.absent(),
          Value<int?> totalActivitySeconds = const Value.absent(),
          Value<int?> totalRestSeconds = const Value.absent(),
          Value<String?> notes = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      Session(
        id: id ?? this.id,
        sessionDateTime: sessionDateTime ?? this.sessionDateTime,
        totalDurationSeconds: totalDurationSeconds.present
            ? totalDurationSeconds.value
            : this.totalDurationSeconds,
        totalActivitySeconds: totalActivitySeconds.present
            ? totalActivitySeconds.value
            : this.totalActivitySeconds,
        totalRestSeconds: totalRestSeconds.present
            ? totalRestSeconds.value
            : this.totalRestSeconds,
        notes: notes.present ? notes.value : this.notes,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  Session copyWithCompanion(SessionsCompanion data) {
    return Session(
      id: data.id.present ? data.id.value : this.id,
      sessionDateTime: data.sessionDateTime.present
          ? data.sessionDateTime.value
          : this.sessionDateTime,
      totalDurationSeconds: data.totalDurationSeconds.present
          ? data.totalDurationSeconds.value
          : this.totalDurationSeconds,
      totalActivitySeconds: data.totalActivitySeconds.present
          ? data.totalActivitySeconds.value
          : this.totalActivitySeconds,
      totalRestSeconds: data.totalRestSeconds.present
          ? data.totalRestSeconds.value
          : this.totalRestSeconds,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Session(')
          ..write('id: $id, ')
          ..write('sessionDateTime: $sessionDateTime, ')
          ..write('totalDurationSeconds: $totalDurationSeconds, ')
          ..write('totalActivitySeconds: $totalActivitySeconds, ')
          ..write('totalRestSeconds: $totalRestSeconds, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, sessionDateTime, totalDurationSeconds,
      totalActivitySeconds, totalRestSeconds, notes, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Session &&
          other.id == this.id &&
          other.sessionDateTime == this.sessionDateTime &&
          other.totalDurationSeconds == this.totalDurationSeconds &&
          other.totalActivitySeconds == this.totalActivitySeconds &&
          other.totalRestSeconds == this.totalRestSeconds &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class SessionsCompanion extends UpdateCompanion<Session> {
  final Value<String> id;
  final Value<DateTime> sessionDateTime;
  final Value<int?> totalDurationSeconds;
  final Value<int?> totalActivitySeconds;
  final Value<int?> totalRestSeconds;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const SessionsCompanion({
    this.id = const Value.absent(),
    this.sessionDateTime = const Value.absent(),
    this.totalDurationSeconds = const Value.absent(),
    this.totalActivitySeconds = const Value.absent(),
    this.totalRestSeconds = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SessionsCompanion.insert({
    required String id,
    required DateTime sessionDateTime,
    this.totalDurationSeconds = const Value.absent(),
    this.totalActivitySeconds = const Value.absent(),
    this.totalRestSeconds = const Value.absent(),
    this.notes = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        sessionDateTime = Value(sessionDateTime),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<Session> custom({
    Expression<String>? id,
    Expression<DateTime>? sessionDateTime,
    Expression<int>? totalDurationSeconds,
    Expression<int>? totalActivitySeconds,
    Expression<int>? totalRestSeconds,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionDateTime != null) 'date_time': sessionDateTime,
      if (totalDurationSeconds != null)
        'total_duration_seconds': totalDurationSeconds,
      if (totalActivitySeconds != null)
        'total_activity_seconds': totalActivitySeconds,
      if (totalRestSeconds != null) 'total_rest_seconds': totalRestSeconds,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SessionsCompanion copyWith(
      {Value<String>? id,
      Value<DateTime>? sessionDateTime,
      Value<int?>? totalDurationSeconds,
      Value<int?>? totalActivitySeconds,
      Value<int?>? totalRestSeconds,
      Value<String?>? notes,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt,
      Value<int>? rowid}) {
    return SessionsCompanion(
      id: id ?? this.id,
      sessionDateTime: sessionDateTime ?? this.sessionDateTime,
      totalDurationSeconds: totalDurationSeconds ?? this.totalDurationSeconds,
      totalActivitySeconds: totalActivitySeconds ?? this.totalActivitySeconds,
      totalRestSeconds: totalRestSeconds ?? this.totalRestSeconds,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (sessionDateTime.present) {
      map['date_time'] = Variable<DateTime>(sessionDateTime.value);
    }
    if (totalDurationSeconds.present) {
      map['total_duration_seconds'] = Variable<int>(totalDurationSeconds.value);
    }
    if (totalActivitySeconds.present) {
      map['total_activity_seconds'] = Variable<int>(totalActivitySeconds.value);
    }
    if (totalRestSeconds.present) {
      map['total_rest_seconds'] = Variable<int>(totalRestSeconds.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SessionsCompanion(')
          ..write('id: $id, ')
          ..write('sessionDateTime: $sessionDateTime, ')
          ..write('totalDurationSeconds: $totalDurationSeconds, ')
          ..write('totalActivitySeconds: $totalActivitySeconds, ')
          ..write('totalRestSeconds: $totalRestSeconds, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ExerciseInstancesTable extends ExerciseInstances
    with TableInfo<$ExerciseInstancesTable, ExerciseInstance> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ExerciseInstancesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _slugMeta = const VerificationMeta('slug');
  @override
  late final GeneratedColumn<String> slug = GeneratedColumn<String>(
      'slug', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _familyIdMeta =
      const VerificationMeta('familyId');
  @override
  late final GeneratedColumn<String> familyId = GeneratedColumn<String>(
      'family_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _displayNameMeta =
      const VerificationMeta('displayName');
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
      'display_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, String>, String>
      discriminators = GeneratedColumn<String>(
              'discriminators', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<Map<String, String>>(
              $ExerciseInstancesTable.$converterdiscriminators);
  static const VerificationMeta _firstSeenAtMeta =
      const VerificationMeta('firstSeenAt');
  @override
  late final GeneratedColumn<DateTime> firstSeenAt = GeneratedColumn<DateTime>(
      'first_seen_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [slug, familyId, displayName, discriminators, firstSeenAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'exercise_instances';
  @override
  VerificationContext validateIntegrity(Insertable<ExerciseInstance> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('slug')) {
      context.handle(
          _slugMeta, slug.isAcceptableOrUnknown(data['slug']!, _slugMeta));
    } else if (isInserting) {
      context.missing(_slugMeta);
    }
    if (data.containsKey('family_id')) {
      context.handle(_familyIdMeta,
          familyId.isAcceptableOrUnknown(data['family_id']!, _familyIdMeta));
    } else if (isInserting) {
      context.missing(_familyIdMeta);
    }
    if (data.containsKey('display_name')) {
      context.handle(
          _displayNameMeta,
          displayName.isAcceptableOrUnknown(
              data['display_name']!, _displayNameMeta));
    } else if (isInserting) {
      context.missing(_displayNameMeta);
    }
    if (data.containsKey('first_seen_at')) {
      context.handle(
          _firstSeenAtMeta,
          firstSeenAt.isAcceptableOrUnknown(
              data['first_seen_at']!, _firstSeenAtMeta));
    } else if (isInserting) {
      context.missing(_firstSeenAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {slug};
  @override
  ExerciseInstance map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ExerciseInstance(
      slug: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}slug'])!,
      familyId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}family_id'])!,
      displayName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}display_name'])!,
      discriminators: $ExerciseInstancesTable.$converterdiscriminators.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}discriminators'])!),
      firstSeenAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}first_seen_at'])!,
    );
  }

  @override
  $ExerciseInstancesTable createAlias(String alias) {
    return $ExerciseInstancesTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, String>, String> $converterdiscriminators =
      const DiscriminatorsConverter();
}

class ExerciseInstance extends DataClass
    implements Insertable<ExerciseInstance> {
  final String slug;
  final String familyId;
  final String displayName;
  final Map<String, String> discriminators;
  final DateTime firstSeenAt;
  const ExerciseInstance(
      {required this.slug,
      required this.familyId,
      required this.displayName,
      required this.discriminators,
      required this.firstSeenAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['slug'] = Variable<String>(slug);
    map['family_id'] = Variable<String>(familyId);
    map['display_name'] = Variable<String>(displayName);
    {
      map['discriminators'] = Variable<String>($ExerciseInstancesTable
          .$converterdiscriminators
          .toSql(discriminators));
    }
    map['first_seen_at'] = Variable<DateTime>(firstSeenAt);
    return map;
  }

  ExerciseInstancesCompanion toCompanion(bool nullToAbsent) {
    return ExerciseInstancesCompanion(
      slug: Value(slug),
      familyId: Value(familyId),
      displayName: Value(displayName),
      discriminators: Value(discriminators),
      firstSeenAt: Value(firstSeenAt),
    );
  }

  factory ExerciseInstance.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ExerciseInstance(
      slug: serializer.fromJson<String>(json['slug']),
      familyId: serializer.fromJson<String>(json['familyId']),
      displayName: serializer.fromJson<String>(json['displayName']),
      discriminators:
          serializer.fromJson<Map<String, String>>(json['discriminators']),
      firstSeenAt: serializer.fromJson<DateTime>(json['firstSeenAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'slug': serializer.toJson<String>(slug),
      'familyId': serializer.toJson<String>(familyId),
      'displayName': serializer.toJson<String>(displayName),
      'discriminators': serializer.toJson<Map<String, String>>(discriminators),
      'firstSeenAt': serializer.toJson<DateTime>(firstSeenAt),
    };
  }

  ExerciseInstance copyWith(
          {String? slug,
          String? familyId,
          String? displayName,
          Map<String, String>? discriminators,
          DateTime? firstSeenAt}) =>
      ExerciseInstance(
        slug: slug ?? this.slug,
        familyId: familyId ?? this.familyId,
        displayName: displayName ?? this.displayName,
        discriminators: discriminators ?? this.discriminators,
        firstSeenAt: firstSeenAt ?? this.firstSeenAt,
      );
  ExerciseInstance copyWithCompanion(ExerciseInstancesCompanion data) {
    return ExerciseInstance(
      slug: data.slug.present ? data.slug.value : this.slug,
      familyId: data.familyId.present ? data.familyId.value : this.familyId,
      displayName:
          data.displayName.present ? data.displayName.value : this.displayName,
      discriminators: data.discriminators.present
          ? data.discriminators.value
          : this.discriminators,
      firstSeenAt:
          data.firstSeenAt.present ? data.firstSeenAt.value : this.firstSeenAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ExerciseInstance(')
          ..write('slug: $slug, ')
          ..write('familyId: $familyId, ')
          ..write('displayName: $displayName, ')
          ..write('discriminators: $discriminators, ')
          ..write('firstSeenAt: $firstSeenAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(slug, familyId, displayName, discriminators, firstSeenAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ExerciseInstance &&
          other.slug == this.slug &&
          other.familyId == this.familyId &&
          other.displayName == this.displayName &&
          other.discriminators == this.discriminators &&
          other.firstSeenAt == this.firstSeenAt);
}

class ExerciseInstancesCompanion extends UpdateCompanion<ExerciseInstance> {
  final Value<String> slug;
  final Value<String> familyId;
  final Value<String> displayName;
  final Value<Map<String, String>> discriminators;
  final Value<DateTime> firstSeenAt;
  final Value<int> rowid;
  const ExerciseInstancesCompanion({
    this.slug = const Value.absent(),
    this.familyId = const Value.absent(),
    this.displayName = const Value.absent(),
    this.discriminators = const Value.absent(),
    this.firstSeenAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ExerciseInstancesCompanion.insert({
    required String slug,
    required String familyId,
    required String displayName,
    required Map<String, String> discriminators,
    required DateTime firstSeenAt,
    this.rowid = const Value.absent(),
  })  : slug = Value(slug),
        familyId = Value(familyId),
        displayName = Value(displayName),
        discriminators = Value(discriminators),
        firstSeenAt = Value(firstSeenAt);
  static Insertable<ExerciseInstance> custom({
    Expression<String>? slug,
    Expression<String>? familyId,
    Expression<String>? displayName,
    Expression<String>? discriminators,
    Expression<DateTime>? firstSeenAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (slug != null) 'slug': slug,
      if (familyId != null) 'family_id': familyId,
      if (displayName != null) 'display_name': displayName,
      if (discriminators != null) 'discriminators': discriminators,
      if (firstSeenAt != null) 'first_seen_at': firstSeenAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ExerciseInstancesCompanion copyWith(
      {Value<String>? slug,
      Value<String>? familyId,
      Value<String>? displayName,
      Value<Map<String, String>>? discriminators,
      Value<DateTime>? firstSeenAt,
      Value<int>? rowid}) {
    return ExerciseInstancesCompanion(
      slug: slug ?? this.slug,
      familyId: familyId ?? this.familyId,
      displayName: displayName ?? this.displayName,
      discriminators: discriminators ?? this.discriminators,
      firstSeenAt: firstSeenAt ?? this.firstSeenAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (slug.present) {
      map['slug'] = Variable<String>(slug.value);
    }
    if (familyId.present) {
      map['family_id'] = Variable<String>(familyId.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (discriminators.present) {
      map['discriminators'] = Variable<String>($ExerciseInstancesTable
          .$converterdiscriminators
          .toSql(discriminators.value));
    }
    if (firstSeenAt.present) {
      map['first_seen_at'] = Variable<DateTime>(firstSeenAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ExerciseInstancesCompanion(')
          ..write('slug: $slug, ')
          ..write('familyId: $familyId, ')
          ..write('displayName: $displayName, ')
          ..write('discriminators: $discriminators, ')
          ..write('firstSeenAt: $firstSeenAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SetEntriesTable extends SetEntries
    with TableInfo<$SetEntriesTable, SetEntry> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SetEntriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _sessionIdMeta =
      const VerificationMeta('sessionId');
  @override
  late final GeneratedColumn<String> sessionId = GeneratedColumn<String>(
      'session_id', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES sessions (id)'));
  static const VerificationMeta _exerciseSlugMeta =
      const VerificationMeta('exerciseSlug');
  @override
  late final GeneratedColumn<String> exerciseSlug = GeneratedColumn<String>(
      'exercise_slug', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES exercise_instances (slug)'));
  static const VerificationMeta _setOrderMeta =
      const VerificationMeta('setOrder');
  @override
  late final GeneratedColumn<int> setOrder = GeneratedColumn<int>(
      'set_order', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _weightMeta = const VerificationMeta('weight');
  @override
  late final GeneratedColumn<double> weight = GeneratedColumn<double>(
      'weight', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _repsMeta = const VerificationMeta('reps');
  @override
  late final GeneratedColumn<int> reps = GeneratedColumn<int>(
      'reps', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _setTypeMeta =
      const VerificationMeta('setType');
  @override
  late final GeneratedColumn<String> setType = GeneratedColumn<String>(
      'set_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _durationSecondsMeta =
      const VerificationMeta('durationSeconds');
  @override
  late final GeneratedColumn<int> durationSeconds = GeneratedColumn<int>(
      'duration_seconds', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _distanceMMeta =
      const VerificationMeta('distanceM');
  @override
  late final GeneratedColumn<int> distanceM = GeneratedColumn<int>(
      'distance_m', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _caloriesMeta =
      const VerificationMeta('calories');
  @override
  late final GeneratedColumn<int> calories = GeneratedColumn<int>(
      'calories', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _rpeMeta = const VerificationMeta('rpe');
  @override
  late final GeneratedColumn<double> rpe = GeneratedColumn<double>(
      'rpe', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _metricsJsonMeta =
      const VerificationMeta('metricsJson');
  @override
  late final GeneratedColumn<String> metricsJson = GeneratedColumn<String>(
      'metrics_json', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _prescriptionJsonMeta =
      const VerificationMeta('prescriptionJson');
  @override
  late final GeneratedColumn<String> prescriptionJson = GeneratedColumn<String>(
      'prescription_json', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        sessionId,
        exerciseSlug,
        setOrder,
        weight,
        reps,
        setType,
        durationSeconds,
        distanceM,
        calories,
        rpe,
        metricsJson,
        prescriptionJson,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'set_entries';
  @override
  VerificationContext validateIntegrity(Insertable<SetEntry> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('session_id')) {
      context.handle(_sessionIdMeta,
          sessionId.isAcceptableOrUnknown(data['session_id']!, _sessionIdMeta));
    } else if (isInserting) {
      context.missing(_sessionIdMeta);
    }
    if (data.containsKey('exercise_slug')) {
      context.handle(
          _exerciseSlugMeta,
          exerciseSlug.isAcceptableOrUnknown(
              data['exercise_slug']!, _exerciseSlugMeta));
    } else if (isInserting) {
      context.missing(_exerciseSlugMeta);
    }
    if (data.containsKey('set_order')) {
      context.handle(_setOrderMeta,
          setOrder.isAcceptableOrUnknown(data['set_order']!, _setOrderMeta));
    } else if (isInserting) {
      context.missing(_setOrderMeta);
    }
    if (data.containsKey('weight')) {
      context.handle(_weightMeta,
          weight.isAcceptableOrUnknown(data['weight']!, _weightMeta));
    } else if (isInserting) {
      context.missing(_weightMeta);
    }
    if (data.containsKey('reps')) {
      context.handle(
          _repsMeta, reps.isAcceptableOrUnknown(data['reps']!, _repsMeta));
    } else if (isInserting) {
      context.missing(_repsMeta);
    }
    if (data.containsKey('set_type')) {
      context.handle(_setTypeMeta,
          setType.isAcceptableOrUnknown(data['set_type']!, _setTypeMeta));
    }
    if (data.containsKey('duration_seconds')) {
      context.handle(
          _durationSecondsMeta,
          durationSeconds.isAcceptableOrUnknown(
              data['duration_seconds']!, _durationSecondsMeta));
    }
    if (data.containsKey('distance_m')) {
      context.handle(_distanceMMeta,
          distanceM.isAcceptableOrUnknown(data['distance_m']!, _distanceMMeta));
    }
    if (data.containsKey('calories')) {
      context.handle(_caloriesMeta,
          calories.isAcceptableOrUnknown(data['calories']!, _caloriesMeta));
    }
    if (data.containsKey('rpe')) {
      context.handle(
          _rpeMeta, rpe.isAcceptableOrUnknown(data['rpe']!, _rpeMeta));
    }
    if (data.containsKey('metrics_json')) {
      context.handle(
          _metricsJsonMeta,
          metricsJson.isAcceptableOrUnknown(
              data['metrics_json']!, _metricsJsonMeta));
    }
    if (data.containsKey('prescription_json')) {
      context.handle(
          _prescriptionJsonMeta,
          prescriptionJson.isAcceptableOrUnknown(
              data['prescription_json']!, _prescriptionJsonMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SetEntry map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SetEntry(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      sessionId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}session_id'])!,
      exerciseSlug: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}exercise_slug'])!,
      setOrder: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}set_order'])!,
      weight: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}weight'])!,
      reps: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}reps'])!,
      setType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}set_type']),
      durationSeconds: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}duration_seconds']),
      distanceM: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}distance_m']),
      calories: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}calories']),
      rpe: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}rpe']),
      metricsJson: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}metrics_json']),
      prescriptionJson: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}prescription_json']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $SetEntriesTable createAlias(String alias) {
    return $SetEntriesTable(attachedDatabase, alias);
  }
}

class SetEntry extends DataClass implements Insertable<SetEntry> {
  final String id;
  final String sessionId;
  final String exerciseSlug;
  final int setOrder;
  final double weight;
  final int reps;
  final String? setType;
  final int? durationSeconds;
  final int? distanceM;
  final int? calories;
  final double? rpe;
  final String? metricsJson;
  final String? prescriptionJson;
  final DateTime createdAt;
  final DateTime updatedAt;
  const SetEntry(
      {required this.id,
      required this.sessionId,
      required this.exerciseSlug,
      required this.setOrder,
      required this.weight,
      required this.reps,
      this.setType,
      this.durationSeconds,
      this.distanceM,
      this.calories,
      this.rpe,
      this.metricsJson,
      this.prescriptionJson,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['session_id'] = Variable<String>(sessionId);
    map['exercise_slug'] = Variable<String>(exerciseSlug);
    map['set_order'] = Variable<int>(setOrder);
    map['weight'] = Variable<double>(weight);
    map['reps'] = Variable<int>(reps);
    if (!nullToAbsent || setType != null) {
      map['set_type'] = Variable<String>(setType);
    }
    if (!nullToAbsent || durationSeconds != null) {
      map['duration_seconds'] = Variable<int>(durationSeconds);
    }
    if (!nullToAbsent || distanceM != null) {
      map['distance_m'] = Variable<int>(distanceM);
    }
    if (!nullToAbsent || calories != null) {
      map['calories'] = Variable<int>(calories);
    }
    if (!nullToAbsent || rpe != null) {
      map['rpe'] = Variable<double>(rpe);
    }
    if (!nullToAbsent || metricsJson != null) {
      map['metrics_json'] = Variable<String>(metricsJson);
    }
    if (!nullToAbsent || prescriptionJson != null) {
      map['prescription_json'] = Variable<String>(prescriptionJson);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  SetEntriesCompanion toCompanion(bool nullToAbsent) {
    return SetEntriesCompanion(
      id: Value(id),
      sessionId: Value(sessionId),
      exerciseSlug: Value(exerciseSlug),
      setOrder: Value(setOrder),
      weight: Value(weight),
      reps: Value(reps),
      setType: setType == null && nullToAbsent
          ? const Value.absent()
          : Value(setType),
      durationSeconds: durationSeconds == null && nullToAbsent
          ? const Value.absent()
          : Value(durationSeconds),
      distanceM: distanceM == null && nullToAbsent
          ? const Value.absent()
          : Value(distanceM),
      calories: calories == null && nullToAbsent
          ? const Value.absent()
          : Value(calories),
      rpe: rpe == null && nullToAbsent ? const Value.absent() : Value(rpe),
      metricsJson: metricsJson == null && nullToAbsent
          ? const Value.absent()
          : Value(metricsJson),
      prescriptionJson: prescriptionJson == null && nullToAbsent
          ? const Value.absent()
          : Value(prescriptionJson),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory SetEntry.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SetEntry(
      id: serializer.fromJson<String>(json['id']),
      sessionId: serializer.fromJson<String>(json['sessionId']),
      exerciseSlug: serializer.fromJson<String>(json['exerciseSlug']),
      setOrder: serializer.fromJson<int>(json['setOrder']),
      weight: serializer.fromJson<double>(json['weight']),
      reps: serializer.fromJson<int>(json['reps']),
      setType: serializer.fromJson<String?>(json['setType']),
      durationSeconds: serializer.fromJson<int?>(json['durationSeconds']),
      distanceM: serializer.fromJson<int?>(json['distanceM']),
      calories: serializer.fromJson<int?>(json['calories']),
      rpe: serializer.fromJson<double?>(json['rpe']),
      metricsJson: serializer.fromJson<String?>(json['metricsJson']),
      prescriptionJson: serializer.fromJson<String?>(json['prescriptionJson']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'sessionId': serializer.toJson<String>(sessionId),
      'exerciseSlug': serializer.toJson<String>(exerciseSlug),
      'setOrder': serializer.toJson<int>(setOrder),
      'weight': serializer.toJson<double>(weight),
      'reps': serializer.toJson<int>(reps),
      'setType': serializer.toJson<String?>(setType),
      'durationSeconds': serializer.toJson<int?>(durationSeconds),
      'distanceM': serializer.toJson<int?>(distanceM),
      'calories': serializer.toJson<int?>(calories),
      'rpe': serializer.toJson<double?>(rpe),
      'metricsJson': serializer.toJson<String?>(metricsJson),
      'prescriptionJson': serializer.toJson<String?>(prescriptionJson),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  SetEntry copyWith(
          {String? id,
          String? sessionId,
          String? exerciseSlug,
          int? setOrder,
          double? weight,
          int? reps,
          Value<String?> setType = const Value.absent(),
          Value<int?> durationSeconds = const Value.absent(),
          Value<int?> distanceM = const Value.absent(),
          Value<int?> calories = const Value.absent(),
          Value<double?> rpe = const Value.absent(),
          Value<String?> metricsJson = const Value.absent(),
          Value<String?> prescriptionJson = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      SetEntry(
        id: id ?? this.id,
        sessionId: sessionId ?? this.sessionId,
        exerciseSlug: exerciseSlug ?? this.exerciseSlug,
        setOrder: setOrder ?? this.setOrder,
        weight: weight ?? this.weight,
        reps: reps ?? this.reps,
        setType: setType.present ? setType.value : this.setType,
        durationSeconds: durationSeconds.present
            ? durationSeconds.value
            : this.durationSeconds,
        distanceM: distanceM.present ? distanceM.value : this.distanceM,
        calories: calories.present ? calories.value : this.calories,
        rpe: rpe.present ? rpe.value : this.rpe,
        metricsJson: metricsJson.present ? metricsJson.value : this.metricsJson,
        prescriptionJson: prescriptionJson.present
            ? prescriptionJson.value
            : this.prescriptionJson,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  SetEntry copyWithCompanion(SetEntriesCompanion data) {
    return SetEntry(
      id: data.id.present ? data.id.value : this.id,
      sessionId: data.sessionId.present ? data.sessionId.value : this.sessionId,
      exerciseSlug: data.exerciseSlug.present
          ? data.exerciseSlug.value
          : this.exerciseSlug,
      setOrder: data.setOrder.present ? data.setOrder.value : this.setOrder,
      weight: data.weight.present ? data.weight.value : this.weight,
      reps: data.reps.present ? data.reps.value : this.reps,
      setType: data.setType.present ? data.setType.value : this.setType,
      durationSeconds: data.durationSeconds.present
          ? data.durationSeconds.value
          : this.durationSeconds,
      distanceM: data.distanceM.present ? data.distanceM.value : this.distanceM,
      calories: data.calories.present ? data.calories.value : this.calories,
      rpe: data.rpe.present ? data.rpe.value : this.rpe,
      metricsJson:
          data.metricsJson.present ? data.metricsJson.value : this.metricsJson,
      prescriptionJson: data.prescriptionJson.present
          ? data.prescriptionJson.value
          : this.prescriptionJson,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SetEntry(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('exerciseSlug: $exerciseSlug, ')
          ..write('setOrder: $setOrder, ')
          ..write('weight: $weight, ')
          ..write('reps: $reps, ')
          ..write('setType: $setType, ')
          ..write('durationSeconds: $durationSeconds, ')
          ..write('distanceM: $distanceM, ')
          ..write('calories: $calories, ')
          ..write('rpe: $rpe, ')
          ..write('metricsJson: $metricsJson, ')
          ..write('prescriptionJson: $prescriptionJson, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      sessionId,
      exerciseSlug,
      setOrder,
      weight,
      reps,
      setType,
      durationSeconds,
      distanceM,
      calories,
      rpe,
      metricsJson,
      prescriptionJson,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SetEntry &&
          other.id == this.id &&
          other.sessionId == this.sessionId &&
          other.exerciseSlug == this.exerciseSlug &&
          other.setOrder == this.setOrder &&
          other.weight == this.weight &&
          other.reps == this.reps &&
          other.setType == this.setType &&
          other.durationSeconds == this.durationSeconds &&
          other.distanceM == this.distanceM &&
          other.calories == this.calories &&
          other.rpe == this.rpe &&
          other.metricsJson == this.metricsJson &&
          other.prescriptionJson == this.prescriptionJson &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class SetEntriesCompanion extends UpdateCompanion<SetEntry> {
  final Value<String> id;
  final Value<String> sessionId;
  final Value<String> exerciseSlug;
  final Value<int> setOrder;
  final Value<double> weight;
  final Value<int> reps;
  final Value<String?> setType;
  final Value<int?> durationSeconds;
  final Value<int?> distanceM;
  final Value<int?> calories;
  final Value<double?> rpe;
  final Value<String?> metricsJson;
  final Value<String?> prescriptionJson;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const SetEntriesCompanion({
    this.id = const Value.absent(),
    this.sessionId = const Value.absent(),
    this.exerciseSlug = const Value.absent(),
    this.setOrder = const Value.absent(),
    this.weight = const Value.absent(),
    this.reps = const Value.absent(),
    this.setType = const Value.absent(),
    this.durationSeconds = const Value.absent(),
    this.distanceM = const Value.absent(),
    this.calories = const Value.absent(),
    this.rpe = const Value.absent(),
    this.metricsJson = const Value.absent(),
    this.prescriptionJson = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SetEntriesCompanion.insert({
    required String id,
    required String sessionId,
    required String exerciseSlug,
    required int setOrder,
    required double weight,
    required int reps,
    this.setType = const Value.absent(),
    this.durationSeconds = const Value.absent(),
    this.distanceM = const Value.absent(),
    this.calories = const Value.absent(),
    this.rpe = const Value.absent(),
    this.metricsJson = const Value.absent(),
    this.prescriptionJson = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        sessionId = Value(sessionId),
        exerciseSlug = Value(exerciseSlug),
        setOrder = Value(setOrder),
        weight = Value(weight),
        reps = Value(reps),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<SetEntry> custom({
    Expression<String>? id,
    Expression<String>? sessionId,
    Expression<String>? exerciseSlug,
    Expression<int>? setOrder,
    Expression<double>? weight,
    Expression<int>? reps,
    Expression<String>? setType,
    Expression<int>? durationSeconds,
    Expression<int>? distanceM,
    Expression<int>? calories,
    Expression<double>? rpe,
    Expression<String>? metricsJson,
    Expression<String>? prescriptionJson,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionId != null) 'session_id': sessionId,
      if (exerciseSlug != null) 'exercise_slug': exerciseSlug,
      if (setOrder != null) 'set_order': setOrder,
      if (weight != null) 'weight': weight,
      if (reps != null) 'reps': reps,
      if (setType != null) 'set_type': setType,
      if (durationSeconds != null) 'duration_seconds': durationSeconds,
      if (distanceM != null) 'distance_m': distanceM,
      if (calories != null) 'calories': calories,
      if (rpe != null) 'rpe': rpe,
      if (metricsJson != null) 'metrics_json': metricsJson,
      if (prescriptionJson != null) 'prescription_json': prescriptionJson,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SetEntriesCompanion copyWith(
      {Value<String>? id,
      Value<String>? sessionId,
      Value<String>? exerciseSlug,
      Value<int>? setOrder,
      Value<double>? weight,
      Value<int>? reps,
      Value<String?>? setType,
      Value<int?>? durationSeconds,
      Value<int?>? distanceM,
      Value<int?>? calories,
      Value<double?>? rpe,
      Value<String?>? metricsJson,
      Value<String?>? prescriptionJson,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt,
      Value<int>? rowid}) {
    return SetEntriesCompanion(
      id: id ?? this.id,
      sessionId: sessionId ?? this.sessionId,
      exerciseSlug: exerciseSlug ?? this.exerciseSlug,
      setOrder: setOrder ?? this.setOrder,
      weight: weight ?? this.weight,
      reps: reps ?? this.reps,
      setType: setType ?? this.setType,
      durationSeconds: durationSeconds ?? this.durationSeconds,
      distanceM: distanceM ?? this.distanceM,
      calories: calories ?? this.calories,
      rpe: rpe ?? this.rpe,
      metricsJson: metricsJson ?? this.metricsJson,
      prescriptionJson: prescriptionJson ?? this.prescriptionJson,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (sessionId.present) {
      map['session_id'] = Variable<String>(sessionId.value);
    }
    if (exerciseSlug.present) {
      map['exercise_slug'] = Variable<String>(exerciseSlug.value);
    }
    if (setOrder.present) {
      map['set_order'] = Variable<int>(setOrder.value);
    }
    if (weight.present) {
      map['weight'] = Variable<double>(weight.value);
    }
    if (reps.present) {
      map['reps'] = Variable<int>(reps.value);
    }
    if (setType.present) {
      map['set_type'] = Variable<String>(setType.value);
    }
    if (durationSeconds.present) {
      map['duration_seconds'] = Variable<int>(durationSeconds.value);
    }
    if (distanceM.present) {
      map['distance_m'] = Variable<int>(distanceM.value);
    }
    if (calories.present) {
      map['calories'] = Variable<int>(calories.value);
    }
    if (rpe.present) {
      map['rpe'] = Variable<double>(rpe.value);
    }
    if (metricsJson.present) {
      map['metrics_json'] = Variable<String>(metricsJson.value);
    }
    if (prescriptionJson.present) {
      map['prescription_json'] = Variable<String>(prescriptionJson.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SetEntriesCompanion(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('exerciseSlug: $exerciseSlug, ')
          ..write('setOrder: $setOrder, ')
          ..write('weight: $weight, ')
          ..write('reps: $reps, ')
          ..write('setType: $setType, ')
          ..write('durationSeconds: $durationSeconds, ')
          ..write('distanceM: $distanceM, ')
          ..write('calories: $calories, ')
          ..write('rpe: $rpe, ')
          ..write('metricsJson: $metricsJson, ')
          ..write('prescriptionJson: $prescriptionJson, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SavedWarmupsTable extends SavedWarmups
    with TableInfo<$SavedWarmupsTable, SavedWarmup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SavedWarmupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _sessionIdMeta =
      const VerificationMeta('sessionId');
  @override
  late final GeneratedColumn<String> sessionId = GeneratedColumn<String>(
      'session_id', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES sessions (id)'));
  static const VerificationMeta _warmupIdMeta =
      const VerificationMeta('warmupId');
  @override
  late final GeneratedColumn<String> warmupId = GeneratedColumn<String>(
      'warmup_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _displayNameMeta =
      const VerificationMeta('displayName');
  @override
  late final GeneratedColumn<String> displayName = GeneratedColumn<String>(
      'display_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, String>, String>
      parameters = GeneratedColumn<String>('parameters', aliasedName, false,
              type: DriftSqlType.string, requiredDuringInsert: true)
          .withConverter<Map<String, String>>(
              $SavedWarmupsTable.$converterparameters);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [id, sessionId, warmupId, displayName, parameters, createdAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'saved_warmups';
  @override
  VerificationContext validateIntegrity(Insertable<SavedWarmup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('session_id')) {
      context.handle(_sessionIdMeta,
          sessionId.isAcceptableOrUnknown(data['session_id']!, _sessionIdMeta));
    } else if (isInserting) {
      context.missing(_sessionIdMeta);
    }
    if (data.containsKey('warmup_id')) {
      context.handle(_warmupIdMeta,
          warmupId.isAcceptableOrUnknown(data['warmup_id']!, _warmupIdMeta));
    } else if (isInserting) {
      context.missing(_warmupIdMeta);
    }
    if (data.containsKey('display_name')) {
      context.handle(
          _displayNameMeta,
          displayName.isAcceptableOrUnknown(
              data['display_name']!, _displayNameMeta));
    } else if (isInserting) {
      context.missing(_displayNameMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SavedWarmup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SavedWarmup(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      sessionId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}session_id'])!,
      warmupId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}warmup_id'])!,
      displayName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}display_name'])!,
      parameters: $SavedWarmupsTable.$converterparameters.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.string, data['${effectivePrefix}parameters'])!),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
    );
  }

  @override
  $SavedWarmupsTable createAlias(String alias) {
    return $SavedWarmupsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, String>, String> $converterparameters =
      const DiscriminatorsConverter();
}

class SavedWarmup extends DataClass implements Insertable<SavedWarmup> {
  final String id;
  final String sessionId;
  final String warmupId;
  final String displayName;
  final Map<String, String> parameters;
  final DateTime createdAt;
  const SavedWarmup(
      {required this.id,
      required this.sessionId,
      required this.warmupId,
      required this.displayName,
      required this.parameters,
      required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['session_id'] = Variable<String>(sessionId);
    map['warmup_id'] = Variable<String>(warmupId);
    map['display_name'] = Variable<String>(displayName);
    {
      map['parameters'] = Variable<String>(
          $SavedWarmupsTable.$converterparameters.toSql(parameters));
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  SavedWarmupsCompanion toCompanion(bool nullToAbsent) {
    return SavedWarmupsCompanion(
      id: Value(id),
      sessionId: Value(sessionId),
      warmupId: Value(warmupId),
      displayName: Value(displayName),
      parameters: Value(parameters),
      createdAt: Value(createdAt),
    );
  }

  factory SavedWarmup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SavedWarmup(
      id: serializer.fromJson<String>(json['id']),
      sessionId: serializer.fromJson<String>(json['sessionId']),
      warmupId: serializer.fromJson<String>(json['warmupId']),
      displayName: serializer.fromJson<String>(json['displayName']),
      parameters: serializer.fromJson<Map<String, String>>(json['parameters']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'sessionId': serializer.toJson<String>(sessionId),
      'warmupId': serializer.toJson<String>(warmupId),
      'displayName': serializer.toJson<String>(displayName),
      'parameters': serializer.toJson<Map<String, String>>(parameters),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  SavedWarmup copyWith(
          {String? id,
          String? sessionId,
          String? warmupId,
          String? displayName,
          Map<String, String>? parameters,
          DateTime? createdAt}) =>
      SavedWarmup(
        id: id ?? this.id,
        sessionId: sessionId ?? this.sessionId,
        warmupId: warmupId ?? this.warmupId,
        displayName: displayName ?? this.displayName,
        parameters: parameters ?? this.parameters,
        createdAt: createdAt ?? this.createdAt,
      );
  SavedWarmup copyWithCompanion(SavedWarmupsCompanion data) {
    return SavedWarmup(
      id: data.id.present ? data.id.value : this.id,
      sessionId: data.sessionId.present ? data.sessionId.value : this.sessionId,
      warmupId: data.warmupId.present ? data.warmupId.value : this.warmupId,
      displayName:
          data.displayName.present ? data.displayName.value : this.displayName,
      parameters:
          data.parameters.present ? data.parameters.value : this.parameters,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SavedWarmup(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('warmupId: $warmupId, ')
          ..write('displayName: $displayName, ')
          ..write('parameters: $parameters, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, sessionId, warmupId, displayName, parameters, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SavedWarmup &&
          other.id == this.id &&
          other.sessionId == this.sessionId &&
          other.warmupId == this.warmupId &&
          other.displayName == this.displayName &&
          other.parameters == this.parameters &&
          other.createdAt == this.createdAt);
}

class SavedWarmupsCompanion extends UpdateCompanion<SavedWarmup> {
  final Value<String> id;
  final Value<String> sessionId;
  final Value<String> warmupId;
  final Value<String> displayName;
  final Value<Map<String, String>> parameters;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const SavedWarmupsCompanion({
    this.id = const Value.absent(),
    this.sessionId = const Value.absent(),
    this.warmupId = const Value.absent(),
    this.displayName = const Value.absent(),
    this.parameters = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SavedWarmupsCompanion.insert({
    required String id,
    required String sessionId,
    required String warmupId,
    required String displayName,
    required Map<String, String> parameters,
    required DateTime createdAt,
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        sessionId = Value(sessionId),
        warmupId = Value(warmupId),
        displayName = Value(displayName),
        parameters = Value(parameters),
        createdAt = Value(createdAt);
  static Insertable<SavedWarmup> custom({
    Expression<String>? id,
    Expression<String>? sessionId,
    Expression<String>? warmupId,
    Expression<String>? displayName,
    Expression<String>? parameters,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionId != null) 'session_id': sessionId,
      if (warmupId != null) 'warmup_id': warmupId,
      if (displayName != null) 'display_name': displayName,
      if (parameters != null) 'parameters': parameters,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SavedWarmupsCompanion copyWith(
      {Value<String>? id,
      Value<String>? sessionId,
      Value<String>? warmupId,
      Value<String>? displayName,
      Value<Map<String, String>>? parameters,
      Value<DateTime>? createdAt,
      Value<int>? rowid}) {
    return SavedWarmupsCompanion(
      id: id ?? this.id,
      sessionId: sessionId ?? this.sessionId,
      warmupId: warmupId ?? this.warmupId,
      displayName: displayName ?? this.displayName,
      parameters: parameters ?? this.parameters,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (sessionId.present) {
      map['session_id'] = Variable<String>(sessionId.value);
    }
    if (warmupId.present) {
      map['warmup_id'] = Variable<String>(warmupId.value);
    }
    if (displayName.present) {
      map['display_name'] = Variable<String>(displayName.value);
    }
    if (parameters.present) {
      map['parameters'] = Variable<String>(
          $SavedWarmupsTable.$converterparameters.toSql(parameters.value));
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SavedWarmupsCompanion(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('warmupId: $warmupId, ')
          ..write('displayName: $displayName, ')
          ..write('parameters: $parameters, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $SessionsTable sessions = $SessionsTable(this);
  late final $ExerciseInstancesTable exerciseInstances =
      $ExerciseInstancesTable(this);
  late final $SetEntriesTable setEntries = $SetEntriesTable(this);
  late final $SavedWarmupsTable savedWarmups = $SavedWarmupsTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities =>
      [sessions, exerciseInstances, setEntries, savedWarmups];
}

typedef $$SessionsTableCreateCompanionBuilder = SessionsCompanion Function({
  required String id,
  required DateTime sessionDateTime,
  Value<int?> totalDurationSeconds,
  Value<int?> totalActivitySeconds,
  Value<int?> totalRestSeconds,
  Value<String?> notes,
  required DateTime createdAt,
  required DateTime updatedAt,
  Value<int> rowid,
});
typedef $$SessionsTableUpdateCompanionBuilder = SessionsCompanion Function({
  Value<String> id,
  Value<DateTime> sessionDateTime,
  Value<int?> totalDurationSeconds,
  Value<int?> totalActivitySeconds,
  Value<int?> totalRestSeconds,
  Value<String?> notes,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
  Value<int> rowid,
});

final class $$SessionsTableReferences
    extends BaseReferences<_$AppDatabase, $SessionsTable, Session> {
  $$SessionsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$SetEntriesTable, List<SetEntry>>
      _setEntriesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.setEntries,
          aliasName:
              $_aliasNameGenerator(db.sessions.id, db.setEntries.sessionId));

  $$SetEntriesTableProcessedTableManager get setEntriesRefs {
    final manager = $$SetEntriesTableTableManager($_db, $_db.setEntries)
        .filter((f) => f.sessionId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_setEntriesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$SavedWarmupsTable, List<SavedWarmup>>
      _savedWarmupsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.savedWarmups,
          aliasName:
              $_aliasNameGenerator(db.sessions.id, db.savedWarmups.sessionId));

  $$SavedWarmupsTableProcessedTableManager get savedWarmupsRefs {
    final manager = $$SavedWarmupsTableTableManager($_db, $_db.savedWarmups)
        .filter((f) => f.sessionId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_savedWarmupsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$SessionsTableFilterComposer
    extends Composer<_$AppDatabase, $SessionsTable> {
  $$SessionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get sessionDateTime => $composableBuilder(
      column: $table.sessionDateTime,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get totalDurationSeconds => $composableBuilder(
      column: $table.totalDurationSeconds,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get totalActivitySeconds => $composableBuilder(
      column: $table.totalActivitySeconds,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get totalRestSeconds => $composableBuilder(
      column: $table.totalRestSeconds,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  Expression<bool> setEntriesRefs(
      Expression<bool> Function($$SetEntriesTableFilterComposer f) f) {
    final $$SetEntriesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.setEntries,
        getReferencedColumn: (t) => t.sessionId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SetEntriesTableFilterComposer(
              $db: $db,
              $table: $db.setEntries,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> savedWarmupsRefs(
      Expression<bool> Function($$SavedWarmupsTableFilterComposer f) f) {
    final $$SavedWarmupsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.savedWarmups,
        getReferencedColumn: (t) => t.sessionId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SavedWarmupsTableFilterComposer(
              $db: $db,
              $table: $db.savedWarmups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$SessionsTableOrderingComposer
    extends Composer<_$AppDatabase, $SessionsTable> {
  $$SessionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get sessionDateTime => $composableBuilder(
      column: $table.sessionDateTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get totalDurationSeconds => $composableBuilder(
      column: $table.totalDurationSeconds,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get totalActivitySeconds => $composableBuilder(
      column: $table.totalActivitySeconds,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get totalRestSeconds => $composableBuilder(
      column: $table.totalRestSeconds,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$SessionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SessionsTable> {
  $$SessionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get sessionDateTime => $composableBuilder(
      column: $table.sessionDateTime, builder: (column) => column);

  GeneratedColumn<int> get totalDurationSeconds => $composableBuilder(
      column: $table.totalDurationSeconds, builder: (column) => column);

  GeneratedColumn<int> get totalActivitySeconds => $composableBuilder(
      column: $table.totalActivitySeconds, builder: (column) => column);

  GeneratedColumn<int> get totalRestSeconds => $composableBuilder(
      column: $table.totalRestSeconds, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> setEntriesRefs<T extends Object>(
      Expression<T> Function($$SetEntriesTableAnnotationComposer a) f) {
    final $$SetEntriesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.setEntries,
        getReferencedColumn: (t) => t.sessionId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SetEntriesTableAnnotationComposer(
              $db: $db,
              $table: $db.setEntries,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> savedWarmupsRefs<T extends Object>(
      Expression<T> Function($$SavedWarmupsTableAnnotationComposer a) f) {
    final $$SavedWarmupsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.savedWarmups,
        getReferencedColumn: (t) => t.sessionId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SavedWarmupsTableAnnotationComposer(
              $db: $db,
              $table: $db.savedWarmups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$SessionsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $SessionsTable,
    Session,
    $$SessionsTableFilterComposer,
    $$SessionsTableOrderingComposer,
    $$SessionsTableAnnotationComposer,
    $$SessionsTableCreateCompanionBuilder,
    $$SessionsTableUpdateCompanionBuilder,
    (Session, $$SessionsTableReferences),
    Session,
    PrefetchHooks Function({bool setEntriesRefs, bool savedWarmupsRefs})> {
  $$SessionsTableTableManager(_$AppDatabase db, $SessionsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SessionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SessionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SessionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<DateTime> sessionDateTime = const Value.absent(),
            Value<int?> totalDurationSeconds = const Value.absent(),
            Value<int?> totalActivitySeconds = const Value.absent(),
            Value<int?> totalRestSeconds = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              SessionsCompanion(
            id: id,
            sessionDateTime: sessionDateTime,
            totalDurationSeconds: totalDurationSeconds,
            totalActivitySeconds: totalActivitySeconds,
            totalRestSeconds: totalRestSeconds,
            notes: notes,
            createdAt: createdAt,
            updatedAt: updatedAt,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            required DateTime sessionDateTime,
            Value<int?> totalDurationSeconds = const Value.absent(),
            Value<int?> totalActivitySeconds = const Value.absent(),
            Value<int?> totalRestSeconds = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            required DateTime createdAt,
            required DateTime updatedAt,
            Value<int> rowid = const Value.absent(),
          }) =>
              SessionsCompanion.insert(
            id: id,
            sessionDateTime: sessionDateTime,
            totalDurationSeconds: totalDurationSeconds,
            totalActivitySeconds: totalActivitySeconds,
            totalRestSeconds: totalRestSeconds,
            notes: notes,
            createdAt: createdAt,
            updatedAt: updatedAt,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $$SessionsTableReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: (
              {setEntriesRefs = false, savedWarmupsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (setEntriesRefs) db.setEntries,
                if (savedWarmupsRefs) db.savedWarmups
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (setEntriesRefs)
                    await $_getPrefetchedData<Session, $SessionsTable,
                            SetEntry>(
                        currentTable: table,
                        referencedTable:
                            $$SessionsTableReferences._setEntriesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$SessionsTableReferences(db, table, p0)
                                .setEntriesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.sessionId == item.id),
                        typedResults: items),
                  if (savedWarmupsRefs)
                    await $_getPrefetchedData<Session, $SessionsTable,
                            SavedWarmup>(
                        currentTable: table,
                        referencedTable: $$SessionsTableReferences
                            ._savedWarmupsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$SessionsTableReferences(db, table, p0)
                                .savedWarmupsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.sessionId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$SessionsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $SessionsTable,
    Session,
    $$SessionsTableFilterComposer,
    $$SessionsTableOrderingComposer,
    $$SessionsTableAnnotationComposer,
    $$SessionsTableCreateCompanionBuilder,
    $$SessionsTableUpdateCompanionBuilder,
    (Session, $$SessionsTableReferences),
    Session,
    PrefetchHooks Function({bool setEntriesRefs, bool savedWarmupsRefs})>;
typedef $$ExerciseInstancesTableCreateCompanionBuilder
    = ExerciseInstancesCompanion Function({
  required String slug,
  required String familyId,
  required String displayName,
  required Map<String, String> discriminators,
  required DateTime firstSeenAt,
  Value<int> rowid,
});
typedef $$ExerciseInstancesTableUpdateCompanionBuilder
    = ExerciseInstancesCompanion Function({
  Value<String> slug,
  Value<String> familyId,
  Value<String> displayName,
  Value<Map<String, String>> discriminators,
  Value<DateTime> firstSeenAt,
  Value<int> rowid,
});

final class $$ExerciseInstancesTableReferences extends BaseReferences<
    _$AppDatabase, $ExerciseInstancesTable, ExerciseInstance> {
  $$ExerciseInstancesTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$SetEntriesTable, List<SetEntry>>
      _setEntriesRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.setEntries,
              aliasName: $_aliasNameGenerator(
                  db.exerciseInstances.slug, db.setEntries.exerciseSlug));

  $$SetEntriesTableProcessedTableManager get setEntriesRefs {
    final manager = $$SetEntriesTableTableManager($_db, $_db.setEntries).filter(
        (f) => f.exerciseSlug.slug.sqlEquals($_itemColumn<String>('slug')!));

    final cache = $_typedResult.readTableOrNull(_setEntriesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$ExerciseInstancesTableFilterComposer
    extends Composer<_$AppDatabase, $ExerciseInstancesTable> {
  $$ExerciseInstancesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get slug => $composableBuilder(
      column: $table.slug, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get familyId => $composableBuilder(
      column: $table.familyId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, String>, Map<String, String>,
          String>
      get discriminators => $composableBuilder(
          column: $table.discriminators,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<DateTime> get firstSeenAt => $composableBuilder(
      column: $table.firstSeenAt, builder: (column) => ColumnFilters(column));

  Expression<bool> setEntriesRefs(
      Expression<bool> Function($$SetEntriesTableFilterComposer f) f) {
    final $$SetEntriesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.slug,
        referencedTable: $db.setEntries,
        getReferencedColumn: (t) => t.exerciseSlug,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SetEntriesTableFilterComposer(
              $db: $db,
              $table: $db.setEntries,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ExerciseInstancesTableOrderingComposer
    extends Composer<_$AppDatabase, $ExerciseInstancesTable> {
  $$ExerciseInstancesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get slug => $composableBuilder(
      column: $table.slug, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get familyId => $composableBuilder(
      column: $table.familyId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get discriminators => $composableBuilder(
      column: $table.discriminators,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get firstSeenAt => $composableBuilder(
      column: $table.firstSeenAt, builder: (column) => ColumnOrderings(column));
}

class $$ExerciseInstancesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ExerciseInstancesTable> {
  $$ExerciseInstancesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get slug =>
      $composableBuilder(column: $table.slug, builder: (column) => column);

  GeneratedColumn<String> get familyId =>
      $composableBuilder(column: $table.familyId, builder: (column) => column);

  GeneratedColumn<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, String>, String>
      get discriminators => $composableBuilder(
          column: $table.discriminators, builder: (column) => column);

  GeneratedColumn<DateTime> get firstSeenAt => $composableBuilder(
      column: $table.firstSeenAt, builder: (column) => column);

  Expression<T> setEntriesRefs<T extends Object>(
      Expression<T> Function($$SetEntriesTableAnnotationComposer a) f) {
    final $$SetEntriesTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.slug,
        referencedTable: $db.setEntries,
        getReferencedColumn: (t) => t.exerciseSlug,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SetEntriesTableAnnotationComposer(
              $db: $db,
              $table: $db.setEntries,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ExerciseInstancesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ExerciseInstancesTable,
    ExerciseInstance,
    $$ExerciseInstancesTableFilterComposer,
    $$ExerciseInstancesTableOrderingComposer,
    $$ExerciseInstancesTableAnnotationComposer,
    $$ExerciseInstancesTableCreateCompanionBuilder,
    $$ExerciseInstancesTableUpdateCompanionBuilder,
    (ExerciseInstance, $$ExerciseInstancesTableReferences),
    ExerciseInstance,
    PrefetchHooks Function({bool setEntriesRefs})> {
  $$ExerciseInstancesTableTableManager(
      _$AppDatabase db, $ExerciseInstancesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ExerciseInstancesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ExerciseInstancesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ExerciseInstancesTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> slug = const Value.absent(),
            Value<String> familyId = const Value.absent(),
            Value<String> displayName = const Value.absent(),
            Value<Map<String, String>> discriminators = const Value.absent(),
            Value<DateTime> firstSeenAt = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ExerciseInstancesCompanion(
            slug: slug,
            familyId: familyId,
            displayName: displayName,
            discriminators: discriminators,
            firstSeenAt: firstSeenAt,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String slug,
            required String familyId,
            required String displayName,
            required Map<String, String> discriminators,
            required DateTime firstSeenAt,
            Value<int> rowid = const Value.absent(),
          }) =>
              ExerciseInstancesCompanion.insert(
            slug: slug,
            familyId: familyId,
            displayName: displayName,
            discriminators: discriminators,
            firstSeenAt: firstSeenAt,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ExerciseInstancesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({setEntriesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (setEntriesRefs) db.setEntries],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (setEntriesRefs)
                    await $_getPrefetchedData<ExerciseInstance,
                            $ExerciseInstancesTable, SetEntry>(
                        currentTable: table,
                        referencedTable: $$ExerciseInstancesTableReferences
                            ._setEntriesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ExerciseInstancesTableReferences(db, table, p0)
                                .setEntriesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.exerciseSlug == item.slug),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$ExerciseInstancesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ExerciseInstancesTable,
    ExerciseInstance,
    $$ExerciseInstancesTableFilterComposer,
    $$ExerciseInstancesTableOrderingComposer,
    $$ExerciseInstancesTableAnnotationComposer,
    $$ExerciseInstancesTableCreateCompanionBuilder,
    $$ExerciseInstancesTableUpdateCompanionBuilder,
    (ExerciseInstance, $$ExerciseInstancesTableReferences),
    ExerciseInstance,
    PrefetchHooks Function({bool setEntriesRefs})>;
typedef $$SetEntriesTableCreateCompanionBuilder = SetEntriesCompanion Function({
  required String id,
  required String sessionId,
  required String exerciseSlug,
  required int setOrder,
  required double weight,
  required int reps,
  Value<String?> setType,
  Value<int?> durationSeconds,
  Value<int?> distanceM,
  Value<int?> calories,
  Value<double?> rpe,
  Value<String?> metricsJson,
  Value<String?> prescriptionJson,
  required DateTime createdAt,
  required DateTime updatedAt,
  Value<int> rowid,
});
typedef $$SetEntriesTableUpdateCompanionBuilder = SetEntriesCompanion Function({
  Value<String> id,
  Value<String> sessionId,
  Value<String> exerciseSlug,
  Value<int> setOrder,
  Value<double> weight,
  Value<int> reps,
  Value<String?> setType,
  Value<int?> durationSeconds,
  Value<int?> distanceM,
  Value<int?> calories,
  Value<double?> rpe,
  Value<String?> metricsJson,
  Value<String?> prescriptionJson,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
  Value<int> rowid,
});

final class $$SetEntriesTableReferences
    extends BaseReferences<_$AppDatabase, $SetEntriesTable, SetEntry> {
  $$SetEntriesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $SessionsTable _sessionIdTable(_$AppDatabase db) =>
      db.sessions.createAlias(
          $_aliasNameGenerator(db.setEntries.sessionId, db.sessions.id));

  $$SessionsTableProcessedTableManager get sessionId {
    final $_column = $_itemColumn<String>('session_id')!;

    final manager = $$SessionsTableTableManager($_db, $_db.sessions)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_sessionIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $ExerciseInstancesTable _exerciseSlugTable(_$AppDatabase db) =>
      db.exerciseInstances.createAlias($_aliasNameGenerator(
          db.setEntries.exerciseSlug, db.exerciseInstances.slug));

  $$ExerciseInstancesTableProcessedTableManager get exerciseSlug {
    final $_column = $_itemColumn<String>('exercise_slug')!;

    final manager =
        $$ExerciseInstancesTableTableManager($_db, $_db.exerciseInstances)
            .filter((f) => f.slug.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_exerciseSlugTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$SetEntriesTableFilterComposer
    extends Composer<_$AppDatabase, $SetEntriesTable> {
  $$SetEntriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get setOrder => $composableBuilder(
      column: $table.setOrder, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get weight => $composableBuilder(
      column: $table.weight, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get reps => $composableBuilder(
      column: $table.reps, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get setType => $composableBuilder(
      column: $table.setType, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get durationSeconds => $composableBuilder(
      column: $table.durationSeconds,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get distanceM => $composableBuilder(
      column: $table.distanceM, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get calories => $composableBuilder(
      column: $table.calories, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get rpe => $composableBuilder(
      column: $table.rpe, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get metricsJson => $composableBuilder(
      column: $table.metricsJson, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get prescriptionJson => $composableBuilder(
      column: $table.prescriptionJson,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$SessionsTableFilterComposer get sessionId {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sessionId,
        referencedTable: $db.sessions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SessionsTableFilterComposer(
              $db: $db,
              $table: $db.sessions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ExerciseInstancesTableFilterComposer get exerciseSlug {
    final $$ExerciseInstancesTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.exerciseSlug,
        referencedTable: $db.exerciseInstances,
        getReferencedColumn: (t) => t.slug,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ExerciseInstancesTableFilterComposer(
              $db: $db,
              $table: $db.exerciseInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$SetEntriesTableOrderingComposer
    extends Composer<_$AppDatabase, $SetEntriesTable> {
  $$SetEntriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get setOrder => $composableBuilder(
      column: $table.setOrder, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get weight => $composableBuilder(
      column: $table.weight, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get reps => $composableBuilder(
      column: $table.reps, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get setType => $composableBuilder(
      column: $table.setType, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get durationSeconds => $composableBuilder(
      column: $table.durationSeconds,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get distanceM => $composableBuilder(
      column: $table.distanceM, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get calories => $composableBuilder(
      column: $table.calories, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get rpe => $composableBuilder(
      column: $table.rpe, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get metricsJson => $composableBuilder(
      column: $table.metricsJson, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get prescriptionJson => $composableBuilder(
      column: $table.prescriptionJson,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$SessionsTableOrderingComposer get sessionId {
    final $$SessionsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sessionId,
        referencedTable: $db.sessions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SessionsTableOrderingComposer(
              $db: $db,
              $table: $db.sessions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ExerciseInstancesTableOrderingComposer get exerciseSlug {
    final $$ExerciseInstancesTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.exerciseSlug,
        referencedTable: $db.exerciseInstances,
        getReferencedColumn: (t) => t.slug,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ExerciseInstancesTableOrderingComposer(
              $db: $db,
              $table: $db.exerciseInstances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$SetEntriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $SetEntriesTable> {
  $$SetEntriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get setOrder =>
      $composableBuilder(column: $table.setOrder, builder: (column) => column);

  GeneratedColumn<double> get weight =>
      $composableBuilder(column: $table.weight, builder: (column) => column);

  GeneratedColumn<int> get reps =>
      $composableBuilder(column: $table.reps, builder: (column) => column);

  GeneratedColumn<String> get setType =>
      $composableBuilder(column: $table.setType, builder: (column) => column);

  GeneratedColumn<int> get durationSeconds => $composableBuilder(
      column: $table.durationSeconds, builder: (column) => column);

  GeneratedColumn<int> get distanceM =>
      $composableBuilder(column: $table.distanceM, builder: (column) => column);

  GeneratedColumn<int> get calories =>
      $composableBuilder(column: $table.calories, builder: (column) => column);

  GeneratedColumn<double> get rpe =>
      $composableBuilder(column: $table.rpe, builder: (column) => column);

  GeneratedColumn<String> get metricsJson => $composableBuilder(
      column: $table.metricsJson, builder: (column) => column);

  GeneratedColumn<String> get prescriptionJson => $composableBuilder(
      column: $table.prescriptionJson, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$SessionsTableAnnotationComposer get sessionId {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sessionId,
        referencedTable: $db.sessions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SessionsTableAnnotationComposer(
              $db: $db,
              $table: $db.sessions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ExerciseInstancesTableAnnotationComposer get exerciseSlug {
    final $$ExerciseInstancesTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.exerciseSlug,
            referencedTable: $db.exerciseInstances,
            getReferencedColumn: (t) => t.slug,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ExerciseInstancesTableAnnotationComposer(
                  $db: $db,
                  $table: $db.exerciseInstances,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return composer;
  }
}

class $$SetEntriesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $SetEntriesTable,
    SetEntry,
    $$SetEntriesTableFilterComposer,
    $$SetEntriesTableOrderingComposer,
    $$SetEntriesTableAnnotationComposer,
    $$SetEntriesTableCreateCompanionBuilder,
    $$SetEntriesTableUpdateCompanionBuilder,
    (SetEntry, $$SetEntriesTableReferences),
    SetEntry,
    PrefetchHooks Function({bool sessionId, bool exerciseSlug})> {
  $$SetEntriesTableTableManager(_$AppDatabase db, $SetEntriesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SetEntriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SetEntriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SetEntriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<String> sessionId = const Value.absent(),
            Value<String> exerciseSlug = const Value.absent(),
            Value<int> setOrder = const Value.absent(),
            Value<double> weight = const Value.absent(),
            Value<int> reps = const Value.absent(),
            Value<String?> setType = const Value.absent(),
            Value<int?> durationSeconds = const Value.absent(),
            Value<int?> distanceM = const Value.absent(),
            Value<int?> calories = const Value.absent(),
            Value<double?> rpe = const Value.absent(),
            Value<String?> metricsJson = const Value.absent(),
            Value<String?> prescriptionJson = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              SetEntriesCompanion(
            id: id,
            sessionId: sessionId,
            exerciseSlug: exerciseSlug,
            setOrder: setOrder,
            weight: weight,
            reps: reps,
            setType: setType,
            durationSeconds: durationSeconds,
            distanceM: distanceM,
            calories: calories,
            rpe: rpe,
            metricsJson: metricsJson,
            prescriptionJson: prescriptionJson,
            createdAt: createdAt,
            updatedAt: updatedAt,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            required String sessionId,
            required String exerciseSlug,
            required int setOrder,
            required double weight,
            required int reps,
            Value<String?> setType = const Value.absent(),
            Value<int?> durationSeconds = const Value.absent(),
            Value<int?> distanceM = const Value.absent(),
            Value<int?> calories = const Value.absent(),
            Value<double?> rpe = const Value.absent(),
            Value<String?> metricsJson = const Value.absent(),
            Value<String?> prescriptionJson = const Value.absent(),
            required DateTime createdAt,
            required DateTime updatedAt,
            Value<int> rowid = const Value.absent(),
          }) =>
              SetEntriesCompanion.insert(
            id: id,
            sessionId: sessionId,
            exerciseSlug: exerciseSlug,
            setOrder: setOrder,
            weight: weight,
            reps: reps,
            setType: setType,
            durationSeconds: durationSeconds,
            distanceM: distanceM,
            calories: calories,
            rpe: rpe,
            metricsJson: metricsJson,
            prescriptionJson: prescriptionJson,
            createdAt: createdAt,
            updatedAt: updatedAt,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$SetEntriesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({sessionId = false, exerciseSlug = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (sessionId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.sessionId,
                    referencedTable:
                        $$SetEntriesTableReferences._sessionIdTable(db),
                    referencedColumn:
                        $$SetEntriesTableReferences._sessionIdTable(db).id,
                  ) as T;
                }
                if (exerciseSlug) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.exerciseSlug,
                    referencedTable:
                        $$SetEntriesTableReferences._exerciseSlugTable(db),
                    referencedColumn:
                        $$SetEntriesTableReferences._exerciseSlugTable(db).slug,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$SetEntriesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $SetEntriesTable,
    SetEntry,
    $$SetEntriesTableFilterComposer,
    $$SetEntriesTableOrderingComposer,
    $$SetEntriesTableAnnotationComposer,
    $$SetEntriesTableCreateCompanionBuilder,
    $$SetEntriesTableUpdateCompanionBuilder,
    (SetEntry, $$SetEntriesTableReferences),
    SetEntry,
    PrefetchHooks Function({bool sessionId, bool exerciseSlug})>;
typedef $$SavedWarmupsTableCreateCompanionBuilder = SavedWarmupsCompanion
    Function({
  required String id,
  required String sessionId,
  required String warmupId,
  required String displayName,
  required Map<String, String> parameters,
  required DateTime createdAt,
  Value<int> rowid,
});
typedef $$SavedWarmupsTableUpdateCompanionBuilder = SavedWarmupsCompanion
    Function({
  Value<String> id,
  Value<String> sessionId,
  Value<String> warmupId,
  Value<String> displayName,
  Value<Map<String, String>> parameters,
  Value<DateTime> createdAt,
  Value<int> rowid,
});

final class $$SavedWarmupsTableReferences
    extends BaseReferences<_$AppDatabase, $SavedWarmupsTable, SavedWarmup> {
  $$SavedWarmupsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $SessionsTable _sessionIdTable(_$AppDatabase db) =>
      db.sessions.createAlias(
          $_aliasNameGenerator(db.savedWarmups.sessionId, db.sessions.id));

  $$SessionsTableProcessedTableManager get sessionId {
    final $_column = $_itemColumn<String>('session_id')!;

    final manager = $$SessionsTableTableManager($_db, $_db.sessions)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_sessionIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$SavedWarmupsTableFilterComposer
    extends Composer<_$AppDatabase, $SavedWarmupsTable> {
  $$SavedWarmupsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get warmupId => $composableBuilder(
      column: $table.warmupId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnFilters(column));

  ColumnWithTypeConverterFilters<Map<String, String>, Map<String, String>,
          String>
      get parameters => $composableBuilder(
          column: $table.parameters,
          builder: (column) => ColumnWithTypeConverterFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  $$SessionsTableFilterComposer get sessionId {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sessionId,
        referencedTable: $db.sessions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SessionsTableFilterComposer(
              $db: $db,
              $table: $db.sessions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$SavedWarmupsTableOrderingComposer
    extends Composer<_$AppDatabase, $SavedWarmupsTable> {
  $$SavedWarmupsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get warmupId => $composableBuilder(
      column: $table.warmupId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get parameters => $composableBuilder(
      column: $table.parameters, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  $$SessionsTableOrderingComposer get sessionId {
    final $$SessionsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sessionId,
        referencedTable: $db.sessions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SessionsTableOrderingComposer(
              $db: $db,
              $table: $db.sessions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$SavedWarmupsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SavedWarmupsTable> {
  $$SavedWarmupsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get warmupId =>
      $composableBuilder(column: $table.warmupId, builder: (column) => column);

  GeneratedColumn<String> get displayName => $composableBuilder(
      column: $table.displayName, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, String>, String>
      get parameters => $composableBuilder(
          column: $table.parameters, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$SessionsTableAnnotationComposer get sessionId {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sessionId,
        referencedTable: $db.sessions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SessionsTableAnnotationComposer(
              $db: $db,
              $table: $db.sessions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$SavedWarmupsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $SavedWarmupsTable,
    SavedWarmup,
    $$SavedWarmupsTableFilterComposer,
    $$SavedWarmupsTableOrderingComposer,
    $$SavedWarmupsTableAnnotationComposer,
    $$SavedWarmupsTableCreateCompanionBuilder,
    $$SavedWarmupsTableUpdateCompanionBuilder,
    (SavedWarmup, $$SavedWarmupsTableReferences),
    SavedWarmup,
    PrefetchHooks Function({bool sessionId})> {
  $$SavedWarmupsTableTableManager(_$AppDatabase db, $SavedWarmupsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SavedWarmupsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SavedWarmupsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SavedWarmupsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<String> sessionId = const Value.absent(),
            Value<String> warmupId = const Value.absent(),
            Value<String> displayName = const Value.absent(),
            Value<Map<String, String>> parameters = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              SavedWarmupsCompanion(
            id: id,
            sessionId: sessionId,
            warmupId: warmupId,
            displayName: displayName,
            parameters: parameters,
            createdAt: createdAt,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            required String sessionId,
            required String warmupId,
            required String displayName,
            required Map<String, String> parameters,
            required DateTime createdAt,
            Value<int> rowid = const Value.absent(),
          }) =>
              SavedWarmupsCompanion.insert(
            id: id,
            sessionId: sessionId,
            warmupId: warmupId,
            displayName: displayName,
            parameters: parameters,
            createdAt: createdAt,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$SavedWarmupsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({sessionId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (sessionId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.sessionId,
                    referencedTable:
                        $$SavedWarmupsTableReferences._sessionIdTable(db),
                    referencedColumn:
                        $$SavedWarmupsTableReferences._sessionIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$SavedWarmupsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $SavedWarmupsTable,
    SavedWarmup,
    $$SavedWarmupsTableFilterComposer,
    $$SavedWarmupsTableOrderingComposer,
    $$SavedWarmupsTableAnnotationComposer,
    $$SavedWarmupsTableCreateCompanionBuilder,
    $$SavedWarmupsTableUpdateCompanionBuilder,
    (SavedWarmup, $$SavedWarmupsTableReferences),
    SavedWarmup,
    PrefetchHooks Function({bool sessionId})>;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$SessionsTableTableManager get sessions =>
      $$SessionsTableTableManager(_db, _db.sessions);
  $$ExerciseInstancesTableTableManager get exerciseInstances =>
      $$ExerciseInstancesTableTableManager(_db, _db.exerciseInstances);
  $$SetEntriesTableTableManager get setEntries =>
      $$SetEntriesTableTableManager(_db, _db.setEntries);
  $$SavedWarmupsTableTableManager get savedWarmups =>
      $$SavedWarmupsTableTableManager(_db, _db.savedWarmups);
}
----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\application\dxg_state.dart ----- 
// ----- lib/src/features/dxg/application/dxg_state.dart -----
// lib/src/features/dxg/application/dxg_state.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'dart:convert';
import 'package:flutter/services.dart' show rootBundle;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:collection/collection.dart';
import 'package:fairware_lift/src/features/dxg/domain/movement_family.dart';
import 'package:fairware_lift/src/features/dxg/application/guardrail_service.dart';
import 'package:fairware_lift/src/features/dxg/application/name_slug_service.dart';

part 'dxg_state.freezed.dart';

// -----------------------------------------------------------------------------
// --- HELPER DATA CLASSES -----------------------------------------------------
// -----------------------------------------------------------------------------

/// A simple data class to hold the result of a generated exercise.
@freezed
class GeneratedExerciseResult with _$GeneratedExerciseResult {
  const factory GeneratedExerciseResult({
    required String displayName,
    required String slug,
    required SelectionsMap discriminators,
    required String familyId,
  }) = _GeneratedExerciseResult;
}

/// The immutable state object for the DXG exercise picker.
@freezed
class DXGState with _$DXGState {
  const DXGState._();

  const factory DXGState({
    /// The master list of all families, loaded once from the seed JSON.
    required List<MovementFamily> allFamilies,

    /// The user's currently selected family ID.
    String? selectedFamilyId,

    /// The user's currently selected discriminator values.
    @Default({}) SelectionsMap selections,

    /// The calculated set of valid options for each discriminator field.
    @Default({}) CandidateOptions availableOptions,

    /// The final, generated canonical exercise if all required fields are selected.
    GeneratedExerciseResult? canonicalExercise,
  }) = _DXGState;

  /// A computed property to easily access the full MovementFamily object.
  MovementFamily? get selectedFamily => allFamilies
      .firstWhereOrNull((family) => family.id == selectedFamilyId);
}

// -----------------------------------------------------------------------------
// --- STATE NOTIFIER ----------------------------------------------------------
// -----------------------------------------------------------------------------

class DXGStateNotifier extends AutoDisposeAsyncNotifier<DXGState> {
  @override
  Future<DXGState> build() async {
    // This method is called once to provide the initial state.
    // We load the seed data from the JSON asset here.
    final families = await _loadMovementFamilies();
    return DXGState(allFamilies: families);
  }

  /// Loads and parses the `movement_families.seed.json` file from assets.
  Future<List<MovementFamily>> _loadMovementFamilies() async {
    final jsonString =
        await rootBundle.loadString('assets/dxg/movement_families.seed.json');
    final jsonResponse = json.decode(jsonString) as Map<String, dynamic>;
    final familiesList = jsonResponse['movement_families'] as List;
    return familiesList
        .map((familyJson) =>
            MovementFamily.fromJson(familyJson as Map<String, dynamic>))
        .toList();
  }

  /// Updates the state when the user selects a movement family.
  void selectFamily(String familyId) {
    final currentState = state.value;
    if (currentState == null) return;

    final newFamily = currentState.allFamilies
        .firstWhereOrNull((f) => f.id == familyId);
    if (newFamily == null) return;

    // When a new family is selected, reset all discriminator selections.
    final newSelections = <String, String>{};
    state = AsyncData(_recalculateState(
      currentState.copyWith(
        selectedFamilyId: familyId,
        selections: newSelections,
      ),
    ));
  }

  /// Updates the state when the user selects or deselects a discriminator value.
  void updateSelection(String field, String? value) {
    final currentState = state.value;
    if (currentState == null || currentState.selectedFamily == null) return;

    final newSelections = Map<String, String>.from(currentState.selections);
    if (value == null) {
      // If value is null, deselect this discriminator.
      newSelections.remove(field);
    } else {
      // Otherwise, update the selection.
      newSelections[field] = value;
    }

    state = AsyncData(_recalculateState(
      currentState.copyWith(selections: newSelections),
    ));
  }

  /// A central method to recalculate all derived state.
  DXGState _recalculateState(DXGState newState) {
    final guardrailService = ref.read(guardrailServiceProvider);
    final nameSlugService = ref.read(nameAndSlugServiceProvider);

    final family = newState.selectedFamily;
    if (family == null) {
      // If no family is selected, there are no options or results.
      return newState.copyWith(
        availableOptions: {},
        canonicalExercise: null,
      );
    }

    // 1. Calculate the currently available options using the GuardrailService.
    final availableOptions = guardrailService.getCandidateOptions(
      family: family,
      selections: newState.selections,
    );

    // --- BUG FIX ---
    // The logic to determine if a canonical exercise can be generated is now
    // more robust. Instead of relying on the display template, it checks if
    // a selection has been made for every available (i.e., visible)
    // discriminator category.
    bool hasAllRequiredFields = true;
    for (final entry in availableOptions.entries) {
      final field = entry.key;
      final options = entry.value;

      // A field is considered required if it has options available to choose from.
      // We ignore fields that only contain 'none'.
      final bool isEffectivelyEmpty = options.isEmpty || (options.length == 1 && options.first == 'none');

      if (!isEffectivelyEmpty && !newState.selections.containsKey(field)) {
        hasAllRequiredFields = false;
        break;
      }
    }

    GeneratedExerciseResult? canonicalExercise;
    if (hasAllRequiredFields) {
      // 3. If so, generate the name and slug using the NameAndSlugService.
      final displayName = nameSlugService.toDisplayName(
        family: family,
        discriminators: newState.selections,
      );
      final slug = nameSlugService.toSlug(
        familyId: family.id,
        discriminators: newState.selections,
      );
      canonicalExercise = GeneratedExerciseResult(
        displayName: displayName,
        slug: slug,
        discriminators: newState.selections,
        familyId: family.id,
      );
    }

    return newState.copyWith(
      availableOptions: availableOptions,
      canonicalExercise: canonicalExercise,
    );
  }
}

// -----------------------------------------------------------------------------
// --- PROVIDER ----------------------------------------------------------------
// -----------------------------------------------------------------------------

// The provider is an `AutoDisposeAsyncNotifierProvider`. This ensures that
// when the exercise picker screen is closed (and no longer being listened to),
// the state is automatically destroyed. The next time the user opens the
// picker, a fresh instance of the notifier will be created.
final dxgStateProvider =
    AutoDisposeAsyncNotifierProvider<DXGStateNotifier, DXGState>(
        DXGStateNotifier.new);----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\application\dxg_state.freezed.dart ----- 
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'dxg_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$GeneratedExerciseResult {
  String get displayName => throw _privateConstructorUsedError;
  String get slug => throw _privateConstructorUsedError;
  Map<String, String> get discriminators => throw _privateConstructorUsedError;
  String get familyId => throw _privateConstructorUsedError;

  /// Create a copy of GeneratedExerciseResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GeneratedExerciseResultCopyWith<GeneratedExerciseResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GeneratedExerciseResultCopyWith<$Res> {
  factory $GeneratedExerciseResultCopyWith(GeneratedExerciseResult value,
          $Res Function(GeneratedExerciseResult) then) =
      _$GeneratedExerciseResultCopyWithImpl<$Res, GeneratedExerciseResult>;
  @useResult
  $Res call(
      {String displayName,
      String slug,
      Map<String, String> discriminators,
      String familyId});
}

/// @nodoc
class _$GeneratedExerciseResultCopyWithImpl<$Res,
        $Val extends GeneratedExerciseResult>
    implements $GeneratedExerciseResultCopyWith<$Res> {
  _$GeneratedExerciseResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GeneratedExerciseResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? displayName = null,
    Object? slug = null,
    Object? discriminators = null,
    Object? familyId = null,
  }) {
    return _then(_value.copyWith(
      displayName: null == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      slug: null == slug
          ? _value.slug
          : slug // ignore: cast_nullable_to_non_nullable
              as String,
      discriminators: null == discriminators
          ? _value.discriminators
          : discriminators // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      familyId: null == familyId
          ? _value.familyId
          : familyId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GeneratedExerciseResultImplCopyWith<$Res>
    implements $GeneratedExerciseResultCopyWith<$Res> {
  factory _$$GeneratedExerciseResultImplCopyWith(
          _$GeneratedExerciseResultImpl value,
          $Res Function(_$GeneratedExerciseResultImpl) then) =
      __$$GeneratedExerciseResultImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String displayName,
      String slug,
      Map<String, String> discriminators,
      String familyId});
}

/// @nodoc
class __$$GeneratedExerciseResultImplCopyWithImpl<$Res>
    extends _$GeneratedExerciseResultCopyWithImpl<$Res,
        _$GeneratedExerciseResultImpl>
    implements _$$GeneratedExerciseResultImplCopyWith<$Res> {
  __$$GeneratedExerciseResultImplCopyWithImpl(
      _$GeneratedExerciseResultImpl _value,
      $Res Function(_$GeneratedExerciseResultImpl) _then)
      : super(_value, _then);

  /// Create a copy of GeneratedExerciseResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? displayName = null,
    Object? slug = null,
    Object? discriminators = null,
    Object? familyId = null,
  }) {
    return _then(_$GeneratedExerciseResultImpl(
      displayName: null == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      slug: null == slug
          ? _value.slug
          : slug // ignore: cast_nullable_to_non_nullable
              as String,
      discriminators: null == discriminators
          ? _value._discriminators
          : discriminators // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      familyId: null == familyId
          ? _value.familyId
          : familyId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$GeneratedExerciseResultImpl implements _GeneratedExerciseResult {
  const _$GeneratedExerciseResultImpl(
      {required this.displayName,
      required this.slug,
      required final Map<String, String> discriminators,
      required this.familyId})
      : _discriminators = discriminators;

  @override
  final String displayName;
  @override
  final String slug;
  final Map<String, String> _discriminators;
  @override
  Map<String, String> get discriminators {
    if (_discriminators is EqualUnmodifiableMapView) return _discriminators;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_discriminators);
  }

  @override
  final String familyId;

  @override
  String toString() {
    return 'GeneratedExerciseResult(displayName: $displayName, slug: $slug, discriminators: $discriminators, familyId: $familyId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GeneratedExerciseResultImpl &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.slug, slug) || other.slug == slug) &&
            const DeepCollectionEquality()
                .equals(other._discriminators, _discriminators) &&
            (identical(other.familyId, familyId) ||
                other.familyId == familyId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, displayName, slug,
      const DeepCollectionEquality().hash(_discriminators), familyId);

  /// Create a copy of GeneratedExerciseResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GeneratedExerciseResultImplCopyWith<_$GeneratedExerciseResultImpl>
      get copyWith => __$$GeneratedExerciseResultImplCopyWithImpl<
          _$GeneratedExerciseResultImpl>(this, _$identity);
}

abstract class _GeneratedExerciseResult implements GeneratedExerciseResult {
  const factory _GeneratedExerciseResult(
      {required final String displayName,
      required final String slug,
      required final Map<String, String> discriminators,
      required final String familyId}) = _$GeneratedExerciseResultImpl;

  @override
  String get displayName;
  @override
  String get slug;
  @override
  Map<String, String> get discriminators;
  @override
  String get familyId;

  /// Create a copy of GeneratedExerciseResult
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GeneratedExerciseResultImplCopyWith<_$GeneratedExerciseResultImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DXGState {
  /// The master list of all families, loaded once from the seed JSON.
  List<MovementFamily> get allFamilies => throw _privateConstructorUsedError;

  /// The user's currently selected family ID.
  String? get selectedFamilyId => throw _privateConstructorUsedError;

  /// The user's currently selected discriminator values.
  Map<String, String> get selections => throw _privateConstructorUsedError;

  /// The calculated set of valid options for each discriminator field.
  Map<String, Set<String>> get availableOptions =>
      throw _privateConstructorUsedError;

  /// The final, generated canonical exercise if all required fields are selected.
  GeneratedExerciseResult? get canonicalExercise =>
      throw _privateConstructorUsedError;

  /// Create a copy of DXGState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DXGStateCopyWith<DXGState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DXGStateCopyWith<$Res> {
  factory $DXGStateCopyWith(DXGState value, $Res Function(DXGState) then) =
      _$DXGStateCopyWithImpl<$Res, DXGState>;
  @useResult
  $Res call(
      {List<MovementFamily> allFamilies,
      String? selectedFamilyId,
      Map<String, String> selections,
      Map<String, Set<String>> availableOptions,
      GeneratedExerciseResult? canonicalExercise});

  $GeneratedExerciseResultCopyWith<$Res>? get canonicalExercise;
}

/// @nodoc
class _$DXGStateCopyWithImpl<$Res, $Val extends DXGState>
    implements $DXGStateCopyWith<$Res> {
  _$DXGStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DXGState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allFamilies = null,
    Object? selectedFamilyId = freezed,
    Object? selections = null,
    Object? availableOptions = null,
    Object? canonicalExercise = freezed,
  }) {
    return _then(_value.copyWith(
      allFamilies: null == allFamilies
          ? _value.allFamilies
          : allFamilies // ignore: cast_nullable_to_non_nullable
              as List<MovementFamily>,
      selectedFamilyId: freezed == selectedFamilyId
          ? _value.selectedFamilyId
          : selectedFamilyId // ignore: cast_nullable_to_non_nullable
              as String?,
      selections: null == selections
          ? _value.selections
          : selections // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      availableOptions: null == availableOptions
          ? _value.availableOptions
          : availableOptions // ignore: cast_nullable_to_non_nullable
              as Map<String, Set<String>>,
      canonicalExercise: freezed == canonicalExercise
          ? _value.canonicalExercise
          : canonicalExercise // ignore: cast_nullable_to_non_nullable
              as GeneratedExerciseResult?,
    ) as $Val);
  }

  /// Create a copy of DXGState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GeneratedExerciseResultCopyWith<$Res>? get canonicalExercise {
    if (_value.canonicalExercise == null) {
      return null;
    }

    return $GeneratedExerciseResultCopyWith<$Res>(_value.canonicalExercise!,
        (value) {
      return _then(_value.copyWith(canonicalExercise: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$DXGStateImplCopyWith<$Res>
    implements $DXGStateCopyWith<$Res> {
  factory _$$DXGStateImplCopyWith(
          _$DXGStateImpl value, $Res Function(_$DXGStateImpl) then) =
      __$$DXGStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<MovementFamily> allFamilies,
      String? selectedFamilyId,
      Map<String, String> selections,
      Map<String, Set<String>> availableOptions,
      GeneratedExerciseResult? canonicalExercise});

  @override
  $GeneratedExerciseResultCopyWith<$Res>? get canonicalExercise;
}

/// @nodoc
class __$$DXGStateImplCopyWithImpl<$Res>
    extends _$DXGStateCopyWithImpl<$Res, _$DXGStateImpl>
    implements _$$DXGStateImplCopyWith<$Res> {
  __$$DXGStateImplCopyWithImpl(
      _$DXGStateImpl _value, $Res Function(_$DXGStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of DXGState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allFamilies = null,
    Object? selectedFamilyId = freezed,
    Object? selections = null,
    Object? availableOptions = null,
    Object? canonicalExercise = freezed,
  }) {
    return _then(_$DXGStateImpl(
      allFamilies: null == allFamilies
          ? _value._allFamilies
          : allFamilies // ignore: cast_nullable_to_non_nullable
              as List<MovementFamily>,
      selectedFamilyId: freezed == selectedFamilyId
          ? _value.selectedFamilyId
          : selectedFamilyId // ignore: cast_nullable_to_non_nullable
              as String?,
      selections: null == selections
          ? _value._selections
          : selections // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      availableOptions: null == availableOptions
          ? _value._availableOptions
          : availableOptions // ignore: cast_nullable_to_non_nullable
              as Map<String, Set<String>>,
      canonicalExercise: freezed == canonicalExercise
          ? _value.canonicalExercise
          : canonicalExercise // ignore: cast_nullable_to_non_nullable
              as GeneratedExerciseResult?,
    ));
  }
}

/// @nodoc

class _$DXGStateImpl extends _DXGState {
  const _$DXGStateImpl(
      {required final List<MovementFamily> allFamilies,
      this.selectedFamilyId,
      final Map<String, String> selections = const {},
      final Map<String, Set<String>> availableOptions = const {},
      this.canonicalExercise})
      : _allFamilies = allFamilies,
        _selections = selections,
        _availableOptions = availableOptions,
        super._();

  /// The master list of all families, loaded once from the seed JSON.
  final List<MovementFamily> _allFamilies;

  /// The master list of all families, loaded once from the seed JSON.
  @override
  List<MovementFamily> get allFamilies {
    if (_allFamilies is EqualUnmodifiableListView) return _allFamilies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_allFamilies);
  }

  /// The user's currently selected family ID.
  @override
  final String? selectedFamilyId;

  /// The user's currently selected discriminator values.
  final Map<String, String> _selections;

  /// The user's currently selected discriminator values.
  @override
  @JsonKey()
  Map<String, String> get selections {
    if (_selections is EqualUnmodifiableMapView) return _selections;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_selections);
  }

  /// The calculated set of valid options for each discriminator field.
  final Map<String, Set<String>> _availableOptions;

  /// The calculated set of valid options for each discriminator field.
  @override
  @JsonKey()
  Map<String, Set<String>> get availableOptions {
    if (_availableOptions is EqualUnmodifiableMapView) return _availableOptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_availableOptions);
  }

  /// The final, generated canonical exercise if all required fields are selected.
  @override
  final GeneratedExerciseResult? canonicalExercise;

  @override
  String toString() {
    return 'DXGState(allFamilies: $allFamilies, selectedFamilyId: $selectedFamilyId, selections: $selections, availableOptions: $availableOptions, canonicalExercise: $canonicalExercise)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DXGStateImpl &&
            const DeepCollectionEquality()
                .equals(other._allFamilies, _allFamilies) &&
            (identical(other.selectedFamilyId, selectedFamilyId) ||
                other.selectedFamilyId == selectedFamilyId) &&
            const DeepCollectionEquality()
                .equals(other._selections, _selections) &&
            const DeepCollectionEquality()
                .equals(other._availableOptions, _availableOptions) &&
            (identical(other.canonicalExercise, canonicalExercise) ||
                other.canonicalExercise == canonicalExercise));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_allFamilies),
      selectedFamilyId,
      const DeepCollectionEquality().hash(_selections),
      const DeepCollectionEquality().hash(_availableOptions),
      canonicalExercise);

  /// Create a copy of DXGState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DXGStateImplCopyWith<_$DXGStateImpl> get copyWith =>
      __$$DXGStateImplCopyWithImpl<_$DXGStateImpl>(this, _$identity);
}

abstract class _DXGState extends DXGState {
  const factory _DXGState(
      {required final List<MovementFamily> allFamilies,
      final String? selectedFamilyId,
      final Map<String, String> selections,
      final Map<String, Set<String>> availableOptions,
      final GeneratedExerciseResult? canonicalExercise}) = _$DXGStateImpl;
  const _DXGState._() : super._();

  /// The master list of all families, loaded once from the seed JSON.
  @override
  List<MovementFamily> get allFamilies;

  /// The user's currently selected family ID.
  @override
  String? get selectedFamilyId;

  /// The user's currently selected discriminator values.
  @override
  Map<String, String> get selections;

  /// The calculated set of valid options for each discriminator field.
  @override
  Map<String, Set<String>> get availableOptions;

  /// The final, generated canonical exercise if all required fields are selected.
  @override
  GeneratedExerciseResult? get canonicalExercise;

  /// Create a copy of DXGState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DXGStateImplCopyWith<_$DXGStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\application\guardrail_service.dart ----- 
// ----- lib/src/features/dxg/application/guardrail_service.dart -----
// lib/src/features/dxg/application/guardrail_service.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/features/dxg/domain/movement_family.dart';

// -----------------------------------------------------------------------------
// --- CONFIGURATION & DATA CLASSES --------------------------------------------
// -----------------------------------------------------------------------------

/// A simple record to hold the result of a validation check, as specified
/// in the DXG document.
typedef ValidationResult = ({bool isValid, String? reason});

/// A type alias for the map of currently selected discriminators.
/// e.g., {'equipment': 'dumbbell', 'angle': 'incline'}
typedef SelectionsMap = Map<String, String>;

/// A type alias for the result of getCandidateOptions. It maps a discriminator
/// field to a set of valid string options.
/// e.g., {'attachment': {'none', 'straight_bar', 'ez_bar'}}
typedef CandidateOptions = Map<String, Set<String>>;

// -----------------------------------------------------------------------------
// --- GUARDRAIL SERVICE -------------------------------------------------------
// -----------------------------------------------------------------------------
// This service implements the "Guardrail Engine" from the DXG specification.
// Its primary role is to determine the valid set of discriminator options
// based on a movement family's rules and the user's current selections.
// -----------------------------------------------------------------------------

class GuardrailService {
  /// Computes the available, valid options for all discriminator fields.
  CandidateOptions getCandidateOptions({
    required MovementFamily family,
    required SelectionsMap selections,
  }) {
    final allowed = family.allowed;
    final denials = family.denies;

    // Helper to compute candidates for a single field, considering denials.
    Set<String> _getOptionsForField(
      List<String> allowedValues,
      String currentField,
    ) {
      final options = Set<String>.from(allowedValues);
      final denialsToRemove = <String>{};

      for (final rule in denials) {
        bool ruleMatches = true;
        if (rule.equipment != null &&
            selections['equipment'] != rule.equipment) {
          ruleMatches = false;
        }

        if (ruleMatches) {
          if (currentField == 'attachment' && rule.attachment != null) {
            denialsToRemove.addAll(rule.attachment!);
          }
        }
      }
      options.removeAll(denialsToRemove);
      return options;
    }

    // Attachments are only relevant for cable exercises. This logic now
    // checks the selected equipment. If it's not 'cable', the attachment
    // options will be an empty set, preventing the UI from showing the section.
    final attachmentOptions = (selections['equipment'] == 'cable')
        ? _getOptionsForField(allowed.attachment, 'attachment')
        : <String>{};

    // --- NEW ---
    // Cable height is only relevant for cable exercises.
    final cableHeightOptions = (selections['equipment'] == 'cable')
        ? Set<String>.from(allowed.cable_height)
        : <String>{};

    return {
      'equipment': Set<String>.from(allowed.equipment),
      'angle': Set<String>.from(allowed.angle),
      'unilateral': Set<String>.from(allowed.unilateral),
      'orientation': Set<String>.from(allowed.orientation),
      'attachment': attachmentOptions,
      'cable_height': cableHeightOptions,
      'grip': Set<String>.from(allowed.grip),
    };
  }

  /// Validates the user's complete set of selections against the family's rules.
  ValidationResult validateSelection({
    required MovementFamily family,
    required SelectionsMap selections,
  }) {
    final candidates = getCandidateOptions(family: family, selections: selections);

    for (final entry in selections.entries) {
      final field = entry.key;
      final selectedValue = entry.value;
      final validOptions = candidates[field];

      if (validOptions == null || !validOptions.contains(selectedValue)) {
        return (
          isValid: false,
          reason:
              "'$selectedValue' is not a valid option for '$field' with the current selections."
        );
      }
    }
    return (isValid: true, reason: null);
  }
}

// -----------------------------------------------------------------------------
// --- PROVIDER ----------------------------------------------------------------
// -----------------------------------------------------------------------------

/// A Riverpod provider to make a singleton instance of the GuardrailService
/// available to the rest of the application.
final guardrailServiceProvider = Provider<GuardrailService>((ref) {
  return GuardrailService();
});----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\application\name_slug_service.dart ----- 
// lib/src/features/dxg/application/name_slug_service.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/features/dxg/domain/movement_family.dart';
import 'package:fairware_lift/src/features/dxg/application/guardrail_service.dart';
import 'package:fairware_lift/src/features/dxg/application/dxg_state.dart'; // To access allFamilies

// -----------------------------------------------------------------------------
// --- NAME & SLUG SERVICE -----------------------------------------------------
// -----------------------------------------------------------------------------

class NameAndSlugService {
  // --- NEW ---
  // The service now requires a reference to the list of movement families.
  final List<MovementFamily> _families;
  NameAndSlugService(this._families);

  /// --- NEW METHOD ---
  /// Finds a movement family by its name or one of its aliases.
  /// This is the core of the "hybrid normalization" step.
  MovementFamily? findFamilyByNameOrAlias(String name) {
    final lowerCaseName = name.toLowerCase();
    for (final family in _families) {
      if (family.name.toLowerCase() == lowerCaseName) {
        return family;
      }
      for (final alias in family.aliases) {
        if (alias.toLowerCase() == lowerCaseName) {
          return family;
        }
      }
    }
    return null; // Return null if no match is found
  }

  String toSlug({
    required String familyId,
    required SelectionsMap discriminators,
  }) {
    const fieldsInOrder = [
      'equipment',
      'angle',
      'unilateral',
      'orientation',
      'attachment',
      'cable_height',
      'grip',
    ];

    final slugParts = [familyId];
    for (final field in fieldsInOrder) {
      if (discriminators.containsKey(field)) {
        slugParts.add(discriminators[field]!);
      }
    }
    return slugParts.join('.');
  }

  String toDisplayName({
    required MovementFamily family,
    required SelectionsMap discriminators,
  }) {
    String template = family.display_name_template;
    for (final rule in family.naming_rules) {
      if (_doesRuleApply(rule.ifCondition, discriminators)) {
        template = rule.name;
        break;
      }
    }

    String result =
        template.replaceAll('{{familyName}}', family.name.split(' ')[0]);

    final tokenRegex = RegExp(r'\{\{(\w+)(\??)(_paren\??)?\}\}');
    result = result.replaceAllMapped(tokenRegex, (match) {
      final field = match.group(1)!;
      final isParenthesized = match.group(3) != null;
      final value = discriminators[field];

      if (value != null) {
        final humanized = _humanize(field, value);
        return isParenthesized ? ' ($humanized)' : humanized;
      }
      return '';
    });

    if (family.id == 'row' || family.id == 'fly') {
      if (discriminators['unilateral'] == 'unilateral') {
        result += ', 1-Arm';
      }
    }

    return result.replaceAll(RegExp(r'\\s+'), ' ').trim();
  }

  bool _doesRuleApply(Map<String, String> condition, SelectionsMap selections) {
    return condition.entries.every((entry) {
      return selections[entry.key] == entry.value;
    });
  }

  String _humanize(String field, String value) {
    if (field == 'cable_height') {
      return 'Pos: $value';
    }

    const humanizationMap = {
      'ez_bar': 'EZ Bar',
      'v_bar': 'V-Bar',
      'd_handle': 'D-Handle',
      'lat_bar': 'Lat Bar',
      'single_d_handle': 'Single D-Handle',
      'straight_bar': 'Straight Bar',
      'seated_cable': 'Seated Cable',
      'incline_bench': 'Incline Bench',
      'bulgarian_split': 'Bulgarian Split',
      'trapbar': 'Trap Bar',
      'hip_hinge_setup': 'Bent-Over',
    };

    if (humanizationMap.containsKey(value)) {
      return humanizationMap[value]!;
    }

    final words = value.split('_');
    return words.map((w) => '${w[0].toUpperCase()}${w.substring(1)}').join(' ');
  }
}

// -----------------------------------------------------------------------------
// --- PROVIDER ----------------------------------------------------------------
// -----------------------------------------------------------------------------

final nameAndSlugServiceProvider = Provider<NameAndSlugService>((ref) {
  // The provider now depends on the dxgStateProvider to get the list of families.
  // This ensures that the service is always initialized with the necessary data.
  final families = ref.watch(dxgStateProvider).value?.allFamilies ?? [];
  return NameAndSlugService(families);
});----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\application\warmup_service.dart ----- 
// lib/src/features/dxg/application/warmup_service.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'dart:convert';
import 'package:flutter/services.dart' show rootBundle;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/features/dxg/domain/warmup_item.dart';

// -----------------------------------------------------------------------------
// --- WARMUP SERVICE ----------------------------------------------------------
// -----------------------------------------------------------------------------
// This service is responsible for loading the catalog of warm-up items from
// the seed JSON file.
// -----------------------------------------------------------------------------

class WarmupService {
  /// Loads and parses the `warmup_items.seed.json` file from assets.
  Future<List<WarmupItem>> loadWarmupItems() async {
    final jsonString =
        await rootBundle.loadString('assets/dxg/warmup_items.seed.json');
    final jsonResponse = json.decode(jsonString) as Map<String, dynamic>;
    final itemsList = jsonResponse['warmup_items'] as List;
    return itemsList
        .map((itemJson) =>
            WarmupItem.fromJson(itemJson as Map<String, dynamic>))
        .toList();
  }
}

// -----------------------------------------------------------------------------
// --- PROVIDER ----------------------------------------------------------------
// -----------------------------------------------------------------------------

/// A provider for the WarmupService itself.
final warmupServiceProvider = Provider<WarmupService>((ref) {
  return WarmupService();
});

/// A FutureProvider that loads the list of warm-up items and makes it available
/// to the UI. The list is loaded once and then cached.
final warmupItemsProvider = FutureProvider<List<WarmupItem>>((ref) {
  return ref.watch(warmupServiceProvider).loadWarmupItems();
});----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\domain\dxg_enums.dart ----- 
// lib/src/features/dxg/domain/dxg_enums.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

// No longer need freezed_annotation here as the incorrect annotation is removed.

// -----------------------------------------------------------------------------
// --- ENUM DEFINITIONS FOR DXG ------------------------------------------------
// -----------------------------------------------------------------------------
// These enums represent the bounded lists of discriminators that define a
// canonical exercise. Using enums provides type safety and prevents typos.
//
// --- FIX ---
// The `@JsonEnum` annotations have been removed. The default behavior of
// `json_serializable` correctly maps the enum value names (e.g., `push`) to
// the strings in the JSON file.
// -----------------------------------------------------------------------------

/// The fundamental type of movement.
enum MovementPattern {
  push,
  pull,
  squat,
  hinge,
  lunge,
  carry,
  rotate,
  // ignore: constant_identifier_names
  anti_rotate,
  gait,
  isolation,
}

/// The type of equipment used for the exercise.
enum Equipment {
  barbell,
  dumbbell,
  machine,
  cable,
  band,
  bodyweight,
  kettlebell,
  landmine,
  trx,
  plate,
  smith,
  trapbar,
  // This is a special value from the synonyms map.
  // ignore: constant_identifier_names
  farmer_handles,
  // Added from ez_bar in allowed lists, not in main enum list in spec.
  // ignore: constant_identifier_names
  ez_bar,
}

/// The angle or line of pull/press for the movement.
enum Angle {
  // Press & Fly
  flat,
  incline,
  decline,
  overhead,
  // Row & Cable
  // ignore: constant_identifier_names
  low_to_high,
  // ignore: constant_identifier_names
  high_to_low,
  horizontal,
  vertical,
  // ignore: constant_identifier_names
  chest_supported,
  // ignore: constant_identifier_names
  seated_cable,
  // Squat variants
  back,
  front,
  goblet,
  hack,
  zercher,
  // Hinge variants
  conventional,
  sumo,
  romanian,
  // ignore: constant_identifier_names
  stiff_leg,
  // ignore: constant_identifier_names
  rack_pull,
  // Lunge variants
  forward,
  reverse,
  walking,
  // ignore: constant_identifier_names
  split_squat,
  // ignore: constant_identifier_names
  bulgarian_split,
  // Carry variants
  farmer,
  suitcase,
  // ignore: constant_identifier_names
  front_rack,
  // Rotation variants
  // ignore: constant_identifier_names
  anti_rotation,
  rotation,
  chop,
  lift,
  // Calf variants
  standing,
  seated,
  donkey,
  // Curl variants (re-using existing enums)
  // standing, seated,
  // ignore: constant_identifier_names
  incline_bench,

  // --- NEW: Shoulder Raise Variants ---
  lateral,
  // ignore: constant_identifier_names
  front_raise,
  // ignore: constant_identifier_names
  rear_delt_raise,
}

/// Whether the movement is performed with one or two limbs.
enum Unilateral {
  bilateral,
  unilateral,
}

/// The user's body orientation during the exercise.
enum BodyOrientation {
  standing,
  seated,
  supine,
  prone,
  // ignore: constant_identifier_names
  half_kneel,
  // ignore: constant_identifier_names
  tall_kneel,
  // ignore: constant_identifier_names
  side_lying,
  // ignore: constant_identifier_names
  chest_supported,
  // ignore: constant_identifier_names
  back_supported,
  // ignore: constant_identifier_names
  hip_hinge_setup,
  // From pullup family
  hanging,
  // From pulldown family
  kneeling,
}

/// The handle or attachment used, primarily for cables.
enum Attachment {
  none,
  rope,
  // ignore: constant_identifier_names
  straight_bar,
  // ignore: constant_identifier_names
  ez_bar,
  // ignore: constant_identifier_names
  v_bar,
  // ignore: constant_identifier_names
  d_handle,
  // ignore: constant_identifier_names
  lat_bar,
  // ignore: constant_identifier_names
  single_d_handle,
}

/// The user's grip on the equipment.
enum Grip {
  neutral,
  supinated,
  pronated,
  mixed,
  hook,
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\domain\exercise_instance.dart ----- 
// lib/src/features/dxg/domain/exercise_instance.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'dart:convert';
import 'package:drift/drift.dart';
import 'package:json_annotation/json_annotation.dart';
import 'package:collection/collection.dart';

// --- FIX ---
// This file no longer uses the freezed code generator. It will only generate
// a `.g.dart` file for JSON serialization.
part 'exercise_instance.g.dart';

// -----------------------------------------------------------------------------
// --- EXERCISE INSTANCE DATA MODEL --------------------------------------------
// -----------------------------------------------------------------------------
// This model represents a canonical exercise that has been used at least once
// and is therefore persisted to the local database. It is now a standard,
// immutable Dart class to bypass the `freezed` generator crash.
// -----------------------------------------------------------------------------

@JsonSerializable()
class ExerciseInstance {
  /// The stable, unique identifier for this exercise combination.
  /// e.g., "press.dumbbell.incline.bilateral.supine"
  final String slug;

  /// The ID of the parent family, e.g., "press".
  final String familyId;

  /// The human-readable name generated by the DXG engine.
  /// e.g., "Incline Dumbbell Press"
  final String displayName;

  /// The map of selected discriminators that define this unique exercise.
  final Map<String, String> discriminators;

  /// The timestamp of when this exercise was first logged.
  final DateTime firstSeenAt;

  const ExerciseInstance({
    required this.slug,
    required this.familyId,
    required this.displayName,
    required this.discriminators,
    required this.firstSeenAt,
  });

  /// Factory constructor for creating a new ExerciseInstance instance from a map.
  /// This is used by the `json_serializable` package.
  factory ExerciseInstance.fromJson(Map<String, dynamic> json) =>
      _$ExerciseInstanceFromJson(json);

  /// Converts this ExerciseInstance instance to a map.
  /// This is used by the `json_serializable` package.
  Map<String, dynamic> toJson() => _$ExerciseInstanceToJson(this);

  /// Manually implemented `hashCode` for value equality.
  /// It uses `DeepCollectionEquality` to correctly hash the `discriminators` map.
  @override
  int get hashCode => Object.hash(
        slug,
        familyId,
        displayName,
        const DeepCollectionEquality().hash(discriminators),
        firstSeenAt,
      );

  /// Manually implemented `operator ==` for value equality.
  /// It uses `DeepCollectionEquality` to correctly compare the `discriminators` map.
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is ExerciseInstance &&
        other.slug == slug &&
        other.familyId == familyId &&
        other.displayName == displayName &&
        const DeepCollectionEquality()
            .equals(other.discriminators, discriminators) &&
        other.firstSeenAt == firstSeenAt;
  }
}

// -----------------------------------------------------------------------------
// --- DRIFT TYPE CONVERTER ----------------------------------------------------
// -----------------------------------------------------------------------------
// This converter is unchanged and works with the new class definition.
// It handles the conversion between the Map<String, String> and a JSON string
// for storage in the Drift database.
// -----------------------------------------------------------------------------

class DiscriminatorsConverter extends TypeConverter<Map<String, String>, String> {
  const DiscriminatorsConverter();

  @override
  Map<String, String> fromSql(String fromDb) {
    final decodedMap = json.decode(fromDb) as Map<String, dynamic>;
    return decodedMap.map((key, value) => MapEntry(key, value.toString()));
  }

  @override
  String toSql(Map<String, String> value) {
    return json.encode(value);
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\domain\exercise_instance.g.dart ----- 
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'exercise_instance.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

ExerciseInstance _$ExerciseInstanceFromJson(Map<String, dynamic> json) =>
    ExerciseInstance(
      slug: json['slug'] as String,
      familyId: json['familyId'] as String,
      displayName: json['displayName'] as String,
      discriminators: Map<String, String>.from(json['discriminators'] as Map),
      firstSeenAt: DateTime.parse(json['firstSeenAt'] as String),
    );

Map<String, dynamic> _$ExerciseInstanceToJson(ExerciseInstance instance) =>
    <String, dynamic>{
      'slug': instance.slug,
      'familyId': instance.familyId,
      'displayName': instance.displayName,
      'discriminators': instance.discriminators,
      'firstSeenAt': instance.firstSeenAt.toIso8601String(),
    };
----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\domain\movement_family.dart ----- 
// ----- lib/src/features/dxg/domain/movement_family.dart -----
// lib/src/features/dxg/domain/movement_family.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:fairware_lift/src/features/dxg/domain/dxg_enums.dart';

part 'movement_family.freezed.dart';
part 'movement_family.g.dart';

// -----------------------------------------------------------------------------
// --- MOVEMENT FAMILY DATA MODEL ----------------------------------------------
// -----------------------------------------------------------------------------
// This file defines the core data structure for a "Movement Family" as specified
// in the DXG document. It is designed to be parsed directly from the
// `movement_families.seed.json` file.
//
// The `@freezed` annotation is used to generate boilerplate code for creating an
// immutable data class, including `copyWith`, `==`, `hashCode`, and `toString`
// methods, as well as the `fromJson` factory.
// -----------------------------------------------------------------------------

@freezed
class MovementFamily with _$MovementFamily {
  const factory MovementFamily({
    required String id,
    required String name,
    required MovementPattern pattern,
    required List<String> primary_muscles,
    required List<String> secondary_muscles,
    required AllowedDiscriminators allowed,
    @Default([]) List<DenyRule> denies,
    required String display_name_template,
    @Default([]) List<NamingRule> naming_rules,
    @Default([]) List<String> aliases,
    String? notes,
  }) = _MovementFamily;

  factory MovementFamily.fromJson(Map<String, dynamic> json) =>
      _$MovementFamilyFromJson(json);
}

/// Represents the "allowed" block within a MovementFamily.
/// This defines the valid discriminator options for constructing an exercise.
@freezed
class AllowedDiscriminators with _$AllowedDiscriminators {
  const factory AllowedDiscriminators({
    @Default([]) List<String> equipment,
    @Default([]) List<String> angle,
    @Default([]) List<String> unilateral,
    @Default([]) List<String> orientation,
    @Default([]) List<String> attachment,
    // --- NEW ---
    // Added cable_height to support the new discriminator.
    @Default([]) List<String> cable_height,
    @Default([]) List<String> grip,
  }) = _AllowedDiscriminators;

  factory AllowedDiscriminators.fromJson(Map<String, dynamic> json) =>
      _$AllowedDiscriminatorsFromJson(json);
}

/// Represents a single "denies" rule.
/// This is used to explicitly forbid combinations that would otherwise be
/// allowed (e.g., denying a "rope" attachment for a "barbell").
@freezed
class DenyRule with _$DenyRule {
  const factory DenyRule({
    String? equipment,
    List<String>? attachment,
    // Add other discriminator fields here if more complex deny rules are needed.
  }) = _DenyRule;

  factory DenyRule.fromJson(Map<String, dynamic> json) =>
      _$DenyRuleFromJson(json);
}

/// Represents a "naming_rules" override.
/// This allows for specific combinations to generate a different display name
/// than the one from the main template (e.g., making a supinated pull-up
/// display as "Chin-Up").
@freezed
class NamingRule with _$NamingRule {
  const factory NamingRule({
    // ignore: invalid_annotation_target
    @JsonKey(name: 'if') required Map<String, String> ifCondition,
    required String name,
  }) = _NamingRule;

  factory NamingRule.fromJson(Map<String, dynamic> json) =>
      _$NamingRuleFromJson(json);
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\domain\movement_family.freezed.dart ----- 
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'movement_family.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

MovementFamily _$MovementFamilyFromJson(Map<String, dynamic> json) {
  return _MovementFamily.fromJson(json);
}

/// @nodoc
mixin _$MovementFamily {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  MovementPattern get pattern => throw _privateConstructorUsedError;
  List<String> get primary_muscles => throw _privateConstructorUsedError;
  List<String> get secondary_muscles => throw _privateConstructorUsedError;
  AllowedDiscriminators get allowed => throw _privateConstructorUsedError;
  List<DenyRule> get denies => throw _privateConstructorUsedError;
  String get display_name_template => throw _privateConstructorUsedError;
  List<NamingRule> get naming_rules => throw _privateConstructorUsedError;
  List<String> get aliases => throw _privateConstructorUsedError;
  String? get notes => throw _privateConstructorUsedError;

  /// Serializes this MovementFamily to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of MovementFamily
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MovementFamilyCopyWith<MovementFamily> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MovementFamilyCopyWith<$Res> {
  factory $MovementFamilyCopyWith(
          MovementFamily value, $Res Function(MovementFamily) then) =
      _$MovementFamilyCopyWithImpl<$Res, MovementFamily>;
  @useResult
  $Res call(
      {String id,
      String name,
      MovementPattern pattern,
      List<String> primary_muscles,
      List<String> secondary_muscles,
      AllowedDiscriminators allowed,
      List<DenyRule> denies,
      String display_name_template,
      List<NamingRule> naming_rules,
      List<String> aliases,
      String? notes});

  $AllowedDiscriminatorsCopyWith<$Res> get allowed;
}

/// @nodoc
class _$MovementFamilyCopyWithImpl<$Res, $Val extends MovementFamily>
    implements $MovementFamilyCopyWith<$Res> {
  _$MovementFamilyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MovementFamily
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? pattern = null,
    Object? primary_muscles = null,
    Object? secondary_muscles = null,
    Object? allowed = null,
    Object? denies = null,
    Object? display_name_template = null,
    Object? naming_rules = null,
    Object? aliases = null,
    Object? notes = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      pattern: null == pattern
          ? _value.pattern
          : pattern // ignore: cast_nullable_to_non_nullable
              as MovementPattern,
      primary_muscles: null == primary_muscles
          ? _value.primary_muscles
          : primary_muscles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      secondary_muscles: null == secondary_muscles
          ? _value.secondary_muscles
          : secondary_muscles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      allowed: null == allowed
          ? _value.allowed
          : allowed // ignore: cast_nullable_to_non_nullable
              as AllowedDiscriminators,
      denies: null == denies
          ? _value.denies
          : denies // ignore: cast_nullable_to_non_nullable
              as List<DenyRule>,
      display_name_template: null == display_name_template
          ? _value.display_name_template
          : display_name_template // ignore: cast_nullable_to_non_nullable
              as String,
      naming_rules: null == naming_rules
          ? _value.naming_rules
          : naming_rules // ignore: cast_nullable_to_non_nullable
              as List<NamingRule>,
      aliases: null == aliases
          ? _value.aliases
          : aliases // ignore: cast_nullable_to_non_nullable
              as List<String>,
      notes: freezed == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  /// Create a copy of MovementFamily
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AllowedDiscriminatorsCopyWith<$Res> get allowed {
    return $AllowedDiscriminatorsCopyWith<$Res>(_value.allowed, (value) {
      return _then(_value.copyWith(allowed: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$MovementFamilyImplCopyWith<$Res>
    implements $MovementFamilyCopyWith<$Res> {
  factory _$$MovementFamilyImplCopyWith(_$MovementFamilyImpl value,
          $Res Function(_$MovementFamilyImpl) then) =
      __$$MovementFamilyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      MovementPattern pattern,
      List<String> primary_muscles,
      List<String> secondary_muscles,
      AllowedDiscriminators allowed,
      List<DenyRule> denies,
      String display_name_template,
      List<NamingRule> naming_rules,
      List<String> aliases,
      String? notes});

  @override
  $AllowedDiscriminatorsCopyWith<$Res> get allowed;
}

/// @nodoc
class __$$MovementFamilyImplCopyWithImpl<$Res>
    extends _$MovementFamilyCopyWithImpl<$Res, _$MovementFamilyImpl>
    implements _$$MovementFamilyImplCopyWith<$Res> {
  __$$MovementFamilyImplCopyWithImpl(
      _$MovementFamilyImpl _value, $Res Function(_$MovementFamilyImpl) _then)
      : super(_value, _then);

  /// Create a copy of MovementFamily
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? pattern = null,
    Object? primary_muscles = null,
    Object? secondary_muscles = null,
    Object? allowed = null,
    Object? denies = null,
    Object? display_name_template = null,
    Object? naming_rules = null,
    Object? aliases = null,
    Object? notes = freezed,
  }) {
    return _then(_$MovementFamilyImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      pattern: null == pattern
          ? _value.pattern
          : pattern // ignore: cast_nullable_to_non_nullable
              as MovementPattern,
      primary_muscles: null == primary_muscles
          ? _value._primary_muscles
          : primary_muscles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      secondary_muscles: null == secondary_muscles
          ? _value._secondary_muscles
          : secondary_muscles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      allowed: null == allowed
          ? _value.allowed
          : allowed // ignore: cast_nullable_to_non_nullable
              as AllowedDiscriminators,
      denies: null == denies
          ? _value._denies
          : denies // ignore: cast_nullable_to_non_nullable
              as List<DenyRule>,
      display_name_template: null == display_name_template
          ? _value.display_name_template
          : display_name_template // ignore: cast_nullable_to_non_nullable
              as String,
      naming_rules: null == naming_rules
          ? _value._naming_rules
          : naming_rules // ignore: cast_nullable_to_non_nullable
              as List<NamingRule>,
      aliases: null == aliases
          ? _value._aliases
          : aliases // ignore: cast_nullable_to_non_nullable
              as List<String>,
      notes: freezed == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MovementFamilyImpl implements _MovementFamily {
  const _$MovementFamilyImpl(
      {required this.id,
      required this.name,
      required this.pattern,
      required final List<String> primary_muscles,
      required final List<String> secondary_muscles,
      required this.allowed,
      final List<DenyRule> denies = const [],
      required this.display_name_template,
      final List<NamingRule> naming_rules = const [],
      final List<String> aliases = const [],
      this.notes})
      : _primary_muscles = primary_muscles,
        _secondary_muscles = secondary_muscles,
        _denies = denies,
        _naming_rules = naming_rules,
        _aliases = aliases;

  factory _$MovementFamilyImpl.fromJson(Map<String, dynamic> json) =>
      _$$MovementFamilyImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final MovementPattern pattern;
  final List<String> _primary_muscles;
  @override
  List<String> get primary_muscles {
    if (_primary_muscles is EqualUnmodifiableListView) return _primary_muscles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_primary_muscles);
  }

  final List<String> _secondary_muscles;
  @override
  List<String> get secondary_muscles {
    if (_secondary_muscles is EqualUnmodifiableListView)
      return _secondary_muscles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_secondary_muscles);
  }

  @override
  final AllowedDiscriminators allowed;
  final List<DenyRule> _denies;
  @override
  @JsonKey()
  List<DenyRule> get denies {
    if (_denies is EqualUnmodifiableListView) return _denies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_denies);
  }

  @override
  final String display_name_template;
  final List<NamingRule> _naming_rules;
  @override
  @JsonKey()
  List<NamingRule> get naming_rules {
    if (_naming_rules is EqualUnmodifiableListView) return _naming_rules;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_naming_rules);
  }

  final List<String> _aliases;
  @override
  @JsonKey()
  List<String> get aliases {
    if (_aliases is EqualUnmodifiableListView) return _aliases;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_aliases);
  }

  @override
  final String? notes;

  @override
  String toString() {
    return 'MovementFamily(id: $id, name: $name, pattern: $pattern, primary_muscles: $primary_muscles, secondary_muscles: $secondary_muscles, allowed: $allowed, denies: $denies, display_name_template: $display_name_template, naming_rules: $naming_rules, aliases: $aliases, notes: $notes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MovementFamilyImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.pattern, pattern) || other.pattern == pattern) &&
            const DeepCollectionEquality()
                .equals(other._primary_muscles, _primary_muscles) &&
            const DeepCollectionEquality()
                .equals(other._secondary_muscles, _secondary_muscles) &&
            (identical(other.allowed, allowed) || other.allowed == allowed) &&
            const DeepCollectionEquality().equals(other._denies, _denies) &&
            (identical(other.display_name_template, display_name_template) ||
                other.display_name_template == display_name_template) &&
            const DeepCollectionEquality()
                .equals(other._naming_rules, _naming_rules) &&
            const DeepCollectionEquality().equals(other._aliases, _aliases) &&
            (identical(other.notes, notes) || other.notes == notes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      pattern,
      const DeepCollectionEquality().hash(_primary_muscles),
      const DeepCollectionEquality().hash(_secondary_muscles),
      allowed,
      const DeepCollectionEquality().hash(_denies),
      display_name_template,
      const DeepCollectionEquality().hash(_naming_rules),
      const DeepCollectionEquality().hash(_aliases),
      notes);

  /// Create a copy of MovementFamily
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MovementFamilyImplCopyWith<_$MovementFamilyImpl> get copyWith =>
      __$$MovementFamilyImplCopyWithImpl<_$MovementFamilyImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MovementFamilyImplToJson(
      this,
    );
  }
}

abstract class _MovementFamily implements MovementFamily {
  const factory _MovementFamily(
      {required final String id,
      required final String name,
      required final MovementPattern pattern,
      required final List<String> primary_muscles,
      required final List<String> secondary_muscles,
      required final AllowedDiscriminators allowed,
      final List<DenyRule> denies,
      required final String display_name_template,
      final List<NamingRule> naming_rules,
      final List<String> aliases,
      final String? notes}) = _$MovementFamilyImpl;

  factory _MovementFamily.fromJson(Map<String, dynamic> json) =
      _$MovementFamilyImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  MovementPattern get pattern;
  @override
  List<String> get primary_muscles;
  @override
  List<String> get secondary_muscles;
  @override
  AllowedDiscriminators get allowed;
  @override
  List<DenyRule> get denies;
  @override
  String get display_name_template;
  @override
  List<NamingRule> get naming_rules;
  @override
  List<String> get aliases;
  @override
  String? get notes;

  /// Create a copy of MovementFamily
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MovementFamilyImplCopyWith<_$MovementFamilyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AllowedDiscriminators _$AllowedDiscriminatorsFromJson(
    Map<String, dynamic> json) {
  return _AllowedDiscriminators.fromJson(json);
}

/// @nodoc
mixin _$AllowedDiscriminators {
  List<String> get equipment => throw _privateConstructorUsedError;
  List<String> get angle => throw _privateConstructorUsedError;
  List<String> get unilateral => throw _privateConstructorUsedError;
  List<String> get orientation => throw _privateConstructorUsedError;
  List<String> get attachment =>
      throw _privateConstructorUsedError; // --- NEW ---
// Added cable_height to support the new discriminator.
  List<String> get cable_height => throw _privateConstructorUsedError;
  List<String> get grip => throw _privateConstructorUsedError;

  /// Serializes this AllowedDiscriminators to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AllowedDiscriminators
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AllowedDiscriminatorsCopyWith<AllowedDiscriminators> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AllowedDiscriminatorsCopyWith<$Res> {
  factory $AllowedDiscriminatorsCopyWith(AllowedDiscriminators value,
          $Res Function(AllowedDiscriminators) then) =
      _$AllowedDiscriminatorsCopyWithImpl<$Res, AllowedDiscriminators>;
  @useResult
  $Res call(
      {List<String> equipment,
      List<String> angle,
      List<String> unilateral,
      List<String> orientation,
      List<String> attachment,
      List<String> cable_height,
      List<String> grip});
}

/// @nodoc
class _$AllowedDiscriminatorsCopyWithImpl<$Res,
        $Val extends AllowedDiscriminators>
    implements $AllowedDiscriminatorsCopyWith<$Res> {
  _$AllowedDiscriminatorsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AllowedDiscriminators
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equipment = null,
    Object? angle = null,
    Object? unilateral = null,
    Object? orientation = null,
    Object? attachment = null,
    Object? cable_height = null,
    Object? grip = null,
  }) {
    return _then(_value.copyWith(
      equipment: null == equipment
          ? _value.equipment
          : equipment // ignore: cast_nullable_to_non_nullable
              as List<String>,
      angle: null == angle
          ? _value.angle
          : angle // ignore: cast_nullable_to_non_nullable
              as List<String>,
      unilateral: null == unilateral
          ? _value.unilateral
          : unilateral // ignore: cast_nullable_to_non_nullable
              as List<String>,
      orientation: null == orientation
          ? _value.orientation
          : orientation // ignore: cast_nullable_to_non_nullable
              as List<String>,
      attachment: null == attachment
          ? _value.attachment
          : attachment // ignore: cast_nullable_to_non_nullable
              as List<String>,
      cable_height: null == cable_height
          ? _value.cable_height
          : cable_height // ignore: cast_nullable_to_non_nullable
              as List<String>,
      grip: null == grip
          ? _value.grip
          : grip // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AllowedDiscriminatorsImplCopyWith<$Res>
    implements $AllowedDiscriminatorsCopyWith<$Res> {
  factory _$$AllowedDiscriminatorsImplCopyWith(
          _$AllowedDiscriminatorsImpl value,
          $Res Function(_$AllowedDiscriminatorsImpl) then) =
      __$$AllowedDiscriminatorsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<String> equipment,
      List<String> angle,
      List<String> unilateral,
      List<String> orientation,
      List<String> attachment,
      List<String> cable_height,
      List<String> grip});
}

/// @nodoc
class __$$AllowedDiscriminatorsImplCopyWithImpl<$Res>
    extends _$AllowedDiscriminatorsCopyWithImpl<$Res,
        _$AllowedDiscriminatorsImpl>
    implements _$$AllowedDiscriminatorsImplCopyWith<$Res> {
  __$$AllowedDiscriminatorsImplCopyWithImpl(_$AllowedDiscriminatorsImpl _value,
      $Res Function(_$AllowedDiscriminatorsImpl) _then)
      : super(_value, _then);

  /// Create a copy of AllowedDiscriminators
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equipment = null,
    Object? angle = null,
    Object? unilateral = null,
    Object? orientation = null,
    Object? attachment = null,
    Object? cable_height = null,
    Object? grip = null,
  }) {
    return _then(_$AllowedDiscriminatorsImpl(
      equipment: null == equipment
          ? _value._equipment
          : equipment // ignore: cast_nullable_to_non_nullable
              as List<String>,
      angle: null == angle
          ? _value._angle
          : angle // ignore: cast_nullable_to_non_nullable
              as List<String>,
      unilateral: null == unilateral
          ? _value._unilateral
          : unilateral // ignore: cast_nullable_to_non_nullable
              as List<String>,
      orientation: null == orientation
          ? _value._orientation
          : orientation // ignore: cast_nullable_to_non_nullable
              as List<String>,
      attachment: null == attachment
          ? _value._attachment
          : attachment // ignore: cast_nullable_to_non_nullable
              as List<String>,
      cable_height: null == cable_height
          ? _value._cable_height
          : cable_height // ignore: cast_nullable_to_non_nullable
              as List<String>,
      grip: null == grip
          ? _value._grip
          : grip // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AllowedDiscriminatorsImpl implements _AllowedDiscriminators {
  const _$AllowedDiscriminatorsImpl(
      {final List<String> equipment = const [],
      final List<String> angle = const [],
      final List<String> unilateral = const [],
      final List<String> orientation = const [],
      final List<String> attachment = const [],
      final List<String> cable_height = const [],
      final List<String> grip = const []})
      : _equipment = equipment,
        _angle = angle,
        _unilateral = unilateral,
        _orientation = orientation,
        _attachment = attachment,
        _cable_height = cable_height,
        _grip = grip;

  factory _$AllowedDiscriminatorsImpl.fromJson(Map<String, dynamic> json) =>
      _$$AllowedDiscriminatorsImplFromJson(json);

  final List<String> _equipment;
  @override
  @JsonKey()
  List<String> get equipment {
    if (_equipment is EqualUnmodifiableListView) return _equipment;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_equipment);
  }

  final List<String> _angle;
  @override
  @JsonKey()
  List<String> get angle {
    if (_angle is EqualUnmodifiableListView) return _angle;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_angle);
  }

  final List<String> _unilateral;
  @override
  @JsonKey()
  List<String> get unilateral {
    if (_unilateral is EqualUnmodifiableListView) return _unilateral;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_unilateral);
  }

  final List<String> _orientation;
  @override
  @JsonKey()
  List<String> get orientation {
    if (_orientation is EqualUnmodifiableListView) return _orientation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_orientation);
  }

  final List<String> _attachment;
  @override
  @JsonKey()
  List<String> get attachment {
    if (_attachment is EqualUnmodifiableListView) return _attachment;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_attachment);
  }

// --- NEW ---
// Added cable_height to support the new discriminator.
  final List<String> _cable_height;
// --- NEW ---
// Added cable_height to support the new discriminator.
  @override
  @JsonKey()
  List<String> get cable_height {
    if (_cable_height is EqualUnmodifiableListView) return _cable_height;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_cable_height);
  }

  final List<String> _grip;
  @override
  @JsonKey()
  List<String> get grip {
    if (_grip is EqualUnmodifiableListView) return _grip;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_grip);
  }

  @override
  String toString() {
    return 'AllowedDiscriminators(equipment: $equipment, angle: $angle, unilateral: $unilateral, orientation: $orientation, attachment: $attachment, cable_height: $cable_height, grip: $grip)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AllowedDiscriminatorsImpl &&
            const DeepCollectionEquality()
                .equals(other._equipment, _equipment) &&
            const DeepCollectionEquality().equals(other._angle, _angle) &&
            const DeepCollectionEquality()
                .equals(other._unilateral, _unilateral) &&
            const DeepCollectionEquality()
                .equals(other._orientation, _orientation) &&
            const DeepCollectionEquality()
                .equals(other._attachment, _attachment) &&
            const DeepCollectionEquality()
                .equals(other._cable_height, _cable_height) &&
            const DeepCollectionEquality().equals(other._grip, _grip));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_equipment),
      const DeepCollectionEquality().hash(_angle),
      const DeepCollectionEquality().hash(_unilateral),
      const DeepCollectionEquality().hash(_orientation),
      const DeepCollectionEquality().hash(_attachment),
      const DeepCollectionEquality().hash(_cable_height),
      const DeepCollectionEquality().hash(_grip));

  /// Create a copy of AllowedDiscriminators
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AllowedDiscriminatorsImplCopyWith<_$AllowedDiscriminatorsImpl>
      get copyWith => __$$AllowedDiscriminatorsImplCopyWithImpl<
          _$AllowedDiscriminatorsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AllowedDiscriminatorsImplToJson(
      this,
    );
  }
}

abstract class _AllowedDiscriminators implements AllowedDiscriminators {
  const factory _AllowedDiscriminators(
      {final List<String> equipment,
      final List<String> angle,
      final List<String> unilateral,
      final List<String> orientation,
      final List<String> attachment,
      final List<String> cable_height,
      final List<String> grip}) = _$AllowedDiscriminatorsImpl;

  factory _AllowedDiscriminators.fromJson(Map<String, dynamic> json) =
      _$AllowedDiscriminatorsImpl.fromJson;

  @override
  List<String> get equipment;
  @override
  List<String> get angle;
  @override
  List<String> get unilateral;
  @override
  List<String> get orientation;
  @override
  List<String> get attachment; // --- NEW ---
// Added cable_height to support the new discriminator.
  @override
  List<String> get cable_height;
  @override
  List<String> get grip;

  /// Create a copy of AllowedDiscriminators
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AllowedDiscriminatorsImplCopyWith<_$AllowedDiscriminatorsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

DenyRule _$DenyRuleFromJson(Map<String, dynamic> json) {
  return _DenyRule.fromJson(json);
}

/// @nodoc
mixin _$DenyRule {
  String? get equipment => throw _privateConstructorUsedError;
  List<String>? get attachment => throw _privateConstructorUsedError;

  /// Serializes this DenyRule to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of DenyRule
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DenyRuleCopyWith<DenyRule> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DenyRuleCopyWith<$Res> {
  factory $DenyRuleCopyWith(DenyRule value, $Res Function(DenyRule) then) =
      _$DenyRuleCopyWithImpl<$Res, DenyRule>;
  @useResult
  $Res call({String? equipment, List<String>? attachment});
}

/// @nodoc
class _$DenyRuleCopyWithImpl<$Res, $Val extends DenyRule>
    implements $DenyRuleCopyWith<$Res> {
  _$DenyRuleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DenyRule
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equipment = freezed,
    Object? attachment = freezed,
  }) {
    return _then(_value.copyWith(
      equipment: freezed == equipment
          ? _value.equipment
          : equipment // ignore: cast_nullable_to_non_nullable
              as String?,
      attachment: freezed == attachment
          ? _value.attachment
          : attachment // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DenyRuleImplCopyWith<$Res>
    implements $DenyRuleCopyWith<$Res> {
  factory _$$DenyRuleImplCopyWith(
          _$DenyRuleImpl value, $Res Function(_$DenyRuleImpl) then) =
      __$$DenyRuleImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? equipment, List<String>? attachment});
}

/// @nodoc
class __$$DenyRuleImplCopyWithImpl<$Res>
    extends _$DenyRuleCopyWithImpl<$Res, _$DenyRuleImpl>
    implements _$$DenyRuleImplCopyWith<$Res> {
  __$$DenyRuleImplCopyWithImpl(
      _$DenyRuleImpl _value, $Res Function(_$DenyRuleImpl) _then)
      : super(_value, _then);

  /// Create a copy of DenyRule
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equipment = freezed,
    Object? attachment = freezed,
  }) {
    return _then(_$DenyRuleImpl(
      equipment: freezed == equipment
          ? _value.equipment
          : equipment // ignore: cast_nullable_to_non_nullable
              as String?,
      attachment: freezed == attachment
          ? _value._attachment
          : attachment // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DenyRuleImpl implements _DenyRule {
  const _$DenyRuleImpl({this.equipment, final List<String>? attachment})
      : _attachment = attachment;

  factory _$DenyRuleImpl.fromJson(Map<String, dynamic> json) =>
      _$$DenyRuleImplFromJson(json);

  @override
  final String? equipment;
  final List<String>? _attachment;
  @override
  List<String>? get attachment {
    final value = _attachment;
    if (value == null) return null;
    if (_attachment is EqualUnmodifiableListView) return _attachment;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'DenyRule(equipment: $equipment, attachment: $attachment)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DenyRuleImpl &&
            (identical(other.equipment, equipment) ||
                other.equipment == equipment) &&
            const DeepCollectionEquality()
                .equals(other._attachment, _attachment));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, equipment, const DeepCollectionEquality().hash(_attachment));

  /// Create a copy of DenyRule
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DenyRuleImplCopyWith<_$DenyRuleImpl> get copyWith =>
      __$$DenyRuleImplCopyWithImpl<_$DenyRuleImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DenyRuleImplToJson(
      this,
    );
  }
}

abstract class _DenyRule implements DenyRule {
  const factory _DenyRule(
      {final String? equipment,
      final List<String>? attachment}) = _$DenyRuleImpl;

  factory _DenyRule.fromJson(Map<String, dynamic> json) =
      _$DenyRuleImpl.fromJson;

  @override
  String? get equipment;
  @override
  List<String>? get attachment;

  /// Create a copy of DenyRule
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DenyRuleImplCopyWith<_$DenyRuleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

NamingRule _$NamingRuleFromJson(Map<String, dynamic> json) {
  return _NamingRule.fromJson(json);
}

/// @nodoc
mixin _$NamingRule {
// ignore: invalid_annotation_target
  @JsonKey(name: 'if')
  Map<String, String> get ifCondition => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;

  /// Serializes this NamingRule to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of NamingRule
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NamingRuleCopyWith<NamingRule> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NamingRuleCopyWith<$Res> {
  factory $NamingRuleCopyWith(
          NamingRule value, $Res Function(NamingRule) then) =
      _$NamingRuleCopyWithImpl<$Res, NamingRule>;
  @useResult
  $Res call(
      {@JsonKey(name: 'if') Map<String, String> ifCondition, String name});
}

/// @nodoc
class _$NamingRuleCopyWithImpl<$Res, $Val extends NamingRule>
    implements $NamingRuleCopyWith<$Res> {
  _$NamingRuleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NamingRule
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ifCondition = null,
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      ifCondition: null == ifCondition
          ? _value.ifCondition
          : ifCondition // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NamingRuleImplCopyWith<$Res>
    implements $NamingRuleCopyWith<$Res> {
  factory _$$NamingRuleImplCopyWith(
          _$NamingRuleImpl value, $Res Function(_$NamingRuleImpl) then) =
      __$$NamingRuleImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'if') Map<String, String> ifCondition, String name});
}

/// @nodoc
class __$$NamingRuleImplCopyWithImpl<$Res>
    extends _$NamingRuleCopyWithImpl<$Res, _$NamingRuleImpl>
    implements _$$NamingRuleImplCopyWith<$Res> {
  __$$NamingRuleImplCopyWithImpl(
      _$NamingRuleImpl _value, $Res Function(_$NamingRuleImpl) _then)
      : super(_value, _then);

  /// Create a copy of NamingRule
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ifCondition = null,
    Object? name = null,
  }) {
    return _then(_$NamingRuleImpl(
      ifCondition: null == ifCondition
          ? _value._ifCondition
          : ifCondition // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NamingRuleImpl implements _NamingRule {
  const _$NamingRuleImpl(
      {@JsonKey(name: 'if') required final Map<String, String> ifCondition,
      required this.name})
      : _ifCondition = ifCondition;

  factory _$NamingRuleImpl.fromJson(Map<String, dynamic> json) =>
      _$$NamingRuleImplFromJson(json);

// ignore: invalid_annotation_target
  final Map<String, String> _ifCondition;
// ignore: invalid_annotation_target
  @override
  @JsonKey(name: 'if')
  Map<String, String> get ifCondition {
    if (_ifCondition is EqualUnmodifiableMapView) return _ifCondition;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_ifCondition);
  }

  @override
  final String name;

  @override
  String toString() {
    return 'NamingRule(ifCondition: $ifCondition, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NamingRuleImpl &&
            const DeepCollectionEquality()
                .equals(other._ifCondition, _ifCondition) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_ifCondition), name);

  /// Create a copy of NamingRule
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NamingRuleImplCopyWith<_$NamingRuleImpl> get copyWith =>
      __$$NamingRuleImplCopyWithImpl<_$NamingRuleImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$NamingRuleImplToJson(
      this,
    );
  }
}

abstract class _NamingRule implements NamingRule {
  const factory _NamingRule(
      {@JsonKey(name: 'if') required final Map<String, String> ifCondition,
      required final String name}) = _$NamingRuleImpl;

  factory _NamingRule.fromJson(Map<String, dynamic> json) =
      _$NamingRuleImpl.fromJson;

// ignore: invalid_annotation_target
  @override
  @JsonKey(name: 'if')
  Map<String, String> get ifCondition;
  @override
  String get name;

  /// Create a copy of NamingRule
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NamingRuleImplCopyWith<_$NamingRuleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\domain\movement_family.g.dart ----- 
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'movement_family.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$MovementFamilyImpl _$$MovementFamilyImplFromJson(Map<String, dynamic> json) =>
    _$MovementFamilyImpl(
      id: json['id'] as String,
      name: json['name'] as String,
      pattern: $enumDecode(_$MovementPatternEnumMap, json['pattern']),
      primary_muscles: (json['primary_muscles'] as List<dynamic>)
          .map((e) => e as String)
          .toList(),
      secondary_muscles: (json['secondary_muscles'] as List<dynamic>)
          .map((e) => e as String)
          .toList(),
      allowed: AllowedDiscriminators.fromJson(
          json['allowed'] as Map<String, dynamic>),
      denies: (json['denies'] as List<dynamic>?)
              ?.map((e) => DenyRule.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      display_name_template: json['display_name_template'] as String,
      naming_rules: (json['naming_rules'] as List<dynamic>?)
              ?.map((e) => NamingRule.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      aliases: (json['aliases'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          const [],
      notes: json['notes'] as String?,
    );

Map<String, dynamic> _$$MovementFamilyImplToJson(
        _$MovementFamilyImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'name': instance.name,
      'pattern': _$MovementPatternEnumMap[instance.pattern]!,
      'primary_muscles': instance.primary_muscles,
      'secondary_muscles': instance.secondary_muscles,
      'allowed': instance.allowed,
      'denies': instance.denies,
      'display_name_template': instance.display_name_template,
      'naming_rules': instance.naming_rules,
      'aliases': instance.aliases,
      'notes': instance.notes,
    };

const _$MovementPatternEnumMap = {
  MovementPattern.push: 'push',
  MovementPattern.pull: 'pull',
  MovementPattern.squat: 'squat',
  MovementPattern.hinge: 'hinge',
  MovementPattern.lunge: 'lunge',
  MovementPattern.carry: 'carry',
  MovementPattern.rotate: 'rotate',
  MovementPattern.anti_rotate: 'anti_rotate',
  MovementPattern.gait: 'gait',
  MovementPattern.isolation: 'isolation',
};

_$AllowedDiscriminatorsImpl _$$AllowedDiscriminatorsImplFromJson(
        Map<String, dynamic> json) =>
    _$AllowedDiscriminatorsImpl(
      equipment: (json['equipment'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          const [],
      angle:
          (json['angle'] as List<dynamic>?)?.map((e) => e as String).toList() ??
              const [],
      unilateral: (json['unilateral'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          const [],
      orientation: (json['orientation'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          const [],
      attachment: (json['attachment'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          const [],
      cable_height: (json['cable_height'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          const [],
      grip:
          (json['grip'] as List<dynamic>?)?.map((e) => e as String).toList() ??
              const [],
    );

Map<String, dynamic> _$$AllowedDiscriminatorsImplToJson(
        _$AllowedDiscriminatorsImpl instance) =>
    <String, dynamic>{
      'equipment': instance.equipment,
      'angle': instance.angle,
      'unilateral': instance.unilateral,
      'orientation': instance.orientation,
      'attachment': instance.attachment,
      'cable_height': instance.cable_height,
      'grip': instance.grip,
    };

_$DenyRuleImpl _$$DenyRuleImplFromJson(Map<String, dynamic> json) =>
    _$DenyRuleImpl(
      equipment: json['equipment'] as String?,
      attachment: (json['attachment'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
    );

Map<String, dynamic> _$$DenyRuleImplToJson(_$DenyRuleImpl instance) =>
    <String, dynamic>{
      'equipment': instance.equipment,
      'attachment': instance.attachment,
    };

_$NamingRuleImpl _$$NamingRuleImplFromJson(Map<String, dynamic> json) =>
    _$NamingRuleImpl(
      ifCondition: Map<String, String>.from(json['if'] as Map),
      name: json['name'] as String,
    );

Map<String, dynamic> _$$NamingRuleImplToJson(_$NamingRuleImpl instance) =>
    <String, dynamic>{
      'if': instance.ifCondition,
      'name': instance.name,
    };
----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\domain\warmup_item.dart ----- 
// lib/src/features/dxg/domain/warmup_item.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:freezed_annotation/freezed_annotation.dart';

part 'warmup_item.freezed.dart';
part 'warmup_item.g.dart';

// -----------------------------------------------------------------------------
// --- WARMUP ITEM DATA MODEL --------------------------------------------------
// -----------------------------------------------------------------------------

@freezed
class WarmupItem with _$WarmupItem {
  const factory WarmupItem({
    required String id,
    required String type,
    required String region,
    required String pattern,
    required String modality,
    // ignore: invalid_annotation_target
    @JsonKey(name: 'display_name') required String displayName,
    // --- NEW ---
    // A list of parameters that can be configured for this warm-up.
    @Default([]) List<WarmupParameter> parameters,
  }) = _WarmupItem;

  factory WarmupItem.fromJson(Map<String, dynamic> json) =>
      _$WarmupItemFromJson(json);
}

/// Represents a configurable parameter for a warm-up item, like "Grip".
@freezed
class WarmupParameter with _$WarmupParameter {
  const factory WarmupParameter({
    required String name,
    required List<String> options,
  }) = _WarmupParameter;

  factory WarmupParameter.fromJson(Map<String, dynamic> json) =>
      _$WarmupParameterFromJson(json);
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\domain\warmup_item.freezed.dart ----- 
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'warmup_item.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

WarmupItem _$WarmupItemFromJson(Map<String, dynamic> json) {
  return _WarmupItem.fromJson(json);
}

/// @nodoc
mixin _$WarmupItem {
  String get id => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  String get region => throw _privateConstructorUsedError;
  String get pattern => throw _privateConstructorUsedError;
  String get modality =>
      throw _privateConstructorUsedError; // ignore: invalid_annotation_target
  @JsonKey(name: 'display_name')
  String get displayName => throw _privateConstructorUsedError; // --- NEW ---
// A list of parameters that can be configured for this warm-up.
  List<WarmupParameter> get parameters => throw _privateConstructorUsedError;

  /// Serializes this WarmupItem to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of WarmupItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $WarmupItemCopyWith<WarmupItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WarmupItemCopyWith<$Res> {
  factory $WarmupItemCopyWith(
          WarmupItem value, $Res Function(WarmupItem) then) =
      _$WarmupItemCopyWithImpl<$Res, WarmupItem>;
  @useResult
  $Res call(
      {String id,
      String type,
      String region,
      String pattern,
      String modality,
      @JsonKey(name: 'display_name') String displayName,
      List<WarmupParameter> parameters});
}

/// @nodoc
class _$WarmupItemCopyWithImpl<$Res, $Val extends WarmupItem>
    implements $WarmupItemCopyWith<$Res> {
  _$WarmupItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of WarmupItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? region = null,
    Object? pattern = null,
    Object? modality = null,
    Object? displayName = null,
    Object? parameters = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      region: null == region
          ? _value.region
          : region // ignore: cast_nullable_to_non_nullable
              as String,
      pattern: null == pattern
          ? _value.pattern
          : pattern // ignore: cast_nullable_to_non_nullable
              as String,
      modality: null == modality
          ? _value.modality
          : modality // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: null == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      parameters: null == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<WarmupParameter>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WarmupItemImplCopyWith<$Res>
    implements $WarmupItemCopyWith<$Res> {
  factory _$$WarmupItemImplCopyWith(
          _$WarmupItemImpl value, $Res Function(_$WarmupItemImpl) then) =
      __$$WarmupItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String type,
      String region,
      String pattern,
      String modality,
      @JsonKey(name: 'display_name') String displayName,
      List<WarmupParameter> parameters});
}

/// @nodoc
class __$$WarmupItemImplCopyWithImpl<$Res>
    extends _$WarmupItemCopyWithImpl<$Res, _$WarmupItemImpl>
    implements _$$WarmupItemImplCopyWith<$Res> {
  __$$WarmupItemImplCopyWithImpl(
      _$WarmupItemImpl _value, $Res Function(_$WarmupItemImpl) _then)
      : super(_value, _then);

  /// Create a copy of WarmupItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? region = null,
    Object? pattern = null,
    Object? modality = null,
    Object? displayName = null,
    Object? parameters = null,
  }) {
    return _then(_$WarmupItemImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      region: null == region
          ? _value.region
          : region // ignore: cast_nullable_to_non_nullable
              as String,
      pattern: null == pattern
          ? _value.pattern
          : pattern // ignore: cast_nullable_to_non_nullable
              as String,
      modality: null == modality
          ? _value.modality
          : modality // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: null == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      parameters: null == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<WarmupParameter>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$WarmupItemImpl implements _WarmupItem {
  const _$WarmupItemImpl(
      {required this.id,
      required this.type,
      required this.region,
      required this.pattern,
      required this.modality,
      @JsonKey(name: 'display_name') required this.displayName,
      final List<WarmupParameter> parameters = const []})
      : _parameters = parameters;

  factory _$WarmupItemImpl.fromJson(Map<String, dynamic> json) =>
      _$$WarmupItemImplFromJson(json);

  @override
  final String id;
  @override
  final String type;
  @override
  final String region;
  @override
  final String pattern;
  @override
  final String modality;
// ignore: invalid_annotation_target
  @override
  @JsonKey(name: 'display_name')
  final String displayName;
// --- NEW ---
// A list of parameters that can be configured for this warm-up.
  final List<WarmupParameter> _parameters;
// --- NEW ---
// A list of parameters that can be configured for this warm-up.
  @override
  @JsonKey()
  List<WarmupParameter> get parameters {
    if (_parameters is EqualUnmodifiableListView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_parameters);
  }

  @override
  String toString() {
    return 'WarmupItem(id: $id, type: $type, region: $region, pattern: $pattern, modality: $modality, displayName: $displayName, parameters: $parameters)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WarmupItemImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.region, region) || other.region == region) &&
            (identical(other.pattern, pattern) || other.pattern == pattern) &&
            (identical(other.modality, modality) ||
                other.modality == modality) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, region, pattern,
      modality, displayName, const DeepCollectionEquality().hash(_parameters));

  /// Create a copy of WarmupItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WarmupItemImplCopyWith<_$WarmupItemImpl> get copyWith =>
      __$$WarmupItemImplCopyWithImpl<_$WarmupItemImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$WarmupItemImplToJson(
      this,
    );
  }
}

abstract class _WarmupItem implements WarmupItem {
  const factory _WarmupItem(
      {required final String id,
      required final String type,
      required final String region,
      required final String pattern,
      required final String modality,
      @JsonKey(name: 'display_name') required final String displayName,
      final List<WarmupParameter> parameters}) = _$WarmupItemImpl;

  factory _WarmupItem.fromJson(Map<String, dynamic> json) =
      _$WarmupItemImpl.fromJson;

  @override
  String get id;
  @override
  String get type;
  @override
  String get region;
  @override
  String get pattern;
  @override
  String get modality; // ignore: invalid_annotation_target
  @override
  @JsonKey(name: 'display_name')
  String get displayName; // --- NEW ---
// A list of parameters that can be configured for this warm-up.
  @override
  List<WarmupParameter> get parameters;

  /// Create a copy of WarmupItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WarmupItemImplCopyWith<_$WarmupItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

WarmupParameter _$WarmupParameterFromJson(Map<String, dynamic> json) {
  return _WarmupParameter.fromJson(json);
}

/// @nodoc
mixin _$WarmupParameter {
  String get name => throw _privateConstructorUsedError;
  List<String> get options => throw _privateConstructorUsedError;

  /// Serializes this WarmupParameter to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of WarmupParameter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $WarmupParameterCopyWith<WarmupParameter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WarmupParameterCopyWith<$Res> {
  factory $WarmupParameterCopyWith(
          WarmupParameter value, $Res Function(WarmupParameter) then) =
      _$WarmupParameterCopyWithImpl<$Res, WarmupParameter>;
  @useResult
  $Res call({String name, List<String> options});
}

/// @nodoc
class _$WarmupParameterCopyWithImpl<$Res, $Val extends WarmupParameter>
    implements $WarmupParameterCopyWith<$Res> {
  _$WarmupParameterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of WarmupParameter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? options = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      options: null == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WarmupParameterImplCopyWith<$Res>
    implements $WarmupParameterCopyWith<$Res> {
  factory _$$WarmupParameterImplCopyWith(_$WarmupParameterImpl value,
          $Res Function(_$WarmupParameterImpl) then) =
      __$$WarmupParameterImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, List<String> options});
}

/// @nodoc
class __$$WarmupParameterImplCopyWithImpl<$Res>
    extends _$WarmupParameterCopyWithImpl<$Res, _$WarmupParameterImpl>
    implements _$$WarmupParameterImplCopyWith<$Res> {
  __$$WarmupParameterImplCopyWithImpl(
      _$WarmupParameterImpl _value, $Res Function(_$WarmupParameterImpl) _then)
      : super(_value, _then);

  /// Create a copy of WarmupParameter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? options = null,
  }) {
    return _then(_$WarmupParameterImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      options: null == options
          ? _value._options
          : options // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$WarmupParameterImpl implements _WarmupParameter {
  const _$WarmupParameterImpl(
      {required this.name, required final List<String> options})
      : _options = options;

  factory _$WarmupParameterImpl.fromJson(Map<String, dynamic> json) =>
      _$$WarmupParameterImplFromJson(json);

  @override
  final String name;
  final List<String> _options;
  @override
  List<String> get options {
    if (_options is EqualUnmodifiableListView) return _options;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_options);
  }

  @override
  String toString() {
    return 'WarmupParameter(name: $name, options: $options)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WarmupParameterImpl &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._options, _options));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, name, const DeepCollectionEquality().hash(_options));

  /// Create a copy of WarmupParameter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WarmupParameterImplCopyWith<_$WarmupParameterImpl> get copyWith =>
      __$$WarmupParameterImplCopyWithImpl<_$WarmupParameterImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$WarmupParameterImplToJson(
      this,
    );
  }
}

abstract class _WarmupParameter implements WarmupParameter {
  const factory _WarmupParameter(
      {required final String name,
      required final List<String> options}) = _$WarmupParameterImpl;

  factory _WarmupParameter.fromJson(Map<String, dynamic> json) =
      _$WarmupParameterImpl.fromJson;

  @override
  String get name;
  @override
  List<String> get options;

  /// Create a copy of WarmupParameter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WarmupParameterImplCopyWith<_$WarmupParameterImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\domain\warmup_item.g.dart ----- 
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'warmup_item.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$WarmupItemImpl _$$WarmupItemImplFromJson(Map<String, dynamic> json) =>
    _$WarmupItemImpl(
      id: json['id'] as String,
      type: json['type'] as String,
      region: json['region'] as String,
      pattern: json['pattern'] as String,
      modality: json['modality'] as String,
      displayName: json['display_name'] as String,
      parameters: (json['parameters'] as List<dynamic>?)
              ?.map((e) => WarmupParameter.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
    );

Map<String, dynamic> _$$WarmupItemImplToJson(_$WarmupItemImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'type': instance.type,
      'region': instance.region,
      'pattern': instance.pattern,
      'modality': instance.modality,
      'display_name': instance.displayName,
      'parameters': instance.parameters,
    };

_$WarmupParameterImpl _$$WarmupParameterImplFromJson(
        Map<String, dynamic> json) =>
    _$WarmupParameterImpl(
      name: json['name'] as String,
      options:
          (json['options'] as List<dynamic>).map((e) => e as String).toList(),
    );

Map<String, dynamic> _$$WarmupParameterImplToJson(
        _$WarmupParameterImpl instance) =>
    <String, dynamic>{
      'name': instance.name,
      'options': instance.options,
    };
----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\dxg\presentation\dxg_exercise_picker_screen.dart ----- 
// ----- lib/src/features/dxg/presentation/dxg_exercise_picker_screen.dart -----
// lib/src/features/dxg/presentation/dxg_exercise_picker_screen.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/dxg/application/dxg_state.dart';
import 'package:fairware_lift/src/features/dxg/application/warmup_service.dart';
import 'package:fairware_lift/src/features/dxg/domain/warmup_item.dart';

// -----------------------------------------------------------------------------
// --- LOCAL STATE PROVIDER ----------------------------------------------------
// -----------------------------------------------------------------------------

enum PickerMode { strength, prep }

final _pickerModeProvider = StateProvider.autoDispose<PickerMode>((ref) {
  return PickerMode.strength;
});

// -----------------------------------------------------------------------------
// --- DXG EXERCISE PICKER SCREEN WIDGET ---------------------------------------
// -----------------------------------------------------------------------------

class DXGExercisePickerScreen extends ConsumerWidget {
  const DXGExercisePickerScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final pickerMode = ref.watch(_pickerModeProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Add to Session'),
        backgroundColor: AppTheme.colors.surface,
        bottom: PreferredSize(
          preferredSize: const Size.fromHeight(56.0),
          child: Padding(
            padding: const EdgeInsets.all(8.0),
            child: SegmentedButton<PickerMode>(
              segments: const [
                ButtonSegment(
                    value: PickerMode.strength,
                    label: Text('Strength'),
                    icon: Icon(Icons.fitness_center)),
                ButtonSegment(
                    value: PickerMode.prep,
                    label: Text('Prep'),
                    icon: Icon(Icons.self_improvement)),
              ],
              selected: {pickerMode},
              onSelectionChanged: (newSelection) {
                ref.read(_pickerModeProvider.notifier).state =
                    newSelection.first;
              },
            ),
          ),
        ),
      ),
      // --- BUG FIX ---
      // The body is now wrapped in a `switch` expression that correctly returns
      // the view based on the picker mode. This ensures the `_buildPrepView` is
      // always rendered when the "Prep" mode is selected.
      body: SafeArea(
        child: switch (pickerMode) {
          PickerMode.strength => _buildStrengthView(context, ref),
          PickerMode.prep => _buildPrepView(context, ref),
        },
      ),
    );
  }

  Widget _buildStrengthView(BuildContext context, WidgetRef ref) {
    final asyncDxgState = ref.watch(dxgStateProvider);

    return asyncDxgState.when(
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, stack) => Center(child: Text('Error: $err')),
      data: (dxgState) {
        return ListView(
          padding: const EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 16.0),
          children: [
            _buildSectionHeader('Family'),
            _buildFamilyChips(ref, dxgState),
            const SizedBox(height: 24),
            _buildDiscriminatorChips(ref, 'Equipment', 'equipment', dxgState),
            _buildDiscriminatorChips(ref, 'Angle / Line', 'angle', dxgState),
            _buildDiscriminatorChips(ref, 'Unilateral', 'unilateral', dxgState),
            _buildDiscriminatorChips(ref, 'Orientation', 'orientation', dxgState),
            _buildDiscriminatorChips(ref, 'Attachment', 'attachment', dxgState),
            _buildDiscriminatorChips(ref, 'Cable Height', 'cable_height', dxgState),
            _buildDiscriminatorChips(ref, 'Grip', 'grip', dxgState),
            if (dxgState.canonicalExercise != null)
              _buildResultCard(context, dxgState.canonicalExercise!),
          ],
        );
      },
    );
  }

  Widget _buildPrepView(BuildContext context, WidgetRef ref) {
    final warmupItemsAsync = ref.watch(warmupItemsProvider);
    return warmupItemsAsync.when(
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, stack) => Center(child: Text('Error: $err')),
      data: (items) {
        return ListView.builder(
          itemCount: items.length,
          itemBuilder: (context, index) {
            final item = items[index];
            return ListTile(
              title: Text(item.displayName),
              subtitle: Text('${item.region} - ${item.modality}'),
              onTap: () async {
                if (item.parameters.isNotEmpty) {
                  final selectedParameters = await _showParameterDialog(context, item);
                  if (selectedParameters != null) {
                    Navigator.of(context).pop({'item': item, 'params': selectedParameters});
                  }
                } else {
                  Navigator.of(context).pop({'item': item, 'params': <String, String>{}});
                }
              },
            );
          },
        );
      },
    );
  }

  Future<Map<String, String>?> _showParameterDialog(
      BuildContext context, WarmupItem item) {
    return showDialog<Map<String, String>>(
      context: context,
      builder: (context) {
        final selections = <String, String>{};
        for (var p in item.parameters) {
          if (p.options.isNotEmpty) {
            selections[p.name] = p.options.first;
          }
        }

        return StatefulBuilder(
          builder: (context, setState) {
            return AlertDialog(
              backgroundColor: AppTheme.colors.surface,
              title: Text(item.displayName),
              content: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: item.parameters.map((param) {
                    return DropdownButtonFormField<String>(
                      value: selections[param.name],
                      items: param.options.map((option) {
                        return DropdownMenuItem(
                          value: option,
                          child: Text(option),
                        );
                      }).toList(),
                      onChanged: (value) {
                        if (value != null) {
                          setState(() => selections[param.name] = value);
                        }
                      },
                      decoration: InputDecoration(labelText: param.name),
                    );
                  }).toList(),
                ),
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: const Text('Cancel'),
                ),
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop(selections);
                  },
                  child: const Text('Add'),
                ),
              ],
            );
          },
        );
      },
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0),
      child: Text(
        title,
        style: AppTheme.typography.title.copyWith(fontSize: 18),
      ),
    );
  }

  Widget _buildFamilyChips(WidgetRef ref, DXGState dxgState) {
    final sortedFamilies = List.from(dxgState.allFamilies)
      ..sort((a, b) => a.name.compareTo(b.name));

    return Wrap(
      spacing: 8.0,
      runSpacing: 4.0,
      children: sortedFamilies.map((family) {
        return FilterChip(
          label: Text(family.name),
          selected: dxgState.selectedFamilyId == family.id,
          onSelected: (_) {
            ref.read(dxgStateProvider.notifier).selectFamily(family.id);
          },
        );
      }).toList(),
    );
  }

  Widget _buildDiscriminatorChips(
    WidgetRef ref,
    String title,
    String field,
    DXGState dxgState,
  ) {
    final options = dxgState.availableOptions[field];
    final bool hasOnlyNoneOption = (options?.length == 1 && options?.first == 'none');

    if (dxgState.selectedFamily == null ||
        options == null ||
        options.isEmpty ||
        hasOnlyNoneOption) {
      return const SizedBox.shrink();
    }
    final selectedValue = dxgState.selections[field];
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionHeader(title),
        Wrap(
          spacing: 8.0,
          runSpacing: 4.0,
          children: options.map((option) {
            return FilterChip(
              label: Text(option),
              selected: selectedValue == option,
              onSelected: (isSelected) {
                final newValue = isSelected ? option : null;
                ref
                    .read(dxgStateProvider.notifier)
                    .updateSelection(field, newValue);
              },
            );
          }).toList(),
        ),
        const SizedBox(height: 24),
      ],
    );
  }

  Widget _buildResultCard(
      BuildContext context, GeneratedExerciseResult result) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionHeader('Result'),
        Card(
          color: AppTheme.colors.surfaceAlt,
          elevation: 0,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
            side: BorderSide(color: AppTheme.colors.accent, width: 2),
          ),
          child: InkWell(
            onTap: () {
              Navigator.of(context).pop(result);
            },
            borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Expanded(
                    child: Text(
                      result.displayName,
                      style: AppTheme.typography.title,
                    ),
                  ),
                  Icon(
                    Icons.add_circle_outline_rounded,
                    color: AppTheme.colors.accent,
                    size: 32,
                  ),
                ],
              ),
            ),
          ),
        ),
      ],
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\exercises\data\exercise_repository.dart ----- 
// lib/src/features/exercises/data/exercise_repository.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart' show rootBundle;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:csv/csv.dart';
import '../domain/exercise.dart';

// -----------------------------------------------------------------------------
// --- EXERCISE REPOSITORY CLASS -----------------------------------------------
// -----------------------------------------------------------------------------

/// A repository responsible for loading and providing the master list of exercises.
class ExerciseRepository {
  final List<Exercise> exercises;

  ExerciseRepository({required this.exercises});

  static Future<ExerciseRepository> create() async {
    final rawCsv = await rootBundle.loadString('assets/data/fairware_exercise_library.csv');

    final List<List<dynamic>> rows = const CsvToListConverter(eol: '\n').convert(
      rawCsv,
      shouldParseNumbers: false,
    );

    final List<Exercise> exercises = [];
    for (int i = 1; i < rows.length; i++) {
      final row = rows[i];
      if (row.length >= 6 && row.any((cell) => cell.toString().trim().isNotEmpty)) {
        try {
          exercises.add(Exercise.fromCsvRow(row));
        } catch (e) {
          debugPrint('Error parsing CSV row $i: $row. Error: $e');
        }
      }
    }

    return ExerciseRepository(exercises: exercises);
  }

  /// Returns the complete list of all available exercises.
  List<Exercise> getAllExercises() {
    return exercises;
  }

  /// --- NEW METHOD ---
  /// Extracts all unique primary muscle groups from the exercise list.
  /// This is used to populate the filter chips in the UI.
  List<String> getUniquePrimaryMuscles() {
    // Use a Set to automatically handle uniqueness.
    final Set<String> muscleSet = {};
    for (final exercise in exercises) {
      // Split muscles that might be comma-separated and add them individually.
      final muscles = exercise.primaryMuscles.split(',').map((e) => e.trim());
      muscleSet.addAll(muscles);
    }
    // Convert the Set to a List and sort it alphabetically.
    final muscleList = muscleSet.toList();
    muscleList.sort();
    return muscleList;
  }
}

// -----------------------------------------------------------------------------
// --- PROVIDER ----------------------------------------------------------------
// -----------------------------------------------------------------------------

final exerciseRepositoryProvider = FutureProvider<ExerciseRepository>((ref) async {
  return await ExerciseRepository.create();
});----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\exercises\data\presentation\exercise_picker_screen.dart ----- 
// lib/src/features/exercises/data/presentation/exercise_picker_screen.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';

// --- FIX ---
// These imports now use the full package path, which is the most reliable
// way to ensure the files are found by the compiler.
import 'package:fairware_lift/src/features/exercises/data/exercise_repository.dart';
import 'package:fairware_lift/src/features/exercises/domain/exercise.dart';

// -----------------------------------------------------------------------------
// --- EXERCISE PICKER SCREEN WIDGET -------------------------------------------
// -----------------------------------------------------------------------------

/// A screen that displays a searchable list of exercises for the user to select.
/// This is now a stateful widget to manage the search query.
class ExercisePickerScreen extends ConsumerStatefulWidget {
  const ExercisePickerScreen({super.key});

  @override
  ConsumerState<ExercisePickerScreen> createState() => _ExercisePickerScreenState();
}

class _ExercisePickerScreenState extends ConsumerState<ExercisePickerScreen> {
  String _searchQuery = '';
  final _searchController = TextEditingController();

  @override
  void initState() {
    super.initState();
    // Update the search query whenever the text in the search bar changes.
    _searchController.addListener(() {
      setState(() {
        _searchQuery = _searchController.text;
      });
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  /// Shows an AlertDialog with the exercise's "how-to" instructions.
  void _showExerciseInfo(BuildContext context, Exercise exercise) {
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          backgroundColor: AppTheme.colors.surface,
          title: Text(exercise.name),
          content: Text(exercise.howTo),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('Close'),
            ),
          ],
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    // Watch the FutureProvider for the exercise repository.
    final exerciseRepoAsync = ref.watch(exerciseRepositoryProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Select Exercise'),
        backgroundColor: AppTheme.colors.surface,
      ),
      body: Column(
        children: [
          // --- SEARCH BAR ---
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: TextField(
              controller: _searchController,
              decoration: InputDecoration(
                hintText: 'Search exercises...',
                prefixIcon: const Icon(Icons.search),
                filled: true,
                fillColor: AppTheme.colors.surface,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
                  borderSide: BorderSide.none,
                ),
              ),
            ),
          ),

          // --- EXERCISE LIST ---
          // Handle the different states of the FutureProvider.
          Expanded(
            child: exerciseRepoAsync.when(
              // --- DATA LOADED STATE ---
              data: (repo) {
                // Filter the full list based on the current search query.
                final allExercises = repo.getAllExercises();
                final filteredExercises = allExercises.where((exercise) {
                  return exercise.name
                      .toLowerCase()
                      .contains(_searchQuery.toLowerCase());
                }).toList();

                return ListView.builder(
                  itemCount: filteredExercises.length,
                  itemBuilder: (context, index) {
                    final exercise = filteredExercises[index];
                    return ListTile(
                      title: Text(exercise.name),
                      // --- NEW INFO BUTTON ---
                      trailing: IconButton(
                        icon: const Icon(Icons.info_outline_rounded),
                        onPressed: () => _showExerciseInfo(context, exercise),
                      ),
                      onTap: () {
                        // Return the selected exercise to the previous screen.
                        Navigator.of(context).pop(exercise);
                      },
                    );
                  },
                );
              },
              // --- LOADING STATE ---
              loading: () => const Center(child: CircularProgressIndicator()),
              // --- ERROR STATE ---
              error: (err, stack) => Center(child: Text('Error: $err')),
            ),
          ),
        ],
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\exercises\domain\exercise.dart ----- 
// lib/src/features/exercises/domain/exercise.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/foundation.dart';

// -----------------------------------------------------------------------------
// --- EXERCISE DATA MODEL -----------------------------------------------------
// -----------------------------------------------------------------------------

/// An immutable data class representing a single exercise definition from the library.
///
/// This model holds all the detailed information for an exercise, parsed from
/// the `fairware_exercise_library.csv` asset.
@immutable
class Exercise {
  final String name;
  final String equipment;
  final String movementPattern;
  final String primaryMuscles;
  final String secondaryMuscles;
  final String howTo;
  final String? defaultSetType;

  const Exercise({
    required this.name,
    required this.equipment,
    required this.movementPattern,
    required this.primaryMuscles,
    required this.secondaryMuscles,
    required this.howTo,
    this.defaultSetType,
  });

  /// A factory constructor to create an Exercise instance from a CSV row (represented as a List<dynamic>).
  factory Exercise.fromCsvRow(List<dynamic> row) {
    return Exercise(
      name: row[0].toString(),
      equipment: row[1].toString(),
      movementPattern: row[2].toString(),
      primaryMuscles: row[3].toString(),
      secondaryMuscles: row[4].toString(),
      howTo: row[5].toString(),
      defaultSetType: row.length > 6 ? row[6].toString().trim().isEmpty ? null : row[6].toString().trim() : null,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Exercise &&
          runtimeType == other.runtimeType &&
          name == other.name;

  @override
  int get hashCode => name.hashCode;

  @override
  String toString() {
    return 'Exercise{name: $name}';
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\history\application\history_state.dart ----- 
// lib/src/features/history/application/history_state.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/theme/data/local/database.dart';

// -----------------------------------------------------------------------------
// --- HISTORY STATE NOTIFIER --------------------------------------------------
// -----------------------------------------------------------------------------

/// --- REFACTORED ---
/// This is now an AsyncNotifier, which allows us to manage an async state
/// that can be modified by UI interactions (like deleting an item).
class HistoryStateNotifier extends AsyncNotifier<List<FullWorkoutSession>> {
  /// The `build` method is called to provide the initial state. It fetches
  /// the complete workout history from the database.
  @override
  Future<List<FullWorkoutSession>> build() async {
    final db = ref.watch(databaseProvider);
    return db.getWorkoutHistory();
  }

  /// --- NEW METHOD ---
  /// Deletes a workout session from the database and then removes it from the
  /// current state, causing the UI to update automatically.
  Future<void> deleteWorkout(String sessionId) async {
    final db = ref.read(databaseProvider);

    // Perform the delete operation in the database.
    await db.deleteWorkoutSession(sessionId);

    // Update the in-memory state to reflect the deletion.
    // This avoids having to re-fetch the entire list from the database.
    state = await AsyncValue.guard(() async {
      final currentState = state.value ?? [];
      // Create a new list that excludes the deleted session.
      return currentState.where((workout) => workout.session.id != sessionId).toList();
    });
  }
}

// -----------------------------------------------------------------------------
// --- HISTORY STATE PROVIDER --------------------------------------------------
// -----------------------------------------------------------------------------

/// --- REFACTORED ---
/// The provider is now an `AsyncNotifierProvider`, which gives us an instance
/// of our `HistoryStateNotifier` and exposes its state.
final workoutHistoryProvider =
    AsyncNotifierProvider<HistoryStateNotifier, List<FullWorkoutSession>>(
  HistoryStateNotifier.new,
);----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\history\presentation\history_screen.dart ----- 
// ----- lib/src/features/history/presentation/history_screen.dart -----
// lib/src/features/history/presentation/history_screen.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/history/application/history_state.dart';
import 'package:fairware_lift/src/core/theme/data/local/database.dart';
import 'package:collection/collection.dart';
import 'package:intl/intl.dart';

// -----------------------------------------------------------------------------
// --- HISTORY SCREEN WIDGET ---------------------------------------------------
// -----------------------------------------------------------------------------

class HistoryScreen extends ConsumerWidget {
  const HistoryScreen({super.key});

  String _formatDuration(int totalSeconds) {
    if (totalSeconds < 0) return "0s";
    final duration = Duration(seconds: totalSeconds);
    final hours = duration.inHours;
    final minutes = duration.inMinutes.remainder(60);
    final seconds = duration.inSeconds.remainder(60);
    final parts = <String>[];
    if (hours > 0) parts.add('${hours}h');
    if (minutes > 0) parts.add('${minutes}m');
    if (seconds > 0 || parts.isEmpty) parts.add('${seconds}s');
    return parts.join(' ');
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final historyAsync = ref.watch(workoutHistoryProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('History'),
        backgroundColor: AppTheme.colors.background,
        elevation: 0,
      ),
      body: historyAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (err, stack) => Center(child: Text('Error: $err')),
        data: (workouts) {
          if (workouts.isEmpty) {
            return _buildEmptyState();
          }
          return ListView.builder(
            padding: const EdgeInsets.all(8.0),
            itemCount: workouts.length,
            itemBuilder: (context, index) {
              final workout = workouts[index];
              return Dismissible(
                key: ValueKey(workout.session.id),
                direction: DismissDirection.endToStart,
                background: _buildDismissBackground(),
                confirmDismiss: (direction) async {
                  return await _showDeleteConfirmationDialog(context);
                },
                onDismissed: (direction) {
                  ref
                      .read(workoutHistoryProvider.notifier)
                      .deleteWorkout(workout.session.id);
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Workout deleted')),
                  );
                },
                child: _buildWorkoutCard(context, workout),
              );
            },
          );
        },
      ),
    );
  }

  Widget _buildDismissBackground() {
    return Container(
      color: AppTheme.colors.danger,
      margin: const EdgeInsets.symmetric(vertical: 4.0),
      padding: const EdgeInsets.symmetric(horizontal: 20.0),
      alignment: Alignment.centerRight,
      child: const Icon(
        Icons.delete_forever_rounded,
        color: Colors.white,
      ),
    );
  }

  Future<bool?> _showDeleteConfirmationDialog(BuildContext context) {
    return showDialog<bool>(
      context: context,
      builder: (context) {
        return AlertDialog(
          backgroundColor: AppTheme.colors.surface,
          title: const Text('Delete Workout?'),
          content: const Text('This action cannot be undone.'),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: Text(
                'Delete',
                style: TextStyle(color: AppTheme.colors.danger),
              ),
            ),
          ],
        );
      },
    );
  }

  Widget _buildWorkoutCard(BuildContext context, FullWorkoutSession workout) {
    final setsByExercise =
        groupBy(workout.sets, (setWithExercise) => setWithExercise.exercise);
    final totalItems = setsByExercise.keys.length + workout.warmups.length;

    final subtitleParts = <String>[
      '$totalItems items',
      '${workout.sets.length} total sets',
    ];
    if (workout.session.totalDurationSeconds != null) {
      subtitleParts.add(_formatDuration(workout.session.totalDurationSeconds!));
    }
    final subtitle = subtitleParts.join('    ');

    return Card(
      color: AppTheme.colors.surface,
      margin: const EdgeInsets.symmetric(vertical: 4.0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
      ),
      child: ExpansionTile(
        title: Text(
          DateFormat.yMMMMd().add_jm().format(workout.session.sessionDateTime),
          style: AppTheme.typography.title.copyWith(fontSize: 18),
        ),
        subtitle: Text(
          subtitle,
          style: AppTheme.typography.caption,
        ),
        childrenPadding: const EdgeInsets.all(16.0),
        children: [
          // --- REFACTORED ---
          // Now displays all three timing metrics if they are available.
          if (workout.session.totalDurationSeconds != null) ...[
            _buildTimingDetails(
              totalDuration: workout.session.totalDurationSeconds!,
              totalActivity: workout.session.totalActivitySeconds ?? 0,
              totalRest: workout.session.totalRestSeconds ?? 0,
            ),
            const Divider(height: 24),
          ],
          ...workout.warmups.map((warmup) => _buildWarmupSummary(warmup)),
          ...setsByExercise.entries.map((entry) {
            final exercise = entry.key;
            final sets = entry.value;
            return _buildExerciseSummary(context, exercise, sets);
          }),
        ],
      ),
    );
  }

  Widget _buildTimingDetails({required int totalDuration, required int totalActivity, required int totalRest}) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceAround,
        children: [
          Column(
            children: [
              Text('Duration', style: AppTheme.typography.caption),
              const SizedBox(height: 4),
              Text(_formatDuration(totalDuration), style: AppTheme.typography.body),
            ],
          ),
          Column(
            children: [
              Text('Activity', style: AppTheme.typography.caption),
              const SizedBox(height: 4),
              Text(_formatDuration(totalActivity), style: AppTheme.typography.body),
            ],
          ),
          Column(
            children: [
              Text('Rest', style: AppTheme.typography.caption),
              const SizedBox(height: 4),
              Text(_formatDuration(totalRest), style: AppTheme.typography.body),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildWarmupSummary(SavedWarmup warmup) {
    final subtitle = warmup.parameters.entries
        .map((e) => '${e.key}: ${e.value}')
        .join('    ');

    return Padding(
      padding: const EdgeInsets.only(bottom: 12.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            warmup.displayName,
            style: AppTheme.typography.body
                .copyWith(color: AppTheme.colors.textSecondary),
          ),
          if (subtitle.isNotEmpty) ...[
            const SizedBox(height: 4),
            Text(
              subtitle,
              style: AppTheme.typography.caption,
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildExerciseSummary(BuildContext context, ExerciseInstance exercise,
      List<SetEntryWithExercise> sets) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Expanded(
                child: Text(
                  exercise.displayName,
                  style: AppTheme.typography.body.copyWith(
                    fontWeight: FontWeight.bold,
                    color: AppTheme.colors.textPrimary,
                  ),
                ),
              ),
              IconButton(
                icon: const Icon(Icons.info_outline_rounded),
                onPressed: () => _showExerciseInfoDialog(context, exercise),
                color: AppTheme.colors.textMuted,
                padding: EdgeInsets.zero,
                constraints: const BoxConstraints(),
              ),
            ],
          ),
          const SizedBox(height: 4),
          ...sets.map((setWithExercise) {
            final set = setWithExercise.set;
            return Text(
              '    ${set.weight} lb x ${set.reps} reps',
              style: AppTheme.typography.body,
            );
          }),
        ],
      ),
    );
  }

  void _showExerciseInfoDialog(
      BuildContext context, ExerciseInstance exercise) {
    String _formatTitle(String key) =>
        '${key[0].toUpperCase()}${key.substring(1)}'.replaceAll('_', ' ');

    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          backgroundColor: AppTheme.colors.surface,
          title: Text(exercise.displayName),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: exercise.discriminators.entries.map((entry) {
              return Padding(
                padding: const EdgeInsets.symmetric(vertical: 4.0),
                child: RichText(
                  text: TextSpan(
                    style: AppTheme.typography.body,
                    children: [
                      TextSpan(
                        text: '${_formatTitle(entry.key)}: ',
                        style: const TextStyle(fontWeight: FontWeight.bold),
                      ),
                      TextSpan(text: entry.value),
                    ],
                  ),
                ),
              );
            }).toList(),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('Close'),
            ),
          ],
        );
      },
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 32.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.bar_chart_rounded,
              size: 80,
              color: AppTheme.colors.textMuted,
            ),
            const SizedBox(height: 24),
            Text(
              'No workouts logged yet.',
              style: AppTheme.typography.title.copyWith(
                color: AppTheme.colors.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\llm_prompting\application\prompt_generation_service.dart ----- 
// lib/src/features/llm_prompting/application/prompt_generation_service.dart

// This file is now deprecated and its functionality has been migrated to
// lib/src/features/prompt_studio/application/prompt_compiler.dart
// It will be removed in a future cleanup.----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\llm_prompting\presentation\llm_intake_screen.dart ----- 
// lib/src/features/llm_prompting/presentation/llm_intake_screen.dart

// This file is now deprecated and its functionality has been migrated to
// lib/src/features/prompt_studio/presentation/sheets/coach_setup_sheet.dart
// It will be removed in a future cleanup.----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\measurements\data\measurements_repository.dart ----- 
// lib/src/features/measurements/data/measurements_repository.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

// -----------------------------------------------------------------------------
// --- CONSTANTS ---------------------------------------------------------------
// -----------------------------------------------------------------------------

const String _kLatestBodyweightKey = 'latest_bodyweight_lbs';

// -----------------------------------------------------------------------------
// --- MEASUREMENTS REPOSITORY -------------------------------------------------
// -----------------------------------------------------------------------------

/// A repository for saving and retrieving user measurement data.
class MeasurementsRepository {
  final SharedPreferences _prefs;

  MeasurementsRepository(this._prefs);

  /// Saves the user's most recent bodyweight.
  Future<void> saveLatestBodyweight(double weightLbs) async {
    await _prefs.setDouble(_kLatestBodyweightKey, weightLbs);
  }

  /// Retrieves the user's most recent bodyweight.
  double? getLatestBodyweight() {
    return _prefs.getDouble(_kLatestBodyweightKey);
  }
}

// -----------------------------------------------------------------------------
// --- PROVIDERS ---------------------------------------------------------------
// -----------------------------------------------------------------------------

/// Provider for SharedPreferences, used by other providers in this file.
final _sharedPreferencesProvider =
    FutureProvider<SharedPreferences>((ref) => SharedPreferences.getInstance());

/// --- MODIFIED: Now a FutureProvider to handle async initialization ---
/// Provider for the MeasurementsRepository.
final measurementsRepositoryProvider = FutureProvider<MeasurementsRepository>((ref) async {
  // Asynchronously watch the SharedPreferences provider.
  final prefs = await ref.watch(_sharedPreferencesProvider.future);
  return MeasurementsRepository(prefs);
});

/// A simple StateProvider to hold the latest bodyweight, allowing the UI to
/// reactively update when a new measurement is saved.
final latestBodyweightProvider = StateProvider<double?>((ref) {
  // This will now rebuild correctly when the repository provider re-evaluates.
  return ref.watch(measurementsRepositoryProvider).value?.getLatestBodyweight();
});----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\measurements\presentation\add_measurement_sheet.dart ----- 
// lib/src/features/measurements/presentation/add_measurement_sheet.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/measurements/data/measurements_repository.dart';

// -----------------------------------------------------------------------------
// --- ADD MEASUREMENT SHEET WIDGET --------------------------------------------
// -----------------------------------------------------------------------------

class AddMeasurementSheet extends ConsumerStatefulWidget {
  const AddMeasurementSheet({super.key});

  @override
  ConsumerState<AddMeasurementSheet> createState() =>
      _AddMeasurementSheetState();
}

class _AddMeasurementSheetState extends ConsumerState<AddMeasurementSheet> {
  final _weightController = TextEditingController();

  @override
  void initState() {
    super.initState();
    // Pre-fill the text field with the current weight if it exists.
    final currentWeight = ref.read(latestBodyweightProvider);
    if (currentWeight != null) {
      _weightController.text = currentWeight.toString();
    }
  }

  @override
  void dispose() {
    _weightController.dispose();
    super.dispose();
  }

  void _onSave() async {
    final weight = double.tryParse(_weightController.text);
    if (weight == null || weight <= 0) {
      // Optional: show a snackbar for invalid input
      return;
    }

    // Use the repository to save the data
    final repo = ref.read(measurementsRepositoryProvider).value;
    if (repo == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Error: Repository not ready.')),
      );
      return;
    }
    await repo.saveLatestBodyweight(weight);

    // Update the state provider to trigger a UI rebuild
    ref.read(latestBodyweightProvider.notifier).state = weight;

    if (mounted) {
      Navigator.of(context).pop();
    }
  }

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
          left: 16,
          right: 16,
          top: 16,
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: _weightController,
              keyboardType:
                  const TextInputType.numberWithOptions(decimal: true),
              textAlign: TextAlign.center,
              style: AppTheme.typography.number,
              autofocus: true,
              decoration: InputDecoration(
                labelText: 'Bodyweight (lbs)',
                labelStyle: AppTheme.typography.body,
                filled: true,
                fillColor: AppTheme.colors.surface,
                border: OutlineInputBorder(
                  borderRadius:
                      BorderRadius.circular(AppTheme.sizing.cardRadius),
                  borderSide: BorderSide.none,
                ),
              ),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: _onSave,
              style: ElevatedButton.styleFrom(
                minimumSize: const Size(double.infinity, 50),
              ),
              child: const Text('Save Measurement'),
            ),
          ],
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\measurements\presentation\measurements_screen.dart ----- 
// lib/src/features/measurements/presentation/measurements_screen.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/measurements/data/measurements_repository.dart';
import 'package:fairware_lift/src/features/measurements/presentation/add_measurement_sheet.dart';

// -----------------------------------------------------------------------------
// --- MEASUREMENTS SCREEN WIDGET ----------------------------------------------
// -----------------------------------------------------------------------------

class MeasurementsScreen extends ConsumerWidget {
  const MeasurementsScreen({super.key});

  void _showAddMeasurementSheet(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: AppTheme.colors.surface,
      builder: (context) => const AddMeasurementSheet(),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // --- MODIFIED: Watch the async provider to handle loading state ---
    final asyncRepo = ref.watch(measurementsRepositoryProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Measurements'),
        backgroundColor: AppTheme.colors.background,
        elevation: 0,
      ),
      body: asyncRepo.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (err, stack) => Center(child: Text('Error: $err')),
        data: (_) {
          // Once the repo is ready, watch the latest weight.
          final latestWeight = ref.watch(latestBodyweightProvider);
          return Center(
            child: Padding(
              padding: EdgeInsets.symmetric(
                horizontal: AppTheme.sizing.baseGrid * 4, // 32pt
              ),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.monitor_weight_rounded,
                    size: 80,
                    color: AppTheme.colors.textMuted,
                  ),
                  const SizedBox(height: 24),
                  if (latestWeight == null)
                    Text(
                      'No measurements yet.',
                      style: AppTheme.typography.title.copyWith(
                        color: AppTheme.colors.textSecondary,
                      ),
                      textAlign: TextAlign.center,
                    )
                  else
                    Text(
                      'Latest Weight: ${latestWeight.toStringAsFixed(1)} lbs',
                      style: AppTheme.typography.title.copyWith(
                        color: AppTheme.colors.textSecondary,
                      ),
                      textAlign: TextAlign.center,
                    ),
                  const SizedBox(height: 24),
                  ElevatedButton.icon(
                    onPressed: () => _showAddMeasurementSheet(context),
                    icon: const Icon(Icons.add_circle_outline_rounded),
                    label: Text(latestWeight == null
                        ? 'Add Measurement'
                        : 'Update Measurement'),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\programs\presentation\programs_screen.dart ----- 
// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

// Core Flutter material design library.
import 'package:flutter/material.dart';

// The application's design system for consistent styling.
import 'package:fairware_lift/src/core/theme/app_theme.dart';

// -----------------------------------------------------------------------------
// --- PROGRAMS SCREEN WIDGET --------------------------------------------------
// -----------------------------------------------------------------------------

/// The screen for managing user-created workout programs.
///
/// As defined in the SSOT, this screen will list all of the user's programs.
/// This implementation shows the "Empty State" UI (SSOT 5.1) which is displayed
/// when the user has not created any programs yet.
class ProgramsScreen extends StatelessWidget {
  const ProgramsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    // A Scaffold provides the basic visual layout structure for the screen.
    return Scaffold(
      appBar: AppBar(
        title: const Text('Programs'),
        backgroundColor: AppTheme.colors.background,
        elevation: 0,
      ),
      // The body is centered to hold the empty state content.
      body: Center(
        child: Padding(
          // Horizontal padding to keep content from touching screen edges.
          padding: EdgeInsets.symmetric(
            horizontal: AppTheme.sizing.baseGrid * 4, // 32pt
          ),
          child: Column(
            // Center the content vertically.
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // --- ILLUSTRATION PLACEHOLDER ---
              // A placeholder for a future illustration. An icon is used for now.
              Icon(
                Icons.list_alt_rounded,
                size: 80,
                color: AppTheme.colors.textMuted,
              ),
              const SizedBox(height: 24),

              // --- EMPTY STATE MESSAGE ---
              // The message text as specified in SSOT 5.1.
              Text(
                'No programs. Start from a template or create your own.',
                style: AppTheme.typography.title.copyWith(
                  color: AppTheme.colors.textSecondary,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),

              // --- CALL TO ACTION (CTA) BUTTON ---
              // The CTA to guide the user to the next step.
              ElevatedButton.icon(
                onPressed: () {
                  // TODO: Implement navigation to the program builder.
                  print('Create Program button pressed!');
                },
                icon: const Icon(Icons.add_circle_outline_rounded),
                label: const Text('Create Program'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\prompt_studio\application\prompt_compiler.dart ----- 
// lib/src/features/prompt_studio/application/prompt_compiler.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/features/user_profile/domain/user_profile.dart';

// -----------------------------------------------------------------------------
// --- PROMPT COMPILER SERVICE -------------------------------------------------
// -----------------------------------------------------------------------------

/// A service responsible for compiling user data and context into structured,
/// ready-to-paste prompts for external LLMs.
class PromptCompiler {
  /// Compiles the initial "Onboard New LLM" prompt based on the full spec.
  String compileCoachSetupPrompt(UserProfile profile) {
    final weightKg = (profile.weightLbs ?? 0) * 0.453592;
    final weightConversionNote = profile.weightLbs != null ? ' (auto-converted from lbs)' : '';

    const systemSection = """
SYSTEM:
You are Fairware Lifts AI Coach  a professional personal trainer who combines human-like conversation with data-driven precision.

You operate in two phases:

PHASE 1  INTERVIEW MODE
- Start by greeting the client warmly.
- Ask open, natural follow-up questions to learn about them before programming.
- Cover training history, goals, schedule, equipment, preferences, recovery, and motivation.
- Specifically ask if they want a warm-up included and, if so, for how long (e.g., 5-10 minutes).
- Keep the tone friendly and encouraging, never robotic.
- Summarize what youve learned and ask, Would you like me to start designing your first plan?

PHASE 2  WORKOUT FORMATTER MODE
- When the client says Yes or Lets start, switch immediately to Workout Formatter behavior.
- Output ONLY valid JSON strictly matching the schema below.
- Never return conversational text once in this mode.
""";

    final populatedUserContext = """
USER CONTEXT
- Name: ${profile.name ?? 'not specified'}
- Age: ${profile.age?.toString() ?? 'not specified'}
- Body weight: ${weightKg.toStringAsFixed(1)} kg$weightConversionNote
- Training age: ${profile.trainingAge ?? 'not specified'}
- Known 1RMs: ${profile.json1RMs ?? 'not specified'}
- HR zones: Z2 ${profile.z2LowBpm?.toString() ?? 'not set'}${profile.z2HighBpm?.toString() ?? 'not set'} bpm
- Constraints: ${profile.constraints ?? 'none'}
- Equipment available: ${profile.equipmentAvailable?.join(', ') ?? 'not specified'}
- Goal today: a balanced workout
- Session length cap: ${profile.timePerSessionMinutes?.toString() ?? '60'} minutes
- Motivation style: ${profile.motivationStyle ?? 'Science-y'}
""";

    const contractSection = """
CONTRACT (exact shape)
{
  "version": "lift.v1",
  "workout": {
    "title": "string",
    "notes": "string optional",
    "blocks": [
      {
        "type": "straight|superset|triset|warmup|finisher",
        "label": "string optional",
        "rounds": "int optional (for superset/triset)",
        "exercises": [
          {
            "name": "string",
            "variation": {
              "freeform keys like": "grip, stance, position, tempo, implement, angle, side, assist, benchAngle, rangeCue, hold_seconds_top, hold_seconds_bottom"
            },
            "prescription": {
              "setType": { "enum": ["weight_reps", "timed", "reps_only"] },
              "sets": "int optional unless type=straight",
              "reps": "int | 'lowhigh' | 'X/side' | 'AMRAP' | 'AMRAP-N'",
              "intensity": { "type": "RPE|percent_1RM|load|rir", "target|value|kg|lb|rir": "numbers optional" },
              "rest_seconds": "int optional",
              "rest_seconds_after": "int optional",
              "note": "string optional"
            },
            "info": {
              "how_to": "string optional (24 sentences: setup  execution  finish; cues-first)",
              "coaching_cues": ["string... optional (36 bullets)"],
              "common_errors": ["string... optional (25 bullets)"],
              "safety_notes": "string optional",
              "video_search_query": "string optional (ideal YouTube search)",
              "web_search_query": "string optional (ideal general web search)",
              "regression": "string optional (make it easier)",
              "progression": "string optional (make it harder)",
              "equipment_notes": "string optional"
            },
            "metadata": {
              "aliases": ["string..."],
              "equipment": ["string..."],
              "primary_muscles": ["string..."]
            }
          }
        ]
      }
    ]
  }
}
""";

    // --- MODIFIED: More forceful instructions for setType ---
    const behaviorSection = """
REQUIRED BEHAVIOR
- Use only available equipment; respect the minutes cap.
- Fill sets, reps, intensity, and rest so the workout is runnable now.
- **THIS IS A CRITICAL, NON-NEGOTIABLE RULE: For each exercise, you MUST set the `prescription.setType` field.**
  - Use `"weight_reps"` for any exercise where the user lifts an external weight (e.g., Barbell Bench Press, DB Curl, Leg Press).
  - Use `"timed"` for cardio (Treadmill, Bike, Rower), planks, or loaded carries (Farmer's Walk).
  - Use `"reps_only"` for any bodyweight exercise where only reps are tracked (e.g., Push-Up, Pull-Up, Bodyweight Squat, Dips).
- For `"reps_only"` or `"timed"` exercises, **DO NOT** include a `load`, `kg`, or `lb` key in the `intensity` object.
- If 1RMs unknown, prefer RPE/RIR over percent_1RM.
- For unilateral work, use reps like "10/side".
- Use simple, common exercise names for the `name` field. Use the `metadata.aliases` field for variations like "BB Bench Press".
- Populate info.* fields so the apps  panel is useful; search queries should be copy-ready (no URLs).
""";

    const defaultsSection = """
DEFAULTS THE MODEL MAY APPLY
- Straight: sets=3, reps="812", intensity={"type":"RPE","target":7}, rest_seconds=90
- Superset: rounds=3 if sets omitted; rest_seconds_after=0 between A1A2, 120 between rounds
- Accessories tempo default "3-1-1" if not specified
""";

    const sessionKickoffSection = """
SESSION KICKOFF
Begin in Interview Mode.
Greet the client casually (use their name if known) and ask your first question about their training goals or current routine.
Do not generate any JSON until the client explicitly says theyre ready to start workouts.
""";

    // Assemble the final prompt with enhanced separators.
    return [
      systemSection.trim(),
      populatedUserContext.trim(),
      contractSection.trim(),
      behaviorSection.trim(),
      defaultsSection.trim(),
      sessionKickoffSection.trim(),
    ].join('\n\n---\n\n');
  }

  String compileDataWhispererPrompt() {
    // Placeholder for future implementation
    return "SYSTEM: You are Fairware Lift's Data Analyst...";
  }

  String compileCoachSwitchboardPrompt() {
    // Placeholder for future implementation
    return "SYSTEM: You are Fairware Lift's Coach Assistant...";
  }
}

final promptCompilerProvider = Provider<PromptCompiler>((ref) {
  return PromptCompiler();
});----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\prompt_studio\presentation\prompt_studio_page.dart ----- 
// lib/src/features/prompt_studio/presentation/prompt_studio_page.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/prompt_studio/presentation/widgets/prompt_card.dart';
import 'package:fairware_lift/src/features/prompt_studio/presentation/sheets/coach_setup_sheet.dart';
import 'package:fairware_lift/src/features/prompt_studio/presentation/sheets/data_whisperer_sheet.dart';
import 'package:fairware_lift/src/features/prompt_studio/presentation/sheets/coach_switchboard_sheet.dart';

// -----------------------------------------------------------------------------
// --- PROMPT STUDIO PAGE WIDGET -----------------------------------------------
// -----------------------------------------------------------------------------

/// The main page for the "Prompt Studio" feature, acting as a creative hub.
class PromptStudioPage extends StatelessWidget {
  const PromptStudioPage({super.key});

  /// A helper method to show a builder sheet modally.
  void _showBuilderSheet(BuildContext context, Widget sheet) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => DraggableScrollableSheet(
        initialChildSize: 0.85,
        maxChildSize: 0.95,
        minChildSize: 0.5,
        builder: (_, scrollController) => Container(
          decoration: BoxDecoration(
            color: const Color(0xFF181818), // bg.surface
            borderRadius: BorderRadius.vertical(top: Radius.circular(AppTheme.sizing.cardRadius)),
          ),
          child: sheet,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Prompt Studio'),
        centerTitle: true,
        bottom: PreferredSize(
          preferredSize: const Size.fromHeight(20.0),
          child: Text(
            'Build prompts that talk your language. Copy  Paste  Coach.',
            style: AppTheme.typography.caption,
          ),
        ),
        backgroundColor: AppTheme.colors.background,
        elevation: 0,
      ),
      body: ListView(
        padding: const EdgeInsets.all(16.0),
        children: [
          PromptCard(
            title: 'Coach Setup',
            subtitle: 'Build your AIs first impression.',
            // --- MODIFIED: Reverted to IconData and unified color ---
            icon: Icons.person_add_alt_1_rounded,
            color: AppTheme.colors.accentRust,
            onTap: () => _showBuilderSheet(context, const CoachSetupSheet()),
          ),
          const SizedBox(height: 16),
          PromptCard(
            title: 'Data Whisperer',
            subtitle: 'Turn logs into insights.',
            // --- MODIFIED: Reverted to IconData and unified color ---
            icon: Icons.insights_rounded,
            color: AppTheme.colors.accentRust,
            onTap: () => _showBuilderSheet(context, const DataWhispererSheet()),
          ),
          const SizedBox(height: 16),
          PromptCard(
            title: 'Coach Switchboard',
            subtitle: 'Bring a new model up to speed.',
            // --- MODIFIED: Reverted to IconData and unified color ---
            icon: Icons.sync_alt_rounded,
            color: AppTheme.colors.accentRust,
            onTap: () => _showBuilderSheet(context, const CoachSwitchboardSheet()),
          ),
        ],
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\prompt_studio\presentation\sheets\coach_setup_sheet.dart ----- 
// lib/src/features/prompt_studio/presentation/sheets/coach_setup_sheet.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/user_profile/application/user_profile_service.dart';
import 'package:fairware_lift/src/features/user_profile/domain/user_profile.dart';
import 'package:fairware_lift/src/features/prompt_studio/application/prompt_compiler.dart';

// -----------------------------------------------------------------------------
// --- COACH SETUP SHEET WIDGET ------------------------------------------------
// -----------------------------------------------------------------------------

class CoachSetupSheet extends ConsumerStatefulWidget {
  const CoachSetupSheet({super.key});

  @override
  ConsumerState<CoachSetupSheet> createState() => _CoachSetupSheetState();
}

class _CoachSetupSheetState extends ConsumerState<CoachSetupSheet> {
  final _formKey = GlobalKey<FormState>();
  late UserProfile _profile;

  @override
  void initState() {
    super.initState();
    // Initialize the form with existing user data or a new profile.
    _profile = ref.read(userProfileProvider).value ?? const UserProfile();
  }

  void _generatePrompt() {
    if (_formKey.currentState!.validate()) {
      _formKey.currentState!.save();
      // Save the updated profile.
      ref.read(userProfileProvider.notifier).save(_profile);
      // Compile the prompt using the new service.
      final prompt = ref.read(promptCompilerProvider).compileCoachSetupPrompt(_profile);
      _showPromptDialog(prompt);
    }
  }

  void _showPromptDialog(String prompt) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: AppTheme.colors.surface,
        title: const Text('Your Onboarding Prompt'),
        content: SingleChildScrollView(
          child: Text(prompt, style: const TextStyle(fontFamily: 'monospace')),
        ),
        actions: [
          TextButton(
            onPressed: () {
              Clipboard.setData(ClipboardData(text: prompt));
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Prompt copied to clipboard!')),
              );
            },
            child: const Text('Copy to Clipboard'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.transparent,
      appBar: AppBar(
        title: const Text('Meet Your New Coach '),
        backgroundColor: Colors.transparent,
        elevation: 0,
        automaticallyImplyLeading: false,
        centerTitle: true,
      ),
      body: Form(
        key: _formKey,
        child: ListView(
          padding: const EdgeInsets.symmetric(horizontal: 24.0),
          children: [
            Text(
              "We'll write your AI intro  you fill in the details.",
              textAlign: TextAlign.center,
              style: AppTheme.typography.body,
            ),
            const SizedBox(height: 24),
            _buildSectionHeader('About You'),
            Row(
              children: [
                Expanded(child: _buildTextFormField(
                  label: 'Name',
                  initialValue: _profile.name,
                  onSaved: (value) => _profile = _profile.copyWith(name: value),
                )),
                const SizedBox(width: 16),
                Expanded(child: _buildTextFormField(
                  label: 'Age',
                  initialValue: _profile.age?.toString(),
                  keyboardType: TextInputType.number,
                  onSaved: (value) => _profile = _profile.copyWith(age: int.tryParse(value ?? '')),
                )),
                const SizedBox(width: 16),
                Expanded(child: _buildTextFormField(
                  label: 'Weight (lbs)',
                  initialValue: _profile.weightLbs?.toString(),
                  keyboardType: const TextInputType.numberWithOptions(decimal: true),
                  onSaved: (value) => _profile = _profile.copyWith(weightLbs: double.tryParse(value ?? '')),
                )),
              ],
            ),
            const SizedBox(height: 24),
            _buildSectionHeader('Motivation Style'),
            Wrap(
              spacing: 8.0,
              runSpacing: 8.0,
              children: ['Chill', 'Science-y', 'Hype', 'Drill Serg.'].map((style) {
                return ChoiceChip(
                  label: Text(style),
                  selected: _profile.motivationStyle == style,
                  onSelected: (selected) {
                    setState(() {
                      _profile = _profile.copyWith(motivationStyle: selected ? style : null);
                    });
                  },
                  backgroundColor: AppTheme.colors.surface,
                  selectedColor: AppTheme.colors.accentRust,
                  labelStyle: TextStyle(
                    color: _profile.motivationStyle == style
                        ? AppTheme.colors.textPrimary
                        : AppTheme.colors.textSecondary,
                  ),
                );
              }).toList(),
            ),
            // ... Add other form sections here ...
            const SizedBox(height: 100), // Space for the floating button
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: _generatePrompt,
        backgroundColor: AppTheme.colors.accentRust,
        icon: const Icon(Icons.preview_rounded),
        label: const Text('Generate Preview'),
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12.0),
      child: Text(
        title,
        style: AppTheme.typography.body.copyWith(fontWeight: FontWeight.bold),
      ),
    );
  }

  Widget _buildTextFormField({
    required String label,
    String? initialValue,
    required FormFieldSetter<String> onSaved,
    TextInputType? keyboardType,
  }) {
    return TextFormField(
      initialValue: initialValue,
      onSaved: onSaved,
      keyboardType: keyboardType,
      decoration: InputDecoration(
        labelText: label,
        labelStyle: AppTheme.typography.body.copyWith(color: AppTheme.colors.textMuted),
        filled: true,
        fillColor: AppTheme.colors.surfaceAlt,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\prompt_studio\presentation\sheets\coach_switchboard_sheet.dart ----- 
 // lib/src/features/prompt_studio/presentation/sheets/coach_switchboard_sheet.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';

// -----------------------------------------------------------------------------
// --- COACH SWITCHBOARD SHEET WIDGET ------------------------------------------
// -----------------------------------------------------------------------------

/// A bottom sheet for the "Coach Switchboard" prompt builder.
///
/// This widget will display the auto-summary and generate the re-onboarding prompt.
/// This is the initial scaffold.
class CoachSwitchboardSheet extends StatelessWidget {
  const CoachSwitchboardSheet({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.transparent,
      appBar: AppBar(
        title: const Text('Switching Coaches '),
        backgroundColor: Colors.transparent,
        elevation: 0,
        automaticallyImplyLeading: false,
        centerTitle: true,
      ),
      body: Center(
        child: Text(
          'Coach Switchboard UI Goes Here',
          style: AppTheme.typography.title,
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\prompt_studio\presentation\sheets\data_whisperer_sheet.dart ----- 
 // lib/src/features/prompt_studio/presentation/sheets/data_whisperer_sheet.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';

// -----------------------------------------------------------------------------
// --- DATA WHISPERER SHEET WIDGET ---------------------------------------------
// -----------------------------------------------------------------------------

/// A bottom sheet for the "Data Whisperer" prompt builder.
///
/// This widget will contain the form for generating data analysis prompts.
/// This is the initial scaffold.
class DataWhispererSheet extends StatelessWidget {
  const DataWhispererSheet({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.transparent,
      appBar: AppBar(
        title: const Text('Ask Your Data Anything '),
        backgroundColor: Colors.transparent,
        elevation: 0,
        automaticallyImplyLeading: false,
        centerTitle: true,
      ),
      body: Center(
        child: Text(
          'Data Whisperer Form Goes Here',
          style: AppTheme.typography.title,
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\prompt_studio\presentation\widgets\prompt_card.dart ----- 
// lib/src/features/prompt_studio/presentation/widgets/prompt_card.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';

// -----------------------------------------------------------------------------
// --- PROMPT CARD WIDGET ------------------------------------------------------
// -----------------------------------------------------------------------------

/// A reusable card widget for the Prompt Studio main page, featuring a solid
/// color border and a clean, professional look.
class PromptCard extends StatelessWidget {
  final String title;
  final String subtitle;
  final IconData icon; // Reverted to IconData
  final Color color;
  final VoidCallback onTap;

  const PromptCard({
    super.key,
    required this.title,
    required this.subtitle,
    required this.icon,
    required this.color,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 24.0, vertical: 20.0),
        decoration: BoxDecoration(
          color: AppTheme.colors.surface,
          borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
          // --- MODIFIED: Replaced gradient with a solid border ---
          border: Border.all(
            color: color,
            width: 1.5,
          ),
        ),
        child: Row(
          children: [
            // --- MODIFIED: Reverted to Icon widget ---
            Icon(
              icon,
              size: 28,
              color: color,
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: AppTheme.typography.title.copyWith(fontSize: 20),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    subtitle,
                    style: AppTheme.typography.body.copyWith(
                      color: color,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\settings\application\settings_provider.dart ----- 
// lib/src/features/settings/application/settings_provider.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

// Riverpod for state management.
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Package for simple key-value storage.
import 'package:shared_preferences/shared_preferences.dart';

// -----------------------------------------------------------------------------
// --- CONSTANTS ---------------------------------------------------------------
// -----------------------------------------------------------------------------

/// The key prefix used to store the quick rest timers in SharedPreferences.
const String _kQuickRestTimerKeyPrefix = 'quickRestTimer_';

/// The default values for the three quick-select timers in seconds.
const List<int> kDefaultQuickRestTimers = [60, 90, 180];

// -----------------------------------------------------------------------------
// --- SETTINGS STATE DATA MODEL -----------------------------------------------
// -----------------------------------------------------------------------------

/// An immutable class to hold all user-configurable settings.
class AppSettings {
  /// --- UPDATED ---
  /// A list of the user's three preferred quick-select rest times in seconds.
  final List<int> quickRestTimers;

  const AppSettings({
    this.quickRestTimers = kDefaultQuickRestTimers,
  });

  /// Creates a copy of the settings with some values replaced.
  AppSettings copyWith({
    List<int>? quickRestTimers,
  }) {
    return AppSettings(
      quickRestTimers: quickRestTimers ?? this.quickRestTimers,
    );
  }
}

// -----------------------------------------------------------------------------
// --- SETTINGS NOTIFIER -------------------------------------------------------
// -----------------------------------------------------------------------------

/// A Riverpod Notifier that manages the state of the user's settings.
///
/// This class is responsible for loading settings from the device's local
/// storage and saving any changes back to it.
class SettingsNotifier extends AsyncNotifier<AppSettings> {
  @override
  Future<AppSettings> build() async {
    // This method is called to provide the initial state.
    // It asynchronously loads the settings from SharedPreferences.
    return _loadSettings();
  }

  /// Loads the settings from SharedPreferences.
  Future<AppSettings> _loadSettings() async {
    final prefs = await SharedPreferences.getInstance();
    final timers = [
      prefs.getInt('${_kQuickRestTimerKeyPrefix}0') ?? kDefaultQuickRestTimers[0],
      prefs.getInt('${_kQuickRestTimerKeyPrefix}1') ?? kDefaultQuickRestTimers[1],
      prefs.getInt('${_kQuickRestTimerKeyPrefix}2') ?? kDefaultQuickRestTimers[2],
    ];
    return AppSettings(quickRestTimers: timers);
  }

  /// --- NEW METHOD ---
  /// Updates a specific quick rest timer at a given index.
  Future<void> updateQuickRestTimer({required int index, required int newDuration}) async {
    if (index < 0 || index > 2) return; // Guard against invalid index.

    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt('${_kQuickRestTimerKeyPrefix}$index', newDuration);

    // Update the state with the new list of timers.
    state = await AsyncValue.guard(() async {
      final currentTimers = List<int>.from(state.value!.quickRestTimers);
      currentTimers[index] = newDuration;
      return state.value!.copyWith(quickRestTimers: currentTimers);
    });
  }
}

// -----------------------------------------------------------------------------
// --- PROVIDER ----------------------------------------------------------------
// -----------------------------------------------------------------------------

/// The global provider for the user's settings.
///
/// The UI and other services will use this provider to access and modify
/// user preferences. Using an `AsyncNotifierProvider` handles the initial
/// asynchronous loading of the settings.
final settingsProvider = AsyncNotifierProvider<SettingsNotifier, AppSettings>(
  SettingsNotifier.new,
);----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\settings\presentation\settings_screen.dart ----- 
// lib/src/features/settings/presentation/settings_screen.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';

// --- NEW IMPORT ---
// Import the HistoryScreen so we can navigate to it.
import 'package:fairware_lift/src/features/history/presentation/history_screen.dart';

// -----------------------------------------------------------------------------
// --- SETTINGS SCREEN WIDGET --------------------------------------------------
// -----------------------------------------------------------------------------

/// The screen for managing application settings and user-related options.
class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Settings'),
        backgroundColor: AppTheme.colors.background,
        elevation: 0,
      ),
      body: ListView(
        children: [
          _buildSectionHeader('Account'),
          _buildListTile(
            icon: Icons.person_outline_rounded,
            title: 'Profile',
            subtitle: 'Manage your name, email, and goals',
            onTap: () {
              print('Profile tapped');
            },
          ),
          _buildListTile(
            icon: Icons.cloud_sync_outlined,
            title: 'Sync Status',
            subtitle: 'View data sync and conflict logs',
            onTap: () {
              print('Sync Status tapped');
            },
          ),
          _buildSectionHeader('Data'),
          _buildListTile(
            icon: Icons.bar_chart_rounded,
            title: 'Workout History',
            subtitle: 'Review all your past sessions',
            // --- UI FIX ---
            // The onTap callback now navigates to the HistoryScreen.
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => const HistoryScreen(),
                ),
              );
            },
          ),
          _buildListTile(
            icon: Icons.upload_file_rounded,
            title: 'Export Data',
            subtitle: 'Export your workout history as CSV or PDF',
            onTap: () {
              print('Export Data tapped');
            },
          ),
          _buildSectionHeader('General'),
          _buildListTile(
            icon: Icons.palette_outlined,
            title: 'Appearance',
            subtitle: 'Switch between dark and light themes',
            onTap: () {
              print('Appearance tapped');
            },
          ),
          _buildListTile(
            icon: Icons.info_outline_rounded,
            title: 'About',
            subtitle: 'View app version and licenses',
            onTap: () {
              print('About tapped');
            },
          ),
        ],
      ),
    );
  }

  /// Private helper to build a consistent section header.
  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 24, 16, 8),
      child: Text(
        title.toUpperCase(),
        style: AppTheme.typography.caption.copyWith(
          color: AppTheme.colors.accent,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  /// Private helper to build a consistent ListTile for settings items.
  Widget _buildListTile({
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    return ListTile(
      leading: Icon(icon, color: AppTheme.colors.textMuted),
      title: Text(
        title,
        style: AppTheme.typography.body.copyWith(
          color: AppTheme.colors.textPrimary,
        ),
      ),
      subtitle: Text(
        subtitle,
        style: AppTheme.typography.body.copyWith(fontSize: 14),
      ),
      onTap: onTap,
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\today\application\today_state.dart ----- 
// lib/src/features/today/application/today_state.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/theme/data/local/database.dart';

// -----------------------------------------------------------------------------
// --- STATE NOTIFIER ----------------------------------------------------------
// -----------------------------------------------------------------------------

/// --- REFACTORED ---
/// This notifier now fetches the single most recent `FullWorkoutSession`.
class LastWorkoutNotifier extends AsyncNotifier<FullWorkoutSession?> {
  @override
  Future<FullWorkoutSession?> build() async {
    final db = ref.watch(databaseProvider);
    return db.getLatestWorkout();
  }
}

// -----------------------------------------------------------------------------
// --- PROVIDER ----------------------------------------------------------------
// -----------------------------------------------------------------------------

/// --- REFACTORED ---
/// A provider that exposes the last workout session for the Today screen preview.
final lastWorkoutProvider =
    AsyncNotifierProvider<LastWorkoutNotifier, FullWorkoutSession?>(
  LastWorkoutNotifier.new,
);----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\today\presentation\today_screen.dart ----- 
// ----- lib\src\features\today\presentation\today_screen.dart -----
// lib/src/features/today/presentation/today_screen.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/today/application/today_state.dart';
import 'package:watch_connectivity/watch_connectivity.dart';

import 'widgets/today_header.dart';
import 'widgets/start_continue_cta.dart';
import 'widgets/prs_badge.dart';
import 'widgets/last_workout_preview.dart';

// Create a single WatchConnectivity instance you can reuse.
final _watch = WatchConnectivity();

// -----------------------------------------------------------------------------
// --- TODAY SCREEN WIDGET -----------------------------------------------------
// -----------------------------------------------------------------------------

class TodayScreen extends ConsumerWidget {
  const TodayScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Today'),
        backgroundColor: AppTheme.colors.background,
        elevation: 0,
      ),
      body: SafeArea(
        child: RefreshIndicator(
          onRefresh: () => ref.refresh(lastWorkoutProvider.future),
          child: ListView(
            padding: EdgeInsets.fromLTRB(
              AppTheme.sizing.baseGrid * 2,
              0,
              AppTheme.sizing.baseGrid * 2,
              100.0,
            ),
            children: [
              SizedBox(height: AppTheme.sizing.verticalRhythm),
              const TodayHeader(),
              SizedBox(height: AppTheme.sizing.verticalRhythm),
              const StartContinueCTA(),
              SizedBox(height: AppTheme.sizing.verticalRhythm),
              const LastWorkoutPreview(),
              SizedBox(height: AppTheme.sizing.verticalRhythm),
              const PRsBadge(),

              // --- CORRECTED: Ping Watch button using watch_connectivity ---
              const SizedBox(height: 24),
              ElevatedButton(
                onPressed: () async {
                  try {
                    final reachable = await _watch.isReachable;
                    if (!reachable) {
                      if (context.mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Watch not reachable  open the watch app.'),
                          ),
                        );
                      }
                      return;
                    }

                    // watch_connectivity uses simple Map payloads.
                    await _watch.sendMessage({'type': 'ping'});

                    if (context.mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(content: Text('Ping sent to watch!')),
                      );
                    }
                  } catch (e) {
                    if (context.mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text('Error sending ping: $e')),
                      );
                    }
                  }
                },
                child: const Text('Ping Watch'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\today\presentation\widgets\last_workout_preview.dart ----- 
// lib/src/features/today/presentation/widgets/last_workout_preview.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:collection/collection.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/today/application/today_state.dart';

// -----------------------------------------------------------------------------
// --- LAST WORKOUT PREVIEW WIDGET ---------------------------------------------
// -----------------------------------------------------------------------------

class LastWorkoutPreview extends ConsumerWidget {
  const LastWorkoutPreview({super.key});

  /// --- UPDATED METHOD ---
  /// Infers a "Day Type" with added safety checks.
  String _inferDayType(List<String> familyIds) {
    if (familyIds.isEmpty) return 'Workout';

    final counts = familyIds.groupListsBy((id) => id);
    final sorted = counts.entries.toList()
      ..sort((a, b) => b.value.length.compareTo(a.value.length));

    if (sorted.isEmpty) return 'Workout';

    final mostCommon = sorted.first.key;
    final name = mostCommon.replaceAll('_', ' ').trim();

    // --- FIX: Add a guard to prevent RangeError on empty strings ---
    if (name.isEmpty) return 'Workout';

    return '${name[0].toUpperCase()}${name.substring(1)} Day';
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final asyncLastWorkout = ref.watch(lastWorkoutProvider);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(bottom: 12.0),
          child: Text(
            'Last Workout',
            style: AppTheme.typography.title,
          ),
        ),
        asyncLastWorkout.when(
          loading: () => const Center(child: CircularProgressIndicator()),
          error: (err, stack) => Center(child: Text('Error: $err')),
          data: (workout) {
            if (workout == null) {
              return Card(
                color: AppTheme.colors.surface,
                elevation: 0,
                child: const Center(
                  child: Padding(
                    padding: EdgeInsets.all(32.0),
                    child: Text('No workouts logged yet.'),
                  ),
                ),
              );
            }

            final familyIds = workout.sets.map((s) => s.exercise.familyId).toList();
            final dayType = _inferDayType(familyIds);
            final formattedDate = DateFormat.yMMMMd().format(workout.session.sessionDateTime);

            return Card(
              color: AppTheme.colors.surface,
              elevation: 0,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
              ),
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      dayType,
                      style: AppTheme.typography.title.copyWith(fontSize: 20),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      formattedDate,
                      style: AppTheme.typography.body.copyWith(color: AppTheme.colors.textMuted),
                    ),
                    const Divider(height: 24),
                    Text(
                      '${workout.sets.length} total sets performed.',
                      style: AppTheme.typography.body,
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      ],
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\today\presentation\widgets\llm_prompt_builder_card.dart ----- 
// lib/src/features/today/presentation/widgets/llm_prompt_builder_card.dart

// This file is now deprecated and its functionality is moved to the Prompt Studio.
// It will be removed in a future cleanup.----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\today\presentation\widgets\prs_badge.dart ----- 
// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

// Core Flutter material design library.
import 'package:flutter/material.dart';

// The application's design system for consistent styling.
import 'package:fairware_lift/src/core/theme/app_theme.dart';

// -----------------------------------------------------------------------------
// --- PRs BADGE WIDGET --------------------------------------------------------
// -----------------------------------------------------------------------------

/// A widget to display recent Personal Records (PRs) on the Today screen.
///
/// As per SSOT Section 5.3, this component serves to motivate the user by
/// highlighting their recent achievements. This is a static placeholder that
/// showcases a few different types of PRs.
class PRsBadge extends StatelessWidget {
  const PRsBadge({super.key});

  @override
  Widget build(BuildContext context) {
    // A Column structures the section with a title and the content card.
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // --- SECTION HEADER ---
        Padding(
          padding: const EdgeInsets.only(bottom: 12.0),
          child: Text(
            'Recent PRs',
            style: AppTheme.typography.title,
          ),
        ),

        // --- PRs CARD ---
        Card(
          color: AppTheme.colors.surface,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
          ),
          elevation: 0,
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              // Placeholder data for recent PRs.
              children: [
                _buildPrRow(
                  icon: Icons.emoji_events_rounded,
                  color: AppTheme.colors.warning,
                  exercise: 'Bench Press',
                  prValue: '185 lb x 8 reps',
                  date: '3 days ago',
                ),
                const SizedBox(height: 16),
                _buildPrRow(
                  icon: Icons.local_fire_department_rounded,
                  color: AppTheme.colors.danger,
                  exercise: 'Squat',
                  prValue: 'Volume: 12,500 lb',
                  date: '5 days ago',
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  /// Private helper method to build a consistent row for each PR entry.
  Widget _buildPrRow({
    required IconData icon,
    required Color color,
    required String exercise,
    required String prValue,
    required String date,
  }) {
    return Row(
      children: [
        // --- ICON ---
        Icon(icon, color: color, size: 28),
        const SizedBox(width: 16),

        // --- PR DETAILS ---
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                exercise,
                style: AppTheme.typography.body.copyWith(
                  color: AppTheme.colors.textPrimary,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                prValue,
                style: AppTheme.typography.body.copyWith(
                  color: AppTheme.colors.textSecondary,
                ),
              ),
            ],
          ),
        ),
        const SizedBox(width: 16),

        // --- DATE ---
        Text(
          date,
          style: AppTheme.typography.caption,
        ),
      ],
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\today\presentation\widgets\session_preview.dart ----- 
// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

// Core Flutter material design library.
import 'package:flutter/material.dart';

// The application's design system for consistent styling.
import 'package:fairware_lift/src/core/theme/app_theme.dart';

// -----------------------------------------------------------------------------
// --- SESSION PREVIEW WIDGET --------------------------------------------------
// -----------------------------------------------------------------------------

/// A widget that displays a preview of the user's next planned session.
///
/// As per SSOT Section 5.3, this component gives the user a glimpse of what's
/// next in their program. This is a static placeholder implementation that
/// will be connected to real data later.
class SessionPreview extends StatelessWidget {
  const SessionPreview({super.key});

  @override
  Widget build(BuildContext context) {
    // The main container for the preview section.
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // --- SECTION HEADER ---
        // A descriptive title for this section.
        Padding(
          padding: const EdgeInsets.only(bottom: 12.0),
          child: Text(
            'Next Up: Push Day', // Placeholder title
            style: AppTheme.typography.title,
          ),
        ),

        // --- PREVIEW CARD ---
        // A card that contains the list of exercises.
        Card(
          color: AppTheme.colors.surface,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
          ),
          elevation: 0,
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              children: [
                // Static placeholder list of exercises.
                // In a real implementation, this would be a dynamically generated list.
                _buildExerciseRow('Barbell Bench Press', '4 sets x 5-8 reps'),
                _buildDivider(),
                _buildExerciseRow('Incline Dumbbell Press', '3 sets x 8-12 reps'),
                _buildDivider(),
                _buildExerciseRow('Overhead Press', '3 sets x 8-12 reps'),
                _buildDivider(),
                _buildExerciseRow('Tricep Pushdown', '3 sets x 10-15 reps'),
              ],
            ),
          ),
        ),
      ],
    );
  }

  /// Private helper to build a consistent row for each exercise.
  Widget _buildExerciseRow(String name, String details) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          // --- LAYOUT FIX ---
          // The exercise name Text widget is wrapped in an Expanded widget.
          // This allows it to fill the available space and prevents the Row
          // from overflowing when the text on the right needs more room.
          Expanded(
            child: Text(
              name,
              style: AppTheme.typography.body.copyWith(
                color: AppTheme.colors.textPrimary,
              ),
              // Handle long exercise names gracefully.
              overflow: TextOverflow.ellipsis,
              maxLines: 1,
            ),
          ),
          // Add a small gap to ensure the text doesn't touch.
          const SizedBox(width: 16),
          // Exercise sets/reps details.
          Text(
            details,
            style: AppTheme.typography.body,
          ),
        ],
      ),
    );
  }

  /// Private helper to build a consistent divider between rows.
  Widget _buildDivider() {
    return Divider(
      color: AppTheme.colors.surfaceAlt,
      height: 1,
      thickness: 1,
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\today\presentation\widgets\start_continue_cta.dart ----- 
// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

// Core Flutter material design library.
import 'package:flutter/material.dart';

// The application's design system for consistent styling.
import 'package:fairware_lift/src/core/theme/app_theme.dart';

// -----------------------------------------------------------------------------
// --- START/CONTINUE CTA WIDGET -----------------------------------------------
// -----------------------------------------------------------------------------

/// A widget for the primary "Start/Continue" call-to-action on the Today screen.
///
/// As per SSOT Section 5.3, this is the main entry point for a user's workout.
/// It's designed as a large, easily tappable card that clearly communicates
/// the next action. For now, it is a static placeholder.
class StartContinueCTA extends StatelessWidget {
  const StartContinueCTA({super.key});

  @override
  Widget build(BuildContext context) {
    // Using a GestureDetector to make the entire card tappable.
    return GestureDetector(
      onTap: () {
        // TODO: Implement the action to start a new workout.
        print('Start/Continue CTA tapped!');
      },
      child: Card(
        // Using the surface color from our theme for the card background.
        color: AppTheme.colors.surface,
        // Applying the standard card radius from our theme.
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
        ),
        // No elevation is needed as per the dark theme design.
        elevation: 0,
        child: Padding(
          // Using generous padding for a clean, spacious look.
          // The vertical rhythm constant ensures consistent vertical spacing.
          padding: EdgeInsets.all(AppTheme.sizing.verticalRhythm),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              // --- TEXT CONTENT ---
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Start Workout', // Placeholder text
                    style: AppTheme.typography.title.copyWith(
                      color: AppTheme.colors.textPrimary,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'Begin a new session', // Placeholder subtitle
                    style: AppTheme.typography.body,
                  ),
                ],
              ),

              // --- ICON ---
              // The icon acts as a visual affordance for the action.
              Icon(
                Icons.play_circle_fill_rounded,
                color: AppTheme.colors.accent,
                size: AppTheme.sizing.touchTargetMinimum, // Ensures a large tap target
              ),
            ],
          ),
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\today\presentation\widgets\today_header.dart ----- 
// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

// Core Flutter material design library.
import 'package:flutter/material.dart';

// The application's design system for consistent styling.
import 'package:fairware_lift/src/core/theme/app_theme.dart';

// -----------------------------------------------------------------------------
// --- TODAY HEADER WIDGET -----------------------------------------------------
// -----------------------------------------------------------------------------

/// A widget to display the header information on the "Today" screen.
///
/// As per SSOT Section 5.3, this component is responsible for showing the
/// current date, the user's last recorded bodyweight, and their fasted/fed
/// status. This widget uses placeholder data for now.
class TodayHeader extends StatelessWidget {
  const TodayHeader({super.key});

  @override
  Widget build(BuildContext context) {
    // A Row is used to lay out the header elements horizontally.
    return Row(
      // `spaceBetween` alignment pushes the date to the left and the other
      // elements to the right, creating a clean, balanced layout.
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      crossAxisAlignment: CrossAxisAlignment.center, // Vertically align items
      children: [
        // --- LAYOUT FIX ---
        // The date display Column is wrapped in an Expanded widget. This tells
        // the Column to fill all available horizontal space, which pushes the
        // metrics Row to the right edge and gives it the room it needs,
        // preventing an overflow.
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'TUESDAY', // Placeholder
                style: AppTheme.typography.caption.copyWith(
                  color: AppTheme.colors.textMuted,
                ),
              ),
              Text(
                'October 14, 2025', // Placeholder
                style: AppTheme.typography.title,
                // Prevent text from wrapping if space is tight.
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),

        // Add a small gap between the date and the metrics.
        const SizedBox(width: 16),

        // --- BODYWEIGHT & FASTED STATUS ---
        // This Row will now have enough space because the date Column is flexible.
        Row(
          mainAxisSize: MainAxisSize.min, // Take up only needed space
          children: [
            _buildMetric(
              icon: Icons.monitor_weight_outlined,
              value: '185.2', // Placeholder
              unit: 'lb',
            ),
            const SizedBox(width: 16),
            _buildMetric(
              icon: Icons.wb_sunny_outlined,
              value: 'Fasted', // Placeholder
              unit: '',
            ),
          ],
        ),
      ],
    );
  }

  /// A private helper method to build a consistent metric display.
  ///
  /// This encapsulates the common styling for icon-value-unit combinations,
  /// promoting code reuse and easier maintenance.
  Widget _buildMetric({
    required IconData icon,
    required String value,
    required String unit,
  }) {
    return Row(
      children: [
        Icon(
          icon,
          color: AppTheme.colors.textMuted,
          size: 20,
        ),
        const SizedBox(width: 8),
        RichText(
          text: TextSpan(
            style: AppTheme.typography.body,
            children: [
              TextSpan(
                text: value,
                style: TextStyle(
                  color: AppTheme.colors.textPrimary,
                  fontWeight: FontWeight.w600,
                ),
              ),
              if (unit.isNotEmpty)
                TextSpan(
                  text: ' $unit',
                  style: TextStyle(
                    color: AppTheme.colors.textMuted,
                    fontSize: 14,
                  ),
                ),
            ],
          ),
        ),
      ],
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\user_profile\application\user_profile_service.dart ----- 
// lib/src/features/user_profile/application/user_profile_service.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'dart:convert';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:fairware_lift/src/features/user_profile/domain/user_profile.dart';

// -----------------------------------------------------------------------------
// --- USER PROFILE SERVICE ----------------------------------------------------
// -----------------------------------------------------------------------------

const String _userProfileKey = 'user_profile_data';

/// A service responsible for persisting and retrieving the user's profile
/// data using SharedPreferences.
class UserProfileService {
  final SharedPreferences _prefs;

  UserProfileService(this._prefs);

  /// Loads the user profile from local storage.
  Future<UserProfile?> loadProfile() async {
    final jsonString = _prefs.getString(_userProfileKey);
    if (jsonString != null) {
      return UserProfile.fromJson(json.decode(jsonString));
    }
    // --- MODIFICATION: Return a const empty profile if none exists ---
    return const UserProfile();
  }

  /// Saves the user profile to local storage.
  Future<void> saveProfile(UserProfile profile) async {
    final jsonString = json.encode(profile.toJson());
    await _prefs.setString(_userProfileKey, jsonString);
  }
}

// -----------------------------------------------------------------------------
// --- PROVIDERS ---------------------------------------------------------------
// -----------------------------------------------------------------------------

final _sharedPreferencesProvider =
    FutureProvider<SharedPreferences>((ref) => SharedPreferences.getInstance());

final userProfileServiceProvider = Provider<UserProfileService>((ref) {
  final prefs = ref.watch(_sharedPreferencesProvider).value;
  if (prefs == null) {
    throw Exception('SharedPreferences not initialized');
  }
  return UserProfileService(prefs);
});

class UserProfileNotifier extends AsyncNotifier<UserProfile?> {
  @override
  Future<UserProfile?> build() async {
    return ref.watch(userProfileServiceProvider).loadProfile();
  }

  Future<void> save(UserProfile profile) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await ref.read(userProfileServiceProvider).saveProfile(profile);
      return profile;
    });
  }
}

final userProfileProvider =
    AsyncNotifierProvider<UserProfileNotifier, UserProfile?>(
  UserProfileNotifier.new,
);----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\user_profile\domain\user_profile.dart ----- 
// lib/src/features/user_profile/domain/user_profile.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_profile.freezed.dart';
part 'user_profile.g.dart';

// -----------------------------------------------------------------------------
// --- USER PROFILE DATA MODEL -------------------------------------------------
// -----------------------------------------------------------------------------

@freezed
class UserProfile with _$UserProfile {
  const factory UserProfile({
    // Basic Info
    String? name,
    int? age,
    String? gender,
    int? heightInches,
    double? weightLbs,

    // Experience & Goals
    String? trainingAge,
    List<String>? primaryGoals,
    String? goalDetails,

    // --- NEW FIELD ---
    String? motivationStyle,

    // Schedule & Equipment
    int? daysPerWeek,
    int? timePerSessionMinutes,
    List<String>? equipmentAvailable,

    // Health & History
    String? constraints,
    String? currentStatus,
    String? json1RMs,
    int? z2LowBpm,
    int? z2HighBpm,
  }) = _UserProfile;

  factory UserProfile.fromJson(Map<String, dynamic> json) =>
      _$UserProfileFromJson(json);
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\user_profile\domain\user_profile.freezed.dart ----- 
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_profile.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

UserProfile _$UserProfileFromJson(Map<String, dynamic> json) {
  return _UserProfile.fromJson(json);
}

/// @nodoc
mixin _$UserProfile {
// Basic Info
  String? get name => throw _privateConstructorUsedError;
  int? get age => throw _privateConstructorUsedError;
  String? get gender => throw _privateConstructorUsedError;
  int? get heightInches => throw _privateConstructorUsedError;
  double? get weightLbs =>
      throw _privateConstructorUsedError; // Experience & Goals
  String? get trainingAge => throw _privateConstructorUsedError;
  List<String>? get primaryGoals => throw _privateConstructorUsedError;
  String? get goalDetails =>
      throw _privateConstructorUsedError; // --- NEW FIELD ---
  String? get motivationStyle =>
      throw _privateConstructorUsedError; // Schedule & Equipment
  int? get daysPerWeek => throw _privateConstructorUsedError;
  int? get timePerSessionMinutes => throw _privateConstructorUsedError;
  List<String>? get equipmentAvailable =>
      throw _privateConstructorUsedError; // Health & History
  String? get constraints => throw _privateConstructorUsedError;
  String? get currentStatus => throw _privateConstructorUsedError;
  String? get json1RMs => throw _privateConstructorUsedError;
  int? get z2LowBpm => throw _privateConstructorUsedError;
  int? get z2HighBpm => throw _privateConstructorUsedError;

  /// Serializes this UserProfile to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of UserProfile
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $UserProfileCopyWith<UserProfile> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserProfileCopyWith<$Res> {
  factory $UserProfileCopyWith(
          UserProfile value, $Res Function(UserProfile) then) =
      _$UserProfileCopyWithImpl<$Res, UserProfile>;
  @useResult
  $Res call(
      {String? name,
      int? age,
      String? gender,
      int? heightInches,
      double? weightLbs,
      String? trainingAge,
      List<String>? primaryGoals,
      String? goalDetails,
      String? motivationStyle,
      int? daysPerWeek,
      int? timePerSessionMinutes,
      List<String>? equipmentAvailable,
      String? constraints,
      String? currentStatus,
      String? json1RMs,
      int? z2LowBpm,
      int? z2HighBpm});
}

/// @nodoc
class _$UserProfileCopyWithImpl<$Res, $Val extends UserProfile>
    implements $UserProfileCopyWith<$Res> {
  _$UserProfileCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of UserProfile
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? age = freezed,
    Object? gender = freezed,
    Object? heightInches = freezed,
    Object? weightLbs = freezed,
    Object? trainingAge = freezed,
    Object? primaryGoals = freezed,
    Object? goalDetails = freezed,
    Object? motivationStyle = freezed,
    Object? daysPerWeek = freezed,
    Object? timePerSessionMinutes = freezed,
    Object? equipmentAvailable = freezed,
    Object? constraints = freezed,
    Object? currentStatus = freezed,
    Object? json1RMs = freezed,
    Object? z2LowBpm = freezed,
    Object? z2HighBpm = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      age: freezed == age
          ? _value.age
          : age // ignore: cast_nullable_to_non_nullable
              as int?,
      gender: freezed == gender
          ? _value.gender
          : gender // ignore: cast_nullable_to_non_nullable
              as String?,
      heightInches: freezed == heightInches
          ? _value.heightInches
          : heightInches // ignore: cast_nullable_to_non_nullable
              as int?,
      weightLbs: freezed == weightLbs
          ? _value.weightLbs
          : weightLbs // ignore: cast_nullable_to_non_nullable
              as double?,
      trainingAge: freezed == trainingAge
          ? _value.trainingAge
          : trainingAge // ignore: cast_nullable_to_non_nullable
              as String?,
      primaryGoals: freezed == primaryGoals
          ? _value.primaryGoals
          : primaryGoals // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      goalDetails: freezed == goalDetails
          ? _value.goalDetails
          : goalDetails // ignore: cast_nullable_to_non_nullable
              as String?,
      motivationStyle: freezed == motivationStyle
          ? _value.motivationStyle
          : motivationStyle // ignore: cast_nullable_to_non_nullable
              as String?,
      daysPerWeek: freezed == daysPerWeek
          ? _value.daysPerWeek
          : daysPerWeek // ignore: cast_nullable_to_non_nullable
              as int?,
      timePerSessionMinutes: freezed == timePerSessionMinutes
          ? _value.timePerSessionMinutes
          : timePerSessionMinutes // ignore: cast_nullable_to_non_nullable
              as int?,
      equipmentAvailable: freezed == equipmentAvailable
          ? _value.equipmentAvailable
          : equipmentAvailable // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      constraints: freezed == constraints
          ? _value.constraints
          : constraints // ignore: cast_nullable_to_non_nullable
              as String?,
      currentStatus: freezed == currentStatus
          ? _value.currentStatus
          : currentStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      json1RMs: freezed == json1RMs
          ? _value.json1RMs
          : json1RMs // ignore: cast_nullable_to_non_nullable
              as String?,
      z2LowBpm: freezed == z2LowBpm
          ? _value.z2LowBpm
          : z2LowBpm // ignore: cast_nullable_to_non_nullable
              as int?,
      z2HighBpm: freezed == z2HighBpm
          ? _value.z2HighBpm
          : z2HighBpm // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UserProfileImplCopyWith<$Res>
    implements $UserProfileCopyWith<$Res> {
  factory _$$UserProfileImplCopyWith(
          _$UserProfileImpl value, $Res Function(_$UserProfileImpl) then) =
      __$$UserProfileImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? name,
      int? age,
      String? gender,
      int? heightInches,
      double? weightLbs,
      String? trainingAge,
      List<String>? primaryGoals,
      String? goalDetails,
      String? motivationStyle,
      int? daysPerWeek,
      int? timePerSessionMinutes,
      List<String>? equipmentAvailable,
      String? constraints,
      String? currentStatus,
      String? json1RMs,
      int? z2LowBpm,
      int? z2HighBpm});
}

/// @nodoc
class __$$UserProfileImplCopyWithImpl<$Res>
    extends _$UserProfileCopyWithImpl<$Res, _$UserProfileImpl>
    implements _$$UserProfileImplCopyWith<$Res> {
  __$$UserProfileImplCopyWithImpl(
      _$UserProfileImpl _value, $Res Function(_$UserProfileImpl) _then)
      : super(_value, _then);

  /// Create a copy of UserProfile
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? age = freezed,
    Object? gender = freezed,
    Object? heightInches = freezed,
    Object? weightLbs = freezed,
    Object? trainingAge = freezed,
    Object? primaryGoals = freezed,
    Object? goalDetails = freezed,
    Object? motivationStyle = freezed,
    Object? daysPerWeek = freezed,
    Object? timePerSessionMinutes = freezed,
    Object? equipmentAvailable = freezed,
    Object? constraints = freezed,
    Object? currentStatus = freezed,
    Object? json1RMs = freezed,
    Object? z2LowBpm = freezed,
    Object? z2HighBpm = freezed,
  }) {
    return _then(_$UserProfileImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      age: freezed == age
          ? _value.age
          : age // ignore: cast_nullable_to_non_nullable
              as int?,
      gender: freezed == gender
          ? _value.gender
          : gender // ignore: cast_nullable_to_non_nullable
              as String?,
      heightInches: freezed == heightInches
          ? _value.heightInches
          : heightInches // ignore: cast_nullable_to_non_nullable
              as int?,
      weightLbs: freezed == weightLbs
          ? _value.weightLbs
          : weightLbs // ignore: cast_nullable_to_non_nullable
              as double?,
      trainingAge: freezed == trainingAge
          ? _value.trainingAge
          : trainingAge // ignore: cast_nullable_to_non_nullable
              as String?,
      primaryGoals: freezed == primaryGoals
          ? _value._primaryGoals
          : primaryGoals // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      goalDetails: freezed == goalDetails
          ? _value.goalDetails
          : goalDetails // ignore: cast_nullable_to_non_nullable
              as String?,
      motivationStyle: freezed == motivationStyle
          ? _value.motivationStyle
          : motivationStyle // ignore: cast_nullable_to_non_nullable
              as String?,
      daysPerWeek: freezed == daysPerWeek
          ? _value.daysPerWeek
          : daysPerWeek // ignore: cast_nullable_to_non_nullable
              as int?,
      timePerSessionMinutes: freezed == timePerSessionMinutes
          ? _value.timePerSessionMinutes
          : timePerSessionMinutes // ignore: cast_nullable_to_non_nullable
              as int?,
      equipmentAvailable: freezed == equipmentAvailable
          ? _value._equipmentAvailable
          : equipmentAvailable // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      constraints: freezed == constraints
          ? _value.constraints
          : constraints // ignore: cast_nullable_to_non_nullable
              as String?,
      currentStatus: freezed == currentStatus
          ? _value.currentStatus
          : currentStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      json1RMs: freezed == json1RMs
          ? _value.json1RMs
          : json1RMs // ignore: cast_nullable_to_non_nullable
              as String?,
      z2LowBpm: freezed == z2LowBpm
          ? _value.z2LowBpm
          : z2LowBpm // ignore: cast_nullable_to_non_nullable
              as int?,
      z2HighBpm: freezed == z2HighBpm
          ? _value.z2HighBpm
          : z2HighBpm // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserProfileImpl implements _UserProfile {
  const _$UserProfileImpl(
      {this.name,
      this.age,
      this.gender,
      this.heightInches,
      this.weightLbs,
      this.trainingAge,
      final List<String>? primaryGoals,
      this.goalDetails,
      this.motivationStyle,
      this.daysPerWeek,
      this.timePerSessionMinutes,
      final List<String>? equipmentAvailable,
      this.constraints,
      this.currentStatus,
      this.json1RMs,
      this.z2LowBpm,
      this.z2HighBpm})
      : _primaryGoals = primaryGoals,
        _equipmentAvailable = equipmentAvailable;

  factory _$UserProfileImpl.fromJson(Map<String, dynamic> json) =>
      _$$UserProfileImplFromJson(json);

// Basic Info
  @override
  final String? name;
  @override
  final int? age;
  @override
  final String? gender;
  @override
  final int? heightInches;
  @override
  final double? weightLbs;
// Experience & Goals
  @override
  final String? trainingAge;
  final List<String>? _primaryGoals;
  @override
  List<String>? get primaryGoals {
    final value = _primaryGoals;
    if (value == null) return null;
    if (_primaryGoals is EqualUnmodifiableListView) return _primaryGoals;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? goalDetails;
// --- NEW FIELD ---
  @override
  final String? motivationStyle;
// Schedule & Equipment
  @override
  final int? daysPerWeek;
  @override
  final int? timePerSessionMinutes;
  final List<String>? _equipmentAvailable;
  @override
  List<String>? get equipmentAvailable {
    final value = _equipmentAvailable;
    if (value == null) return null;
    if (_equipmentAvailable is EqualUnmodifiableListView)
      return _equipmentAvailable;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

// Health & History
  @override
  final String? constraints;
  @override
  final String? currentStatus;
  @override
  final String? json1RMs;
  @override
  final int? z2LowBpm;
  @override
  final int? z2HighBpm;

  @override
  String toString() {
    return 'UserProfile(name: $name, age: $age, gender: $gender, heightInches: $heightInches, weightLbs: $weightLbs, trainingAge: $trainingAge, primaryGoals: $primaryGoals, goalDetails: $goalDetails, motivationStyle: $motivationStyle, daysPerWeek: $daysPerWeek, timePerSessionMinutes: $timePerSessionMinutes, equipmentAvailable: $equipmentAvailable, constraints: $constraints, currentStatus: $currentStatus, json1RMs: $json1RMs, z2LowBpm: $z2LowBpm, z2HighBpm: $z2HighBpm)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserProfileImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.age, age) || other.age == age) &&
            (identical(other.gender, gender) || other.gender == gender) &&
            (identical(other.heightInches, heightInches) ||
                other.heightInches == heightInches) &&
            (identical(other.weightLbs, weightLbs) ||
                other.weightLbs == weightLbs) &&
            (identical(other.trainingAge, trainingAge) ||
                other.trainingAge == trainingAge) &&
            const DeepCollectionEquality()
                .equals(other._primaryGoals, _primaryGoals) &&
            (identical(other.goalDetails, goalDetails) ||
                other.goalDetails == goalDetails) &&
            (identical(other.motivationStyle, motivationStyle) ||
                other.motivationStyle == motivationStyle) &&
            (identical(other.daysPerWeek, daysPerWeek) ||
                other.daysPerWeek == daysPerWeek) &&
            (identical(other.timePerSessionMinutes, timePerSessionMinutes) ||
                other.timePerSessionMinutes == timePerSessionMinutes) &&
            const DeepCollectionEquality()
                .equals(other._equipmentAvailable, _equipmentAvailable) &&
            (identical(other.constraints, constraints) ||
                other.constraints == constraints) &&
            (identical(other.currentStatus, currentStatus) ||
                other.currentStatus == currentStatus) &&
            (identical(other.json1RMs, json1RMs) ||
                other.json1RMs == json1RMs) &&
            (identical(other.z2LowBpm, z2LowBpm) ||
                other.z2LowBpm == z2LowBpm) &&
            (identical(other.z2HighBpm, z2HighBpm) ||
                other.z2HighBpm == z2HighBpm));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      name,
      age,
      gender,
      heightInches,
      weightLbs,
      trainingAge,
      const DeepCollectionEquality().hash(_primaryGoals),
      goalDetails,
      motivationStyle,
      daysPerWeek,
      timePerSessionMinutes,
      const DeepCollectionEquality().hash(_equipmentAvailable),
      constraints,
      currentStatus,
      json1RMs,
      z2LowBpm,
      z2HighBpm);

  /// Create a copy of UserProfile
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UserProfileImplCopyWith<_$UserProfileImpl> get copyWith =>
      __$$UserProfileImplCopyWithImpl<_$UserProfileImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UserProfileImplToJson(
      this,
    );
  }
}

abstract class _UserProfile implements UserProfile {
  const factory _UserProfile(
      {final String? name,
      final int? age,
      final String? gender,
      final int? heightInches,
      final double? weightLbs,
      final String? trainingAge,
      final List<String>? primaryGoals,
      final String? goalDetails,
      final String? motivationStyle,
      final int? daysPerWeek,
      final int? timePerSessionMinutes,
      final List<String>? equipmentAvailable,
      final String? constraints,
      final String? currentStatus,
      final String? json1RMs,
      final int? z2LowBpm,
      final int? z2HighBpm}) = _$UserProfileImpl;

  factory _UserProfile.fromJson(Map<String, dynamic> json) =
      _$UserProfileImpl.fromJson;

// Basic Info
  @override
  String? get name;
  @override
  int? get age;
  @override
  String? get gender;
  @override
  int? get heightInches;
  @override
  double? get weightLbs; // Experience & Goals
  @override
  String? get trainingAge;
  @override
  List<String>? get primaryGoals;
  @override
  String? get goalDetails; // --- NEW FIELD ---
  @override
  String? get motivationStyle; // Schedule & Equipment
  @override
  int? get daysPerWeek;
  @override
  int? get timePerSessionMinutes;
  @override
  List<String>? get equipmentAvailable; // Health & History
  @override
  String? get constraints;
  @override
  String? get currentStatus;
  @override
  String? get json1RMs;
  @override
  int? get z2LowBpm;
  @override
  int? get z2HighBpm;

  /// Create a copy of UserProfile
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UserProfileImplCopyWith<_$UserProfileImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\user_profile\domain\user_profile.g.dart ----- 
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_profile.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$UserProfileImpl _$$UserProfileImplFromJson(Map<String, dynamic> json) =>
    _$UserProfileImpl(
      name: json['name'] as String?,
      age: (json['age'] as num?)?.toInt(),
      gender: json['gender'] as String?,
      heightInches: (json['heightInches'] as num?)?.toInt(),
      weightLbs: (json['weightLbs'] as num?)?.toDouble(),
      trainingAge: json['trainingAge'] as String?,
      primaryGoals: (json['primaryGoals'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
      goalDetails: json['goalDetails'] as String?,
      motivationStyle: json['motivationStyle'] as String?,
      daysPerWeek: (json['daysPerWeek'] as num?)?.toInt(),
      timePerSessionMinutes: (json['timePerSessionMinutes'] as num?)?.toInt(),
      equipmentAvailable: (json['equipmentAvailable'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
      constraints: json['constraints'] as String?,
      currentStatus: json['currentStatus'] as String?,
      json1RMs: json['json1RMs'] as String?,
      z2LowBpm: (json['z2LowBpm'] as num?)?.toInt(),
      z2HighBpm: (json['z2HighBpm'] as num?)?.toInt(),
    );

Map<String, dynamic> _$$UserProfileImplToJson(_$UserProfileImpl instance) =>
    <String, dynamic>{
      'name': instance.name,
      'age': instance.age,
      'gender': instance.gender,
      'heightInches': instance.heightInches,
      'weightLbs': instance.weightLbs,
      'trainingAge': instance.trainingAge,
      'primaryGoals': instance.primaryGoals,
      'goalDetails': instance.goalDetails,
      'motivationStyle': instance.motivationStyle,
      'daysPerWeek': instance.daysPerWeek,
      'timePerSessionMinutes': instance.timePerSessionMinutes,
      'equipmentAvailable': instance.equipmentAvailable,
      'constraints': instance.constraints,
      'currentStatus': instance.currentStatus,
      'json1RMs': instance.json1RMs,
      'z2LowBpm': instance.z2LowBpm,
      'z2HighBpm': instance.z2HighBpm,
    };
----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\application\session_state.dart ----- 
// ----- lib/src/features/workout/application/session_state.dart -----
// lib/src/features/workout/application/session_state.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:fairware_lift/src/features/exercises/domain/exercise.dart'
    as lib_exercise;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:fairware_lift/src/features/dxg/domain/warmup_item.dart';
import 'package:fairware_lift/src/features/workout/application/timer_state.dart';
import 'package:fairware_lift/src/features/workout/domain/logged_set.dart';
import 'package:fairware_lift/src/features/workout/domain/session_item.dart';
import 'package:fairware_lift/src/features/workout_import/domain/lift_dsl.dart';

// -----------------------------------------------------------------------------
// --- SESSION STATE NOTIFIER --------------------------------------------------
// -----------------------------------------------------------------------------

class SessionStateNotifier extends Notifier<List<SessionItem>> {
  final _uuid = const Uuid();

  @override
  List<SessionItem> build() {
    return [];
  }

  void importWorkout(List<SessionItem> importedItems) {
    if (importedItems.isNotEmpty) {
      final firstItem = importedItems.first;
      if (firstItem is SessionExercise) {
        importedItems[0] = firstItem.copyWith(isCurrent: true);
      } else if (firstItem is SessionSuperset &&
          firstItem.exercises.isNotEmpty) {
        final firstExerciseInSuperset =
            firstItem.exercises.first.copyWith(isCurrent: true);
        final updatedExercises = [
          firstExerciseInSuperset,
          ...firstItem.exercises.skip(1)
        ];
        importedItems[0] = firstItem.copyWith(exercises: updatedExercises);
      }
    }
    state = importedItems;
  }

  List<SessionItem> _deactivateAllExercises(List<SessionItem> currentState) {
    return currentState.map((item) {
      return switch (item) {
        SessionExercise e => e.copyWith(isCurrent: false),
        SessionSuperset s => s.copyWith(
            exercises:
                s.exercises.map((e) => e.copyWith(isCurrent: false)).toList()),
        _ => item,
      };
    }).toList();
  }

  void addExerciseFromLibrary(lib_exercise.Exercise exercise) {
    final newExercise = SessionItem.exercise(
      id: _uuid.v4(),
      slug: exercise.name.toLowerCase().replaceAll(' ', '-'),
      exerciseHash: 'library_${exercise.name}',
      displayName: exercise.name,
      defaultSetType: exercise.defaultSetType,
      prescription: const Prescription(
        sets: 3,
        reps: '8-12',
        restSeconds: 90,
        restSecondsAfter: 0,
      ),
      variation: {
        'equipment': exercise.equipment,
        'pattern': exercise.movementPattern,
      },
      info: Info(howTo: exercise.howTo),
      unmapped: false,
    );

    state = [...state, newExercise];
  }

  void addWarmupItem(WarmupItem item, Map<String, String> selectedParameters) {
    final newWarmup = SessionItem.warmup(
      id: _uuid.v4(),
      item: item,
      selectedParameters: selectedParameters,
    );

    final timeParam = selectedParameters['Time (minutes)'];
    if (timeParam != null) {
      final minutes = int.tryParse(timeParam) ?? 0;
      if (minutes > 0) {
        ref
            .read(workoutMetricsProvider.notifier)
            .addActivityTime(seconds: minutes * 60);
      }
    }

    state = [...state, newWarmup];
  }

  void setCurrentItem({required String itemId}) {
    final newState = _deactivateAllExercises(state);

    state = newState.map((item) {
      return switch (item) {
        SessionExercise e when e.id == itemId => e.copyWith(isCurrent: true),
        SessionSuperset s => s.copyWith(
            exercises: s.exercises.map((e) {
            return e.id == itemId ? e.copyWith(isCurrent: true) : e;
          }).toList()),
        _ => item,
      };
    }).toList();
  }

  void logSet(LoggedSet set) {
    SessionSuperset? parentSuperset;
    SessionExercise? currentExercise;
    int currentExerciseIndex = -1;

    for (final item in state) {
      if (item is SessionExercise && item.isCurrent) {
        currentExercise = item;
        break;
      }
      if (item is SessionSuperset) {
        final index = item.exercises.indexWhere((e) => e.isCurrent);
        if (index != -1) {
          parentSuperset = item;
          currentExercise = item.exercises[index];
          currentExerciseIndex = index;
          break;
        }
      }
    }

    if (currentExercise == null) return;

    final updatedExercise =
        currentExercise.copyWith(loggedSets: [...currentExercise.loggedSets, set]);

    state = state.map((item) {
      if (item.id == currentExercise!.id) return updatedExercise;
      if (item.id == parentSuperset?.id) {
        return (item as SessionSuperset).copyWith(
          exercises: item.exercises
              .map((e) => e.id == updatedExercise.id ? updatedExercise : e)
              .toList(),
        );
      }
      return item;
    }).toList();

    if (set.setType == 'timed' && set.durationSeconds != null) {
      ref
          .read(workoutMetricsProvider.notifier)
          .addActivityTime(seconds: set.durationSeconds!);
    }

    // --- FIX: Conditional Timer Logic ---
    // This block is now corrected to handle straight sets and supersets properly.
    bool shouldStartTimer = false;
    int? restDuration;

    if (parentSuperset == null) {
      // Case 1: This is a straight set, not in a superset.
      shouldStartTimer = true;
      restDuration = currentExercise.prescription.restSeconds;
    } else {
      // Case 2: This is part of a superset.
      // Only start the timer if it's the LAST exercise in the superset.
      if (currentExerciseIndex == parentSuperset.exercises.length - 1) {
        shouldStartTimer = true;
        // Use restSecondsAfter for the rest period following a completed superset.
        restDuration = currentExercise.prescription.restSecondsAfter;
      }
    }

    if (shouldStartTimer) {
      ref.read(timerStateProvider.notifier).startTimer(duration: restDuration);
    }
  }

  // --- NEW: Method to update an existing set ---
  void updateSet(LoggedSet updatedSet) {
    state = state.map((item) {
      // Handle standalone exercises
      if (item is SessionExercise) {
        final setIndex =
            item.loggedSets.indexWhere((s) => s.id == updatedSet.id);
        if (setIndex != -1) {
          final newSets = List<LoggedSet>.from(item.loggedSets);
          newSets[setIndex] = updatedSet;
          return item.copyWith(loggedSets: newSets);
        }
      }
      // Handle exercises within supersets
      else if (item is SessionSuperset) {
        return item.copyWith(
          exercises: item.exercises.map((exercise) {
            final setIndex =
                exercise.loggedSets.indexWhere((s) => s.id == updatedSet.id);
            if (setIndex != -1) {
              final newSets = List<LoggedSet>.from(exercise.loggedSets);
              newSets[setIndex] = updatedSet;
              return exercise.copyWith(loggedSets: newSets);
            }
            return exercise;
          }).toList(),
        );
      }
      return item;
    }).toList();
  }

  // --- NEW: Method to delete a set by its unique ID ---
  void deleteSet({required String setId}) {
    state = state.map((item) {
      // Handle standalone exercises
      if (item is SessionExercise) {
        if (item.loggedSets.any((s) => s.id == setId)) {
          return item.copyWith(
            loggedSets: item.loggedSets.where((s) => s.id != setId).toList(),
          );
        }
      }
      // Handle exercises within supersets
      else if (item is SessionSuperset) {
        // Check if any exercise in the superset contains the set to be deleted
        if (item.exercises.any((e) => e.loggedSets.any((s) => s.id == setId))) {
          return item.copyWith(
            exercises: item.exercises.map((exercise) {
              return exercise.copyWith(
                loggedSets:
                    exercise.loggedSets.where((s) => s.id != setId).toList(),
              );
            }).toList(),
          );
        }
      }
      return item;
    }).toList();
  }

  void logWeightReps({required double weight, required int reps, double? rpe}) {
    final id = _uuid.v4();
    logSet(LoggedSet.weightReps(id: id, weight: weight, reps: reps, rpe: rpe));
  }

  void logTimed(
      {required int durationSeconds, Map<String, dynamic> metrics = const {}}) {
    final id = _uuid.v4();
    logSet(LoggedSet.timed(
        id: id, durationSeconds: durationSeconds, metrics: metrics));
  }

  void logRepsOnlySet(
      {required int reps, required double bodyweight, double? rpe}) {
    final id = _uuid.v4();
    logSet(
        LoggedSet.weightReps(id: id, weight: bodyweight, reps: reps, rpe: rpe));
  }

  void deleteItem(String itemId) {
    state = state.where((item) => item.id != itemId).toList();
  }

  void deleteExerciseFromSuperset({
    required String supersetId,
    required String exerciseId,
  }) {
    state = state.map((item) {
      if (item is SessionSuperset && item.id == supersetId) {
        return item.copyWith(
          exercises: item.exercises.where((e) => e.id != exerciseId).toList(),
        );
      }
      return item;
    }).toList();
  }

  void reorderItem(int oldIndex, int newIndex) {
    final items = List<SessionItem>.from(state);
    if (newIndex > oldIndex) {
      newIndex -= 1;
    }
    final SessionItem item = items.removeAt(oldIndex);
    items.insert(newIndex, item);
    state = items;
  }
}

// -----------------------------------------------------------------------------
// --- PROVIDER ----------------------------------------------------------------
// -----------------------------------------------------------------------------

final sessionStateProvider =
    NotifierProvider<SessionStateNotifier, List<SessionItem>>(
  SessionStateNotifier.new,
);----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\application\timer_state.dart ----- 
// lib/src/features/workout/application/timer_state.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/services/alert_service.dart';
import 'package:fairware_lift/src/features/settings/application/settings_provider.dart';

// -----------------------------------------------------------------------------
// --- WORKOUT METRICS STATE ---------------------------------------------------
// -----------------------------------------------------------------------------

/// A data class to hold live metrics for the current workout session.
@immutable
class WorkoutMetrics {
  /// Wall-clock time from start to finish.
  final int totalDurationSeconds;
  /// Sum of all timed warm-ups and completed rest periods.
  final int totalActivitySeconds;
  /// Sum of all completed rest periods.
  final int totalRestSeconds;

  const WorkoutMetrics({
    this.totalDurationSeconds = 0,
    this.totalActivitySeconds = 0,
    this.totalRestSeconds = 0,
  });

  WorkoutMetrics copyWith({
    int? totalDurationSeconds,
    int? totalActivitySeconds,
    int? totalRestSeconds,
  }) {
    return WorkoutMetrics(
      totalDurationSeconds: totalDurationSeconds ?? this.totalDurationSeconds,
      totalActivitySeconds: totalActivitySeconds ?? this.totalActivitySeconds,
      totalRestSeconds: totalRestSeconds ?? this.totalRestSeconds,
    );
  }
}

/// A notifier to manage the live workout metrics.
class WorkoutMetricsNotifier extends StateNotifier<WorkoutMetrics> {
  Timer? _stopwatch;

  WorkoutMetricsNotifier() : super(const WorkoutMetrics());

  void startWorkout() {
    state = const WorkoutMetrics(); // Reset on start
    _stopwatch?.cancel();
    _stopwatch = Timer.periodic(const Duration(seconds: 1), (timer) {
      state = state.copyWith(totalDurationSeconds: state.totalDurationSeconds + 1);
    });
  }

  void addActivityTime({required int seconds, bool isRest = false}) {
    state = state.copyWith(
      totalActivitySeconds: state.totalActivitySeconds + seconds,
      totalRestSeconds: isRest ? state.totalRestSeconds + seconds : state.totalRestSeconds,
    );
  }

  void stopWorkout() {
    _stopwatch?.cancel();
  }
}

final workoutMetricsProvider =
    StateNotifierProvider<WorkoutMetricsNotifier, WorkoutMetrics>(
  (ref) => WorkoutMetricsNotifier(),
);


// -----------------------------------------------------------------------------
// --- CONFIGURABLE VALUES -----------------------------------------------------
// -----------------------------------------------------------------------------

const int kDefaultRestDuration = 90;

// -----------------------------------------------------------------------------
// --- TIMER STATE DATA MODEL (MODIFIED) ---------------------------------------
// -----------------------------------------------------------------------------

/// Represents the state of the workout timer.
/// This class is now aligned with the SSOT for watch communication.
class TimerState {
  /// The remaining seconds on the timer.
  final int seconds;
  final bool isRunning;
  /// The timestamp of the last state change, used to resolve stale data on the watch.
  final int epochMillis;
  // This is kept locally on the phone for progress bar calculations.
  final int initialDuration;

  const TimerState({
    required this.seconds,
    required this.isRunning,
    required this.epochMillis,
    this.initialDuration = kDefaultRestDuration,
  });

  /// Creates a serializable map for sending to the watch.
  Map<String, dynamic> toMap() => {
    "seconds": seconds,
    "isRunning": isRunning,
    "ts": epochMillis,
    "v": 1, // Payload versioning
  };

  TimerState copyWith({
    int? seconds,
    bool? isRunning,
    int? epochMillis,
    int? initialDuration,
  }) {
    return TimerState(
      seconds: seconds ?? this.seconds,
      isRunning: isRunning ?? this.isRunning,
      epochMillis: epochMillis ?? this.epochMillis,
      initialDuration: initialDuration ?? this.initialDuration,
    );
  }
}

// -----------------------------------------------------------------------------
// --- TIMER STATE NOTIFIER (MODIFIED) -----------------------------------------
// -----------------------------------------------------------------------------

class TimerStateNotifier extends Notifier<TimerState> {
  Timer? _timer;

  @override
  TimerState build() {
    ref.onDispose(() {
      _timer?.cancel();
    });
    // The initial state now requires all fields.
    return TimerState(
      seconds: 0,
      isRunning: false,
      epochMillis: DateTime.now().millisecondsSinceEpoch,
    );
  }

  /// Starts the rest timer for a given duration.
  void startTimer({int? duration}) {
    _timer?.cancel();

    final settings = ref.read(settingsProvider).value;
    final defaultTimerPreset =
        (settings != null && settings.quickRestTimers.isNotEmpty)
            ? settings.quickRestTimers[0]
            : kDefaultRestDuration;

    final timerDuration = duration ?? defaultTimerPreset;

    state = TimerState(
      seconds: timerDuration,
      initialDuration: timerDuration,
      isRunning: true,
      epochMillis: DateTime.now().millisecondsSinceEpoch,
    );

    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (state.seconds > 0) {
        if (state.seconds == 3) {
          ref.read(alertServiceProvider).triggerTimerWarningAlert();
        }
        // Every tick is a state change, so we update the timestamp.
        state = state.copyWith(
          seconds: state.seconds - 1,
          epochMillis: DateTime.now().millisecondsSinceEpoch,
        );
      } else {
        ref.read(alertServiceProvider).triggerTimerCompletionAlert();
        stopTimer(isFinished: true);
      }
    });
  }

  /// Adds a specified number of seconds to the running timer.
  void addTime({int seconds = 30}) {
    if (state.isRunning) {
      state = state.copyWith(
        seconds: state.seconds + seconds,
        epochMillis: DateTime.now().millisecondsSinceEpoch,
      );
    }
  }

  /// Stops the timer, optionally marking it as a completed rest period.
  void stopTimer({bool isFinished = false}) {
    if (isFinished) {
      ref.read(workoutMetricsProvider.notifier).addActivityTime(seconds: state.initialDuration, isRest: true);
    }
    _timer?.cancel();
    state = TimerState(
      seconds: 0,
      isRunning: false,
      epochMillis: DateTime.now().millisecondsSinceEpoch,
      initialDuration: state.initialDuration,
    );
  }
}

// -----------------------------------------------------------------------------
// --- PROVIDER ----------------------------------------------------------------
// -----------------------------------------------------------------------------

final timerStateProvider = NotifierProvider<TimerStateNotifier, TimerState>(
  TimerStateNotifier.new,
);----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\application\wear_timer_sync_service.dart ----- 
// lib/src/features/workout/application/wear_timer_sync_service.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'dart:async';
import 'dart:convert';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_wear_os_connectivity/flutter_wear_os_connectivity.dart';
import 'package:fairware_lift/src/features/workout/application/timer_state.dart';

// -----------------------------------------------------------------------------
// --- WEAR TIMER SYNC SERVICE -------------------------------------------------
// -----------------------------------------------------------------------------

/// A service that coalesces high-frequency timer changes and ships them to a
/// connected Wear OS device using a hybrid strategy for reliability and efficiency.
class WearTimerSyncService {
  final FlutterWearOsConnectivity _wear = FlutterWearOsConnectivity();
  final String _messagePath = "/timer/update";
  final String _dataPath = "/timer/snapshot";
  final Duration _snapshotCadence = const Duration(seconds: 7);

  Timer? _snapshotTimer;
  TimerState? _latestState;

  /// Initializes the Wearable API. Must be called before other methods.
  Future<void> init() async {
    await _wear.configureWearableAPI();
  }

  /// Listens to the Riverpod timer provider and sends updates to the watch.
  void attach(Ref ref) {
    // Listen for every change to the timer state.
    ref.listen<TimerState>(timerStateProvider, (previous, next) {
      _latestState = next;
      // Send an immediate message for important state transitions.
      if (previous?.isRunning != next.isRunning) {
        _flushMessage();
      }
    }, fireImmediately: true);

    // Start a periodic timer to send reliable state snapshots.
    _snapshotTimer ??= Timer.periodic(_snapshotCadence, (_) => _flushSnapshot());
  }

  /// Sends the latest state via the high-priority MessageClient.
  /// This is for low-latency updates when the app is in the foreground.
  Future<void> _flushMessage() async {
    if (_latestState == null) return;
    final payload = utf8.encode(jsonEncode(_latestState!.toMap()));
    try {
      // --- FIX: Fetch connected devices and send a message to each one. ---
      final connectedDevices = await _wear.getConnectedDevices();
      for (final device in connectedDevices) {
        await _wear.sendMessage(
          payload,
          deviceId: device.id, // Now guaranteed to be a non-null String
          path: _messagePath,
          priority: MessagePriority.high,
        );
      }
    } catch (_) {
      // Errors are expected if the watch is not connected; the snapshot will heal the state.
    }
  }

  /// Syncs the latest state via the persistent DataClient.
  /// This ensures the watch gets the correct state upon reconnecting.
  Future<void> _flushSnapshot() async {
    if (_latestState == null) return;
    try {
      await _wear.syncData(
        path: _dataPath,
        data: _latestState!.toMap(),
        isUrgent: false, // Allows the system to coalesce updates to save battery.
      );
    } catch (_) {
      // Errors are expected if the watch is not connected.
    }
  }

  /// Cancels any active timers.
  void dispose() {
    _snapshotTimer?.cancel();
  }
}

// -----------------------------------------------------------------------------
// --- PROVIDER ----------------------------------------------------------------
// -----------------------------------------------------------------------------

/// A global provider for the WearTimerSyncService instance.
final wearTimerSyncServiceProvider = Provider<WearTimerSyncService>((ref) {
  final service = WearTimerSyncService();
  // Attach the service to the Riverpod ref to listen for timer state changes.
  service.attach(ref);
  // Dispose of the service's resources when the provider is disposed.
  ref.onDispose(() => service.dispose());
  return service;
});----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\domain\logged_set.dart ----- 
// ----- lib/src/features/workout/domain/logged_set.dart -----
// lib/src/features/workout/domain/logged_set.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/foundation.dart';
import 'dart:convert';

// -----------------------------------------------------------------------------
// --- LOGGED SET DATA MODEL ---------------------------------------------------
// -----------------------------------------------------------------------------

/// A generic, immutable data class representing a single logged set for an exercise.
@immutable
class LoggedSet {
  final String id;
  final String setType; // "weight_reps", "timed", "distance", ...
  final double? weight; // in lb
  final int? reps;
  final int? durationSeconds;
  final int? distanceM;
  final int? calories;
  final double? rpe;
  final Map<String, dynamic> metrics; // incline, speed_mph, resistance_level, etc.
  final Map<String, dynamic>? prescriptionSnapshot;

  const LoggedSet({
    required this.id,
    required this.setType,
    this.weight,
    this.reps,
    this.durationSeconds,
    this.distanceM,
    this.calories,
    this.rpe,
    this.metrics = const {},
    this.prescriptionSnapshot,
  });

  factory LoggedSet.weightReps({
    required String id,
    required double weight,
    required int reps,
    double? rpe,
    Map<String, dynamic>? prescriptionSnapshot,
  }) =>
      LoggedSet(
        id: id,
        setType: 'weight_reps',
        weight: weight,
        reps: reps,
        rpe: rpe,
        prescriptionSnapshot: prescriptionSnapshot,
      );

  factory LoggedSet.timed({
    required String id,
    required int durationSeconds,
    Map<String, dynamic> metrics = const {},
    double? rpe,
    Map<String, dynamic>? prescriptionSnapshot,
  }) =>
      LoggedSet(
        id: id,
        setType: 'timed',
        durationSeconds: durationSeconds,
        metrics: metrics,
        rpe: rpe,
        prescriptionSnapshot: prescriptionSnapshot,
      );

  // --- NEW: copyWith method for immutable updates ---
  LoggedSet copyWith({
    String? id,
    String? setType,
    double? weight,
    int? reps,
    int? durationSeconds,
    int? distanceM,
    int? calories,
    double? rpe,
    Map<String, dynamic>? metrics,
    Map<String, dynamic>? prescriptionSnapshot,
  }) {
    return LoggedSet(
      id: id ?? this.id,
      setType: setType ?? this.setType,
      weight: weight ?? this.weight,
      reps: reps ?? this.reps,
      durationSeconds: durationSeconds ?? this.durationSeconds,
      distanceM: distanceM ?? this.distanceM,
      calories: calories ?? this.calories,
      rpe: rpe ?? this.rpe,
      metrics: metrics ?? this.metrics,
      prescriptionSnapshot: prescriptionSnapshot ?? this.prescriptionSnapshot,
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\domain\session_item.dart ----- 
// lib/src/features/workout/domain/session_item.dart

import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:fairware_lift/src/features/dxg/domain/warmup_item.dart';
import 'package:fairware_lift/src/features/workout/domain/logged_set.dart';
import 'package:fairware_lift/src/features/workout_import/domain/lift_dsl.dart';

part 'session_item.freezed.dart';

@freezed
sealed class SessionItem with _$SessionItem {
  const factory SessionItem.exercise({
    required String id,
    String? slug,
    required String exerciseHash,
    required String displayName,
    required Prescription prescription,
    required Map<String, dynamic> variation,
    String? defaultSetType, // NEW
    Info? info,
    @Default([]) List<LoggedSet> loggedSets,
    @Default(false) bool isCurrent,
    @Default(false) bool unmapped,
  }) = SessionExercise;

  const factory SessionItem.warmup({
    required String id,
    required WarmupItem item,
    required Map<String, String> selectedParameters,
  }) = SessionWarmupItem;

  const factory SessionItem.superset({
    required String id,
    @Default([]) List<SessionExercise> exercises,
  }) = SessionSuperset;
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\domain\session_item.freezed.dart ----- 
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'session_item.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SessionItem {
  String get id => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String id,
            String? slug,
            String exerciseHash,
            String displayName,
            Prescription prescription,
            Map<String, dynamic> variation,
            String? defaultSetType,
            Info? info,
            List<LoggedSet> loggedSets,
            bool isCurrent,
            bool unmapped)
        exercise,
    required TResult Function(
            String id, WarmupItem item, Map<String, String> selectedParameters)
        warmup,
    required TResult Function(String id, List<SessionExercise> exercises)
        superset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String id,
            String? slug,
            String exerciseHash,
            String displayName,
            Prescription prescription,
            Map<String, dynamic> variation,
            String? defaultSetType,
            Info? info,
            List<LoggedSet> loggedSets,
            bool isCurrent,
            bool unmapped)?
        exercise,
    TResult? Function(
            String id, WarmupItem item, Map<String, String> selectedParameters)?
        warmup,
    TResult? Function(String id, List<SessionExercise> exercises)? superset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String id,
            String? slug,
            String exerciseHash,
            String displayName,
            Prescription prescription,
            Map<String, dynamic> variation,
            String? defaultSetType,
            Info? info,
            List<LoggedSet> loggedSets,
            bool isCurrent,
            bool unmapped)?
        exercise,
    TResult Function(
            String id, WarmupItem item, Map<String, String> selectedParameters)?
        warmup,
    TResult Function(String id, List<SessionExercise> exercises)? superset,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SessionExercise value) exercise,
    required TResult Function(SessionWarmupItem value) warmup,
    required TResult Function(SessionSuperset value) superset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SessionExercise value)? exercise,
    TResult? Function(SessionWarmupItem value)? warmup,
    TResult? Function(SessionSuperset value)? superset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SessionExercise value)? exercise,
    TResult Function(SessionWarmupItem value)? warmup,
    TResult Function(SessionSuperset value)? superset,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SessionItemCopyWith<SessionItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SessionItemCopyWith<$Res> {
  factory $SessionItemCopyWith(
          SessionItem value, $Res Function(SessionItem) then) =
      _$SessionItemCopyWithImpl<$Res, SessionItem>;
  @useResult
  $Res call({String id});
}

/// @nodoc
class _$SessionItemCopyWithImpl<$Res, $Val extends SessionItem>
    implements $SessionItemCopyWith<$Res> {
  _$SessionItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SessionExerciseImplCopyWith<$Res>
    implements $SessionItemCopyWith<$Res> {
  factory _$$SessionExerciseImplCopyWith(_$SessionExerciseImpl value,
          $Res Function(_$SessionExerciseImpl) then) =
      __$$SessionExerciseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String? slug,
      String exerciseHash,
      String displayName,
      Prescription prescription,
      Map<String, dynamic> variation,
      String? defaultSetType,
      Info? info,
      List<LoggedSet> loggedSets,
      bool isCurrent,
      bool unmapped});
}

/// @nodoc
class __$$SessionExerciseImplCopyWithImpl<$Res>
    extends _$SessionItemCopyWithImpl<$Res, _$SessionExerciseImpl>
    implements _$$SessionExerciseImplCopyWith<$Res> {
  __$$SessionExerciseImplCopyWithImpl(
      _$SessionExerciseImpl _value, $Res Function(_$SessionExerciseImpl) _then)
      : super(_value, _then);

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? slug = freezed,
    Object? exerciseHash = null,
    Object? displayName = null,
    Object? prescription = null,
    Object? variation = null,
    Object? defaultSetType = freezed,
    Object? info = freezed,
    Object? loggedSets = null,
    Object? isCurrent = null,
    Object? unmapped = null,
  }) {
    return _then(_$SessionExerciseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      slug: freezed == slug
          ? _value.slug
          : slug // ignore: cast_nullable_to_non_nullable
              as String?,
      exerciseHash: null == exerciseHash
          ? _value.exerciseHash
          : exerciseHash // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: null == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      prescription: null == prescription
          ? _value.prescription
          : prescription // ignore: cast_nullable_to_non_nullable
              as Prescription,
      variation: null == variation
          ? _value._variation
          : variation // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      defaultSetType: freezed == defaultSetType
          ? _value.defaultSetType
          : defaultSetType // ignore: cast_nullable_to_non_nullable
              as String?,
      info: freezed == info
          ? _value.info
          : info // ignore: cast_nullable_to_non_nullable
              as Info?,
      loggedSets: null == loggedSets
          ? _value._loggedSets
          : loggedSets // ignore: cast_nullable_to_non_nullable
              as List<LoggedSet>,
      isCurrent: null == isCurrent
          ? _value.isCurrent
          : isCurrent // ignore: cast_nullable_to_non_nullable
              as bool,
      unmapped: null == unmapped
          ? _value.unmapped
          : unmapped // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$SessionExerciseImpl implements SessionExercise {
  const _$SessionExerciseImpl(
      {required this.id,
      this.slug,
      required this.exerciseHash,
      required this.displayName,
      required this.prescription,
      required final Map<String, dynamic> variation,
      this.defaultSetType,
      this.info,
      final List<LoggedSet> loggedSets = const [],
      this.isCurrent = false,
      this.unmapped = false})
      : _variation = variation,
        _loggedSets = loggedSets;

  @override
  final String id;
  @override
  final String? slug;
  @override
  final String exerciseHash;
  @override
  final String displayName;
  @override
  final Prescription prescription;
  final Map<String, dynamic> _variation;
  @override
  Map<String, dynamic> get variation {
    if (_variation is EqualUnmodifiableMapView) return _variation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_variation);
  }

  @override
  final String? defaultSetType;
// NEW
  @override
  final Info? info;
  final List<LoggedSet> _loggedSets;
  @override
  @JsonKey()
  List<LoggedSet> get loggedSets {
    if (_loggedSets is EqualUnmodifiableListView) return _loggedSets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_loggedSets);
  }

  @override
  @JsonKey()
  final bool isCurrent;
  @override
  @JsonKey()
  final bool unmapped;

  @override
  String toString() {
    return 'SessionItem.exercise(id: $id, slug: $slug, exerciseHash: $exerciseHash, displayName: $displayName, prescription: $prescription, variation: $variation, defaultSetType: $defaultSetType, info: $info, loggedSets: $loggedSets, isCurrent: $isCurrent, unmapped: $unmapped)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SessionExerciseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.slug, slug) || other.slug == slug) &&
            (identical(other.exerciseHash, exerciseHash) ||
                other.exerciseHash == exerciseHash) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.prescription, prescription) ||
                other.prescription == prescription) &&
            const DeepCollectionEquality()
                .equals(other._variation, _variation) &&
            (identical(other.defaultSetType, defaultSetType) ||
                other.defaultSetType == defaultSetType) &&
            (identical(other.info, info) || other.info == info) &&
            const DeepCollectionEquality()
                .equals(other._loggedSets, _loggedSets) &&
            (identical(other.isCurrent, isCurrent) ||
                other.isCurrent == isCurrent) &&
            (identical(other.unmapped, unmapped) ||
                other.unmapped == unmapped));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      slug,
      exerciseHash,
      displayName,
      prescription,
      const DeepCollectionEquality().hash(_variation),
      defaultSetType,
      info,
      const DeepCollectionEquality().hash(_loggedSets),
      isCurrent,
      unmapped);

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SessionExerciseImplCopyWith<_$SessionExerciseImpl> get copyWith =>
      __$$SessionExerciseImplCopyWithImpl<_$SessionExerciseImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String id,
            String? slug,
            String exerciseHash,
            String displayName,
            Prescription prescription,
            Map<String, dynamic> variation,
            String? defaultSetType,
            Info? info,
            List<LoggedSet> loggedSets,
            bool isCurrent,
            bool unmapped)
        exercise,
    required TResult Function(
            String id, WarmupItem item, Map<String, String> selectedParameters)
        warmup,
    required TResult Function(String id, List<SessionExercise> exercises)
        superset,
  }) {
    return exercise(id, slug, exerciseHash, displayName, prescription,
        variation, defaultSetType, info, loggedSets, isCurrent, unmapped);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String id,
            String? slug,
            String exerciseHash,
            String displayName,
            Prescription prescription,
            Map<String, dynamic> variation,
            String? defaultSetType,
            Info? info,
            List<LoggedSet> loggedSets,
            bool isCurrent,
            bool unmapped)?
        exercise,
    TResult? Function(
            String id, WarmupItem item, Map<String, String> selectedParameters)?
        warmup,
    TResult? Function(String id, List<SessionExercise> exercises)? superset,
  }) {
    return exercise?.call(id, slug, exerciseHash, displayName, prescription,
        variation, defaultSetType, info, loggedSets, isCurrent, unmapped);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String id,
            String? slug,
            String exerciseHash,
            String displayName,
            Prescription prescription,
            Map<String, dynamic> variation,
            String? defaultSetType,
            Info? info,
            List<LoggedSet> loggedSets,
            bool isCurrent,
            bool unmapped)?
        exercise,
    TResult Function(
            String id, WarmupItem item, Map<String, String> selectedParameters)?
        warmup,
    TResult Function(String id, List<SessionExercise> exercises)? superset,
    required TResult orElse(),
  }) {
    if (exercise != null) {
      return exercise(id, slug, exerciseHash, displayName, prescription,
          variation, defaultSetType, info, loggedSets, isCurrent, unmapped);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SessionExercise value) exercise,
    required TResult Function(SessionWarmupItem value) warmup,
    required TResult Function(SessionSuperset value) superset,
  }) {
    return exercise(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SessionExercise value)? exercise,
    TResult? Function(SessionWarmupItem value)? warmup,
    TResult? Function(SessionSuperset value)? superset,
  }) {
    return exercise?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SessionExercise value)? exercise,
    TResult Function(SessionWarmupItem value)? warmup,
    TResult Function(SessionSuperset value)? superset,
    required TResult orElse(),
  }) {
    if (exercise != null) {
      return exercise(this);
    }
    return orElse();
  }
}

abstract class SessionExercise implements SessionItem {
  const factory SessionExercise(
      {required final String id,
      final String? slug,
      required final String exerciseHash,
      required final String displayName,
      required final Prescription prescription,
      required final Map<String, dynamic> variation,
      final String? defaultSetType,
      final Info? info,
      final List<LoggedSet> loggedSets,
      final bool isCurrent,
      final bool unmapped}) = _$SessionExerciseImpl;

  @override
  String get id;
  String? get slug;
  String get exerciseHash;
  String get displayName;
  Prescription get prescription;
  Map<String, dynamic> get variation;
  String? get defaultSetType; // NEW
  Info? get info;
  List<LoggedSet> get loggedSets;
  bool get isCurrent;
  bool get unmapped;

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SessionExerciseImplCopyWith<_$SessionExerciseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SessionWarmupItemImplCopyWith<$Res>
    implements $SessionItemCopyWith<$Res> {
  factory _$$SessionWarmupItemImplCopyWith(_$SessionWarmupItemImpl value,
          $Res Function(_$SessionWarmupItemImpl) then) =
      __$$SessionWarmupItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id, WarmupItem item, Map<String, String> selectedParameters});

  $WarmupItemCopyWith<$Res> get item;
}

/// @nodoc
class __$$SessionWarmupItemImplCopyWithImpl<$Res>
    extends _$SessionItemCopyWithImpl<$Res, _$SessionWarmupItemImpl>
    implements _$$SessionWarmupItemImplCopyWith<$Res> {
  __$$SessionWarmupItemImplCopyWithImpl(_$SessionWarmupItemImpl _value,
      $Res Function(_$SessionWarmupItemImpl) _then)
      : super(_value, _then);

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? item = null,
    Object? selectedParameters = null,
  }) {
    return _then(_$SessionWarmupItemImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      item: null == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as WarmupItem,
      selectedParameters: null == selectedParameters
          ? _value._selectedParameters
          : selectedParameters // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ));
  }

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $WarmupItemCopyWith<$Res> get item {
    return $WarmupItemCopyWith<$Res>(_value.item, (value) {
      return _then(_value.copyWith(item: value));
    });
  }
}

/// @nodoc

class _$SessionWarmupItemImpl implements SessionWarmupItem {
  const _$SessionWarmupItemImpl(
      {required this.id,
      required this.item,
      required final Map<String, String> selectedParameters})
      : _selectedParameters = selectedParameters;

  @override
  final String id;
  @override
  final WarmupItem item;
  final Map<String, String> _selectedParameters;
  @override
  Map<String, String> get selectedParameters {
    if (_selectedParameters is EqualUnmodifiableMapView)
      return _selectedParameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_selectedParameters);
  }

  @override
  String toString() {
    return 'SessionItem.warmup(id: $id, item: $item, selectedParameters: $selectedParameters)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SessionWarmupItemImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.item, item) || other.item == item) &&
            const DeepCollectionEquality()
                .equals(other._selectedParameters, _selectedParameters));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, item,
      const DeepCollectionEquality().hash(_selectedParameters));

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SessionWarmupItemImplCopyWith<_$SessionWarmupItemImpl> get copyWith =>
      __$$SessionWarmupItemImplCopyWithImpl<_$SessionWarmupItemImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String id,
            String? slug,
            String exerciseHash,
            String displayName,
            Prescription prescription,
            Map<String, dynamic> variation,
            String? defaultSetType,
            Info? info,
            List<LoggedSet> loggedSets,
            bool isCurrent,
            bool unmapped)
        exercise,
    required TResult Function(
            String id, WarmupItem item, Map<String, String> selectedParameters)
        warmup,
    required TResult Function(String id, List<SessionExercise> exercises)
        superset,
  }) {
    return warmup(id, item, selectedParameters);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String id,
            String? slug,
            String exerciseHash,
            String displayName,
            Prescription prescription,
            Map<String, dynamic> variation,
            String? defaultSetType,
            Info? info,
            List<LoggedSet> loggedSets,
            bool isCurrent,
            bool unmapped)?
        exercise,
    TResult? Function(
            String id, WarmupItem item, Map<String, String> selectedParameters)?
        warmup,
    TResult? Function(String id, List<SessionExercise> exercises)? superset,
  }) {
    return warmup?.call(id, item, selectedParameters);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String id,
            String? slug,
            String exerciseHash,
            String displayName,
            Prescription prescription,
            Map<String, dynamic> variation,
            String? defaultSetType,
            Info? info,
            List<LoggedSet> loggedSets,
            bool isCurrent,
            bool unmapped)?
        exercise,
    TResult Function(
            String id, WarmupItem item, Map<String, String> selectedParameters)?
        warmup,
    TResult Function(String id, List<SessionExercise> exercises)? superset,
    required TResult orElse(),
  }) {
    if (warmup != null) {
      return warmup(id, item, selectedParameters);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SessionExercise value) exercise,
    required TResult Function(SessionWarmupItem value) warmup,
    required TResult Function(SessionSuperset value) superset,
  }) {
    return warmup(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SessionExercise value)? exercise,
    TResult? Function(SessionWarmupItem value)? warmup,
    TResult? Function(SessionSuperset value)? superset,
  }) {
    return warmup?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SessionExercise value)? exercise,
    TResult Function(SessionWarmupItem value)? warmup,
    TResult Function(SessionSuperset value)? superset,
    required TResult orElse(),
  }) {
    if (warmup != null) {
      return warmup(this);
    }
    return orElse();
  }
}

abstract class SessionWarmupItem implements SessionItem {
  const factory SessionWarmupItem(
          {required final String id,
          required final WarmupItem item,
          required final Map<String, String> selectedParameters}) =
      _$SessionWarmupItemImpl;

  @override
  String get id;
  WarmupItem get item;
  Map<String, String> get selectedParameters;

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SessionWarmupItemImplCopyWith<_$SessionWarmupItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SessionSupersetImplCopyWith<$Res>
    implements $SessionItemCopyWith<$Res> {
  factory _$$SessionSupersetImplCopyWith(_$SessionSupersetImpl value,
          $Res Function(_$SessionSupersetImpl) then) =
      __$$SessionSupersetImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, List<SessionExercise> exercises});
}

/// @nodoc
class __$$SessionSupersetImplCopyWithImpl<$Res>
    extends _$SessionItemCopyWithImpl<$Res, _$SessionSupersetImpl>
    implements _$$SessionSupersetImplCopyWith<$Res> {
  __$$SessionSupersetImplCopyWithImpl(
      _$SessionSupersetImpl _value, $Res Function(_$SessionSupersetImpl) _then)
      : super(_value, _then);

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? exercises = null,
  }) {
    return _then(_$SessionSupersetImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      exercises: null == exercises
          ? _value._exercises
          : exercises // ignore: cast_nullable_to_non_nullable
              as List<SessionExercise>,
    ));
  }
}

/// @nodoc

class _$SessionSupersetImpl implements SessionSuperset {
  const _$SessionSupersetImpl(
      {required this.id, final List<SessionExercise> exercises = const []})
      : _exercises = exercises;

  @override
  final String id;
  final List<SessionExercise> _exercises;
  @override
  @JsonKey()
  List<SessionExercise> get exercises {
    if (_exercises is EqualUnmodifiableListView) return _exercises;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_exercises);
  }

  @override
  String toString() {
    return 'SessionItem.superset(id: $id, exercises: $exercises)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SessionSupersetImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._exercises, _exercises));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, id, const DeepCollectionEquality().hash(_exercises));

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SessionSupersetImplCopyWith<_$SessionSupersetImpl> get copyWith =>
      __$$SessionSupersetImplCopyWithImpl<_$SessionSupersetImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String id,
            String? slug,
            String exerciseHash,
            String displayName,
            Prescription prescription,
            Map<String, dynamic> variation,
            String? defaultSetType,
            Info? info,
            List<LoggedSet> loggedSets,
            bool isCurrent,
            bool unmapped)
        exercise,
    required TResult Function(
            String id, WarmupItem item, Map<String, String> selectedParameters)
        warmup,
    required TResult Function(String id, List<SessionExercise> exercises)
        superset,
  }) {
    return superset(id, exercises);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String id,
            String? slug,
            String exerciseHash,
            String displayName,
            Prescription prescription,
            Map<String, dynamic> variation,
            String? defaultSetType,
            Info? info,
            List<LoggedSet> loggedSets,
            bool isCurrent,
            bool unmapped)?
        exercise,
    TResult? Function(
            String id, WarmupItem item, Map<String, String> selectedParameters)?
        warmup,
    TResult? Function(String id, List<SessionExercise> exercises)? superset,
  }) {
    return superset?.call(id, exercises);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String id,
            String? slug,
            String exerciseHash,
            String displayName,
            Prescription prescription,
            Map<String, dynamic> variation,
            String? defaultSetType,
            Info? info,
            List<LoggedSet> loggedSets,
            bool isCurrent,
            bool unmapped)?
        exercise,
    TResult Function(
            String id, WarmupItem item, Map<String, String> selectedParameters)?
        warmup,
    TResult Function(String id, List<SessionExercise> exercises)? superset,
    required TResult orElse(),
  }) {
    if (superset != null) {
      return superset(id, exercises);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SessionExercise value) exercise,
    required TResult Function(SessionWarmupItem value) warmup,
    required TResult Function(SessionSuperset value) superset,
  }) {
    return superset(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SessionExercise value)? exercise,
    TResult? Function(SessionWarmupItem value)? warmup,
    TResult? Function(SessionSuperset value)? superset,
  }) {
    return superset?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SessionExercise value)? exercise,
    TResult Function(SessionWarmupItem value)? warmup,
    TResult Function(SessionSuperset value)? superset,
    required TResult orElse(),
  }) {
    if (superset != null) {
      return superset(this);
    }
    return orElse();
  }
}

abstract class SessionSuperset implements SessionItem {
  const factory SessionSuperset(
      {required final String id,
      final List<SessionExercise> exercises}) = _$SessionSupersetImpl;

  @override
  String get id;
  List<SessionExercise> get exercises;

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SessionSupersetImplCopyWith<_$SessionSupersetImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\presentation\session_screen.dart ----- 
// ----- lib/src/features/workout/presentation/session_screen.dart -----
// lib/src/features/workout/presentation/session_screen.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/exercises/data/presentation/exercise_picker_screen.dart';
import 'package:fairware_lift/src/features/exercises/domain/exercise.dart' as lib_exercise;
import 'package:fairware_lift/src/features/workout/application/session_state.dart';
import 'package:fairware_lift/src/features/workout/application/timer_state.dart';
import 'package:fairware_lift/src/features/workout/domain/session_item.dart';
import 'package:fairware_lift/src/features/workout_import/domain/lift_dsl.dart';
import 'package:fairware_lift/src/features/workout/presentation/widgets/exercise_list_item.dart';
import 'package:fairware_lift/src/features/workout/presentation/widgets/warmup_list_item.dart';
import 'package:fairware_lift/src/features/workout/presentation/widgets/workout_dock.dart';
import 'package:fairware_lift/src/features/workout/presentation/workout_summary_screen.dart';
import 'package:fairware_lift/src/features/workout_import/presentation/paste_workout_screen.dart';

class SessionScreen extends ConsumerStatefulWidget {
  const SessionScreen({super.key});
  @override
  ConsumerState<SessionScreen> createState() => _SessionScreenState();
}

class _SessionScreenState extends ConsumerState<SessionScreen> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(workoutMetricsProvider.notifier).startWorkout();
    });
  }

  @override
  void dispose() {
    ref.read(workoutMetricsProvider.notifier).stopWorkout();
    super.dispose();
  }

  void _showExerciseInfoSheet(BuildContext context, SessionExercise exercise) {
    final info = exercise.info;
    if (info == null) {
      _showSimpleInfoDialog(context, exercise.displayName, 'No additional information available for this exercise.');
    } else if (info.howTo != null && info.coachingCues == null && info.videoSearchQuery == null) {
      _showSimpleInfoDialog(context, exercise.displayName, info.howTo!);
    } else {
      showModalBottomSheet(
        context: context,
        isScrollControlled: true,
        backgroundColor: AppTheme.colors.surface,
        builder: (context) => DraggableScrollableSheet(
          expand: false,
          initialChildSize: 0.6,
          maxChildSize: 0.9,
          builder: (_, controller) => _ExerciseInfoSheet(controller: controller, info: info, exerciseName: exercise.displayName),
        ),
      );
    }
  }

  void _showSimpleInfoDialog(BuildContext context, String title, String content) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: AppTheme.colors.surface,
        title: Text(title),
        content: Text(content, style: AppTheme.typography.body),
        actions: [TextButton(onPressed: () => Navigator.of(context).pop(), child: const Text('Close'))],
      ),
    );
  }

  Future<bool?> _showDeleteItemConfirmationDialog(BuildContext context, {String itemType = 'Item'}) {
    return showDialog<bool>(
      context: context,
      builder: (context) {
        return AlertDialog(
          backgroundColor: AppTheme.colors.surface,
          title: Text('Delete $itemType?'),
          content: const Text('This action cannot be undone.'),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: Text(
                'Delete',
                style: TextStyle(color: AppTheme.colors.danger),
              ),
            ),
          ],
        );
      },
    );
  }


  @override
  Widget build(BuildContext context) {
    final sessionItems = ref.watch(sessionStateProvider);
    return Scaffold(
      appBar: AppBar(
        backgroundColor: AppTheme.colors.background,
        elevation: 0,
        title: const Text('Workout'),
        actions: [
          TextButton(
            onPressed: () {
              ref.read(workoutMetricsProvider.notifier).stopWorkout();
              Navigator.of(context).push(MaterialPageRoute(
                builder: (context) => WorkoutSummaryScreen(completedItems: ref.read(sessionStateProvider)),
              ));
            },
            child: const Text('Finish'),
          ),
        ],
      ),
      // --- MODIFIED: Removed the FloatingActionButton ---
      bottomNavigationBar: const WorkoutDock(),
      body: SafeArea(
        child: ListView(
          padding: const EdgeInsets.fromLTRB(8, 8, 8, 150),
          children: [
            if (sessionItems.isEmpty) _buildEmptyState(context)
            else ReorderableListView(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              onReorder: (oldIndex, newIndex) => ref.read(sessionStateProvider.notifier).reorderItem(oldIndex, newIndex),
              children: sessionItems.map((item) {
                return switch (item) {
                  SessionExercise e => Dismissible(
                      key: ValueKey(item.id),
                      direction: DismissDirection.endToStart,
                      confirmDismiss: (direction) => _showDeleteItemConfirmationDialog(context, itemType: 'Exercise'),
                      onDismissed: (_) => ref.read(sessionStateProvider.notifier).deleteItem(item.id),
                      background: _buildDismissBackground(),
                      child: ExerciseListItem(
                        displayName: e.displayName,
                        prescription: e.prescription,
                        variation: e.variation,
                        loggedSets: e.loggedSets,
                        isCurrent: e.isCurrent,
                        onCardTap: () => ref.read(sessionStateProvider.notifier).setCurrentItem(itemId: e.id),
                        onInfoTap: () => _showExerciseInfoSheet(context, e),
                        setType: e.defaultSetType,
                      ),
                    ),
                  SessionWarmupItem w => Dismissible(
                      key: ValueKey(item.id),
                      direction: DismissDirection.endToStart,
                      confirmDismiss: (direction) => _showDeleteItemConfirmationDialog(context, itemType: 'Warmup'),
                      onDismissed: (_) => ref.read(sessionStateProvider.notifier).deleteItem(item.id),
                      background: _buildDismissBackground(),
                      child: WarmupListItem(warmup: w),
                    ),
                  SessionSuperset s => _SupersetListItem(
                      key: ValueKey(item.id),
                      superset: s,
                      onInfoTap: (exercise) => _showExerciseInfoSheet(context, exercise),
                      onDeleteConfirm: _showDeleteItemConfirmationDialog,
                    ),
                };
              }).toList(),
            ),
          ],
        ),
      ),
    );
  }

  Container _buildDismissBackground() => Container(
    color: AppTheme.colors.danger,
    margin: const EdgeInsets.symmetric(vertical: 4.0),
    alignment: Alignment.centerRight,
    padding: const EdgeInsets.symmetric(horizontal: 20.0),
    child: const Icon(Icons.delete_forever_rounded, color: Colors.white),
  );

  Widget _buildEmptyState(BuildContext context) => Center(
    child: Padding(
      padding: const EdgeInsets.symmetric(vertical: 64.0, horizontal: 16.0),
      child: Column(
        children: [
          Icon(Icons.directions_run_rounded, size: 64, color: AppTheme.colors.textMuted),
          const SizedBox(height: 16),
          Text('Your session is empty.', style: AppTheme.typography.title),
          const SizedBox(height: 8),
          Text('Import a workout or add an exercise to get started.', style: AppTheme.typography.body, textAlign: TextAlign.center),
          const SizedBox(height: 24),
          ElevatedButton.icon(
            onPressed: () => Navigator.of(context).push(MaterialPageRoute(fullscreenDialog: true, builder: (context) => const PasteWorkoutScreen())),
            icon: const Icon(Icons.paste_rounded),
            label: const Text('Import from Text'),
          ),
        ],
      ),
    ),
  );
}

class _SupersetListItem extends ConsumerWidget {
  final SessionSuperset superset;
  final void Function(SessionExercise) onInfoTap;
  final Future<bool?> Function(BuildContext, {String itemType}) onDeleteConfirm;

  const _SupersetListItem({
    super.key, 
    required this.superset, 
    required this.onInfoTap,
    required this.onDeleteConfirm,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      key: key,
      color: AppTheme.colors.surface,
      elevation: 0,
      margin: const EdgeInsets.symmetric(vertical: 4.0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
        side: BorderSide(color: AppTheme.colors.surfaceAlt, width: 2),
      ),
      child: Padding(
        padding: const EdgeInsets.all(8.0),
        child: Column(
          children: [
            ListTile(
              leading: Icon(Icons.link_rounded, color: AppTheme.colors.textMuted),
              title: Text('Superset', style: AppTheme.typography.body.copyWith(color: AppTheme.colors.textMuted)),
              dense: true,
            ),
            ...superset.exercises.map((exercise) => Dismissible(
              key: ValueKey(exercise.id),
              direction: DismissDirection.endToStart,
              confirmDismiss: (direction) => onDeleteConfirm(context, itemType: 'Exercise'),
              onDismissed: (_) => ref.read(sessionStateProvider.notifier).deleteExerciseFromSuperset(supersetId: superset.id, exerciseId: exercise.id),
              background: Container(color: AppTheme.colors.danger, alignment: Alignment.centerRight, padding: const EdgeInsets.symmetric(horizontal: 20.0), child: const Icon(Icons.delete_forever_rounded, color: Colors.white)),
              child: ExerciseListItem(
                displayName: exercise.displayName,
                prescription: exercise.prescription,
                variation: exercise.variation,
                loggedSets: exercise.loggedSets,
                isCurrent: exercise.isCurrent,
                onCardTap: () => ref.read(sessionStateProvider.notifier).setCurrentItem(itemId: exercise.id),
                onInfoTap: () => onInfoTap(exercise),
                setType: exercise.defaultSetType,
              ),
            )),
          ],
        ),
      ),
    );
  }
}


class _ExerciseInfoSheet extends StatelessWidget {
  final ScrollController controller;
  final Info info;
  final String exerciseName;
  const _ExerciseInfoSheet({required this.controller, required this.info, required this.exerciseName});

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: ListView(
        controller: controller,
        padding: const EdgeInsets.all(24),
        children: [
          Text(exerciseName, style: AppTheme.typography.display.copyWith(fontSize: 28)),
          const SizedBox(height: 24),
          if (info.howTo != null) _buildSection('How To', Text(info.howTo!, style: AppTheme.typography.body)),
          if (info.coachingCues?.isNotEmpty ?? false) _buildSection('Coaching Cues', _buildBulletList(info.coachingCues!)),
          if (info.commonErrors?.isNotEmpty ?? false) _buildSection('Common Errors', _buildBulletList(info.commonErrors!)),
          if (info.safetyNotes != null) _buildSection('Safety', Text(info.safetyNotes!, style: AppTheme.typography.body)),
          if (info.progression != null) _buildSection('Progression', Text(info.progression!, style: AppTheme.typography.body)),
          if (info.regression != null) _buildSection('Regression', Text(info.regression!, style: AppTheme.typography.body)),
          if (info.equipmentNotes != null) _buildSection('Equipment', Text(info.equipmentNotes!, style: AppTheme.typography.body)),
          const SizedBox(height: 24),
          Row(
            children: [
              if (info.videoSearchQuery != null) Expanded(child: _buildSearchButton(icon: Icons.video_library_rounded, label: 'Search Video', query: info.videoSearchQuery!, isVideo: true)),
              if (info.videoSearchQuery != null && info.webSearchQuery != null) const SizedBox(width: 16),
              if (info.webSearchQuery != null) Expanded(child: _buildSearchButton(icon: Icons.search, label: 'Search Web', query: info.webSearchQuery!)),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildSection(String title, Widget content) => Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      Text(title, style: AppTheme.typography.title),
      const SizedBox(height: 8),
      content,
      const SizedBox(height: 24),
    ],
  );

  Widget _buildBulletList(List<String> items) => Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: items.map((item) => Padding(
      padding: const EdgeInsets.only(bottom: 4.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(' ', style: TextStyle(fontSize: 16)),
          Expanded(child: Text(item, style: AppTheme.typography.body)),
        ],
      ),
    )).toList(),
  );

  Widget _buildSearchButton({required IconData icon, required String label, required String query, bool isVideo = false}) {
    return ElevatedButton.icon(
      onPressed: () async {
        final url = isVideo
            ? Uri.https('youtube.com', '/results', {'search_query': query})
            : Uri.https('google.com', '/search', {'q': query});
        if (await canLaunchUrl(url)) {
          await launchUrl(url, mode: LaunchMode.externalApplication);
        }
      },
      icon: Icon(icon),
      label: Text(label),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\presentation\start_workout_options_screen.dart ----- 
// lib/src/features/workout/presentation/start_workout_options_screen.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/workout/application/session_state.dart';
import 'package:fairware_lift/src/features/workout/presentation/session_screen.dart';
import 'package:fairware_lift/src/features/workout_import/presentation/paste_workout_screen.dart';

// -----------------------------------------------------------------------------
// --- START WORKOUT OPTIONS SCREEN WIDGET -------------------------------------
// -----------------------------------------------------------------------------

class StartWorkoutOptionsScreen extends ConsumerWidget {
  const StartWorkoutOptionsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return SafeArea(
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Start Workout'),
          backgroundColor: AppTheme.colors.surface,
          elevation: 0,
          automaticallyImplyLeading: true,
        ),
        body: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: 16),
                _buildOptionCard(
                  context: context,
                  icon: Icons.play_circle_outline_rounded,
                  title: 'Quick Workout',
                  subtitle: 'Start an empty session',
                  onTap: () {
                    ref.invalidate(sessionStateProvider);
                    Navigator.of(context).push(
                      MaterialPageRoute(
                        fullscreenDialog: true,
                        builder: (context) => const SessionScreen(),
                      ),
                    );
                  },
                ),
                const SizedBox(height: 16),
                _buildOptionCard(
                  context: context,
                  icon: Icons.paste_rounded,
                  title: 'Import from Text',
                  subtitle: 'Paste a workout from an LLM',
                  onTap: () {
                    Navigator.of(context).push(
                      MaterialPageRoute(
                        fullscreenDialog: true,
                        builder: (context) => const PasteWorkoutScreen(),
                      ),
                    );
                  },
                ),
                const SizedBox(height: 16),
                _buildOptionCard(
                  context: context,
                  icon: Icons.list_alt_rounded,
                  title: 'Choose from Program',
                  subtitle: 'Select a planned day',
                  onTap: () {
                    print('Choose from Program selected');
                  },
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildOptionCard({
    required BuildContext context,
    required IconData icon,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    return Card(
      color: AppTheme.colors.surfaceAlt,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
      ),
      elevation: 0,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            children: [
              Icon(
                icon,
                size: 48,
                color: AppTheme.colors.accent,
              ),
              const SizedBox(height: 16),
              Text(
                title,
                style: AppTheme.typography.title,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 4),
              Text(
                subtitle,
                style: AppTheme.typography.body,
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\presentation\workout_summary_screen.dart ----- 
// lib/src/features/workout/presentation/workout_summary_screen.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:drift/drift.dart' as drift;
import 'package:uuid/uuid.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/core/theme/data/local/database.dart';
import 'package:fairware_lift/src/features/workout/application/session_state.dart';
import 'package:fairware_lift/src/features/workout/application/timer_state.dart';
import 'package:fairware_lift/src/features/workout/domain/session_item.dart';
import 'package:fairware_lift/src/features/workout/domain/logged_set.dart';

// -----------------------------------------------------------------------------
// --- WORKOUT SUMMARY SCREEN WIDGET -------------------------------------------
// -----------------------------------------------------------------------------

class WorkoutSummaryScreen extends ConsumerWidget {
  final List<SessionItem> completedItems;

  const WorkoutSummaryScreen({
    super.key,
    required this.completedItems,
  });

  String _formatDuration(int totalSeconds) {
    if (totalSeconds < 0) return "0s";
    final duration = Duration(seconds: totalSeconds);
    final hours = duration.inHours;
    final minutes = duration.inMinutes.remainder(60);
    final seconds = duration.inSeconds.remainder(60);
    final parts = <String>[];
    if (hours > 0) parts.add('${hours}h');
    if (minutes > 0) parts.add('${minutes}m');
    if (seconds > 0 || parts.isEmpty) parts.add('${seconds}s');
    return parts.join(' ');
  }

  Future<void> _saveWorkout(BuildContext context, WidgetRef ref) async {
    final db = ref.read(databaseProvider);
    final metrics = ref.read(workoutMetricsProvider);
    const uuid = Uuid();
    final now = DateTime.now();
    final sessionId = uuid.v4();

    final sessionCompanion = SessionsCompanion(
      id: drift.Value(sessionId),
      sessionDateTime: drift.Value(now),
      totalDurationSeconds: drift.Value(metrics.totalDurationSeconds),
      totalActivitySeconds: drift.Value(metrics.totalActivitySeconds),
      totalRestSeconds: drift.Value(metrics.totalRestSeconds),
      createdAt: drift.Value(now),
      updatedAt: drift.Value(now),
    );

    final setEntriesCompanion = <SetEntriesCompanion>[];
    final exerciseInstancesToSave = <ExerciseInstancesCompanion>[];
    final savedWarmupsCompanion = <SavedWarmupsCompanion>[];

    for (final item in completedItems) {
      switch (item) {
        case SessionExercise e when e.loggedSets.isNotEmpty && !e.unmapped:
          _processExerciseForSaving(e, sessionId, now, exerciseInstancesToSave, setEntriesCompanion);
        case SessionWarmupItem w:
          savedWarmupsCompanion.add(
            SavedWarmupsCompanion(
              id: drift.Value(uuid.v4()),
              sessionId: drift.Value(sessionId),
              warmupId: drift.Value(w.item.id),
              displayName: drift.Value(w.item.displayName),
              parameters: drift.Value(w.selectedParameters),
              createdAt: drift.Value(now),
            ),
          );
        case SessionSuperset s:
          for (final exerciseInSuperset in s.exercises) {
            if (exerciseInSuperset.loggedSets.isNotEmpty && !exerciseInSuperset.unmapped) {
              _processExerciseForSaving(exerciseInSuperset, sessionId, now, exerciseInstancesToSave, setEntriesCompanion);
            }
          }
        case _:
      }
    }

    if (setEntriesCompanion.isEmpty && savedWarmupsCompanion.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Empty or unmapped workout discarded.')),
      );
      Navigator.of(context).popUntil((route) => route.isFirst);
      return;
    }

    await db.transaction(() async {
      await db.into(db.sessions).insert(sessionCompanion);
      for (final instance in exerciseInstancesToSave) {
        await db.into(db.exerciseInstances).insertOnConflictUpdate(instance);
      }
      if (setEntriesCompanion.isNotEmpty) {
        await db.batch((batch) {
          batch.insertAll(db.setEntries, setEntriesCompanion);
        });
      }
      if (savedWarmupsCompanion.isNotEmpty) {
        await db.batch((batch) {
          batch.insertAll(db.savedWarmups, savedWarmupsCompanion);
        });
      }
    });

    if (context.mounted) {
      await ScaffoldMessenger.of(context)
          .showSnackBar(
            const SnackBar(content: Text('Workout Saved!')),
          )
          .closed;
      ref.invalidate(sessionStateProvider);
      ref.invalidate(workoutMetricsProvider);
      Navigator.of(context).popUntil((route) => route.isFirst);
    }
  }

  void _processExerciseForSaving(
    SessionExercise e,
    String sessionId,
    DateTime now,
    List<ExerciseInstancesCompanion> exerciseInstancesToSave,
    List<SetEntriesCompanion> setEntriesCompanion,
  ) {
    if (e.slug == null) return;

    const uuid = Uuid();
    final familyId = e.slug!.split('.').first;
    final discriminators = e.variation.map((key, value) => MapEntry(key, value.toString()));

    exerciseInstancesToSave.add(
      ExerciseInstancesCompanion(
        slug: drift.Value(e.slug!),
        familyId: drift.Value(familyId),
        displayName: drift.Value(e.displayName),
        discriminators: drift.Value(discriminators),
        firstSeenAt: drift.Value(now),
      ),
    );

    for (int i = 0; i < e.loggedSets.length; i++) {
      final set = e.loggedSets[i];
      final companion = SetEntriesCompanion(
        id: drift.Value(uuid.v4()),
        sessionId: drift.Value(sessionId),
        exerciseSlug: drift.Value(e.slug!),
        setOrder: drift.Value(i + 1),
        weight: drift.Value(set.weight ?? 0),
        reps: drift.Value(set.reps ?? 0),
        setType: drift.Value(set.setType),
        durationSeconds: drift.Value(set.durationSeconds),
        distanceM: drift.Value(set.distanceM),
        calories: drift.Value(set.calories),
        rpe: drift.Value(set.rpe),
        metricsJson: drift.Value(jsonEncode(set.metrics)),
        prescriptionJson: drift.Value(set.prescriptionSnapshot == null ? null : jsonEncode(set.prescriptionSnapshot)),
        createdAt: drift.Value(now),
        updatedAt: drift.Value(now),
      );
      setEntriesCompanion.add(companion);
    }
  }

  String _mmss(int? secs) {
    final s = secs ?? 0;
    final m = s ~/ 60;
    final r = s % 60;
    return '${m.toString().padLeft(1, '0')}:${r.toString().padLeft(2, '0')}';
  }

  String _fmtMetrics(Map<String, dynamic> m) {
    final incline = m['incline'];
    final speed = m['speed_mph'];
    final bits = <String>[];
    if (incline != null) bits.add('incline $incline');
    if (speed != null) bits.add('$speed mph');
    return bits.isEmpty ? '' : ' @ ${bits.join('  ')}';
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final metrics = ref.watch(workoutMetricsProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Workout Summary'),
        actions: [
          TextButton(
            onPressed: () => _saveWorkout(context, ref),
            child: const Text('Save'),
          ),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(8.0),
        children: [
          _buildMetricsCard(metrics),
          ...completedItems.map((item) {
            return switch (item) {
              SessionExercise e when e.loggedSets.isNotEmpty =>
                _buildExerciseSummary(e),
              SessionWarmupItem w => _buildWarmupSummary(w),
              SessionSuperset s when s.exercises.any((e) => e.loggedSets.isNotEmpty) =>
                _buildSupersetSummary(s),
              _ => const SizedBox.shrink(),
            };
          }),
        ],
      ),
    );
  }

  Widget _buildMetricsCard(WorkoutMetrics metrics) {
    return Card(
      color: AppTheme.colors.surface,
      margin: const EdgeInsets.symmetric(vertical: 4.0, horizontal: 4.0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            _buildMetricItem(
              icon: Icons.timer_outlined,
              label: 'Duration',
              value: _formatDuration(metrics.totalDurationSeconds),
            ),
            _buildMetricItem(
              icon: Icons.local_fire_department_outlined,
              label: 'Activity',
              value: _formatDuration(metrics.totalActivitySeconds),
            ),
            _buildMetricItem(
              icon: Icons.pause_circle_outline,
              label: 'Rest',
              value: _formatDuration(metrics.totalRestSeconds),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMetricItem({required IconData icon, required String label, required String value}) {
    return Column(
      children: [
        Icon(icon, color: AppTheme.colors.textMuted, size: 28),
        const SizedBox(height: 8),
        Text(label, style: AppTheme.typography.caption),
        const SizedBox(height: 4),
        Text(value, style: AppTheme.typography.title.copyWith(fontSize: 18)),
      ],
    );
  }

  Widget _buildExerciseSummary(SessionExercise exercise) {
    return Card(
      color: AppTheme.colors.surface,
      margin: const EdgeInsets.symmetric(vertical: 4.0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              exercise.displayName,
              style: AppTheme.typography.title.copyWith(fontSize: 20),
            ),
            const SizedBox(height: 12),
            ...exercise.loggedSets.asMap().entries.map((entry) {
              final setIndex = entry.key + 1;
              final set = entry.value;
              final details = switch (set.setType) {
                'timed' => '${_mmss(set.durationSeconds)}${_fmtMetrics(set.metrics)}',
                'reps_only' => '${set.reps} reps',
                _ => '${set.weight} lb x ${set.reps} reps',
              };
              return Padding(
                padding: const EdgeInsets.symmetric(vertical: 2.0),
                child: Text(
                  'Set $setIndex: $details',
                  style: AppTheme.typography.body,
                ),
              );
            }),
          ],
        ),
      ),
    );
  }

  Widget _buildWarmupSummary(SessionWarmupItem warmup) {
    final subtitle = warmup.selectedParameters.entries
        .map((e) => '${e.key}: ${e.value}')
        .join('    ');

    return Card(
      color: AppTheme.colors.surface,
      margin: const EdgeInsets.symmetric(vertical: 4.0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              warmup.item.displayName,
              style: AppTheme.typography.body
                  .copyWith(color: AppTheme.colors.textPrimary),
            ),
            if (subtitle.isNotEmpty) ...[
              const SizedBox(height: 4),
              Text(
                subtitle,
                style: AppTheme.typography.caption,
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildSupersetSummary(SessionSuperset superset) {
    return Card(
      color: AppTheme.colors.surface,
      margin: const EdgeInsets.symmetric(vertical: 4.0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
        side: BorderSide(color: AppTheme.colors.surfaceAlt, width: 2),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(Icons.link_rounded, color: AppTheme.colors.textMuted),
                const SizedBox(width: 8),
                Text(
                  'Superset',
                  style: AppTheme.typography.title.copyWith(fontSize: 20),
                ),
              ],
            ),
            const Divider(height: 24),
            ...superset.exercises.where((e) => e.loggedSets.isNotEmpty).map((exercise) {
              return Padding(
                padding: const EdgeInsets.only(bottom: 12.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      exercise.displayName,
                      style: AppTheme.typography.body.copyWith(fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 8),
                    ...exercise.loggedSets.asMap().entries.map((entry) {
                      final setIndex = entry.key + 1;
                      final set = entry.value;
                      final details = switch (set.setType) {
                        'timed' => '${_mmss(set.durationSeconds)}${_fmtMetrics(set.metrics)}',
                        'reps_only' => '${set.reps} reps',
                         _ => '${set.weight} lb x ${set.reps} reps',
                      };
                      return Padding(
                        padding: const EdgeInsets.only(left: 8.0, top: 2.0),
                        child: Text(
                          'Set $setIndex: $details',
                          style: AppTheme.typography.body,
                        ),
                      );
                    }),
                  ],
                ),
              );
            }),
          ],
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\presentation\widgets\duration_picker_sheet.dart ----- 
// lib/src/features/workout/presentation/widgets/duration_picker_sheet.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';

// -----------------------------------------------------------------------------
// --- DURATION PICKER SHEET WIDGET --------------------------------------------
// -----------------------------------------------------------------------------

/// A custom bottom sheet for selecting a duration using flat, scrollable lists.
class DurationPickerSheet extends StatefulWidget {
  final Duration initialDuration;

  const DurationPickerSheet({
    super.key,
    this.initialDuration = const Duration(minutes: 1, seconds: 30),
  });

  @override
  State<DurationPickerSheet> createState() => _DurationPickerSheetState();
}

class _DurationPickerSheetState extends State<DurationPickerSheet> {
  late int _selectedMinutes;
  late int _selectedSeconds;

  @override
  void initState() {
    super.initState();
    _selectedMinutes = widget.initialDuration.inMinutes;
    _selectedSeconds = widget.initialDuration.inSeconds % 60;
  }

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: SizedBox(
        height: 300,
        child: Column(
          children: [
            // --- PICKER UI ---
            Expanded(
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  // --- MINUTES PICKER ---
                  _buildPicker(
                    itemCount: 60, // 0-59 minutes
                    initialItem: _selectedMinutes,
                    suffix: ' min',
                    onChanged: (value) {
                      setState(() {
                        _selectedMinutes = value;
                      });
                    },
                  ),
                  // --- SECONDS PICKER ---
                  _buildPicker(
                    itemCount: 60, // 0-59 seconds
                    initialItem: _selectedSeconds,
                    suffix: ' sec',
                    onChanged: (value) {
                      setState(() {
                        _selectedSeconds = value;
                      });
                    },
                  ),
                ],
              ),
            ),
            // --- CONFIRMATION BUTTON ---
            TextButton(
              child: Text(
                'Start Rest',
                style: AppTheme.typography.body.copyWith(
                  color: AppTheme.colors.accent,
                  fontWeight: FontWeight.bold,
                ),
              ),
              onPressed: () {
                final totalDuration =
                    Duration(minutes: _selectedMinutes, seconds: _selectedSeconds);
                // Return the selected duration to the calling widget.
                Navigator.of(context).pop(totalDuration);
              },
            ),
            const SizedBox(height: 16),
          ],
        ),
      ),
    );
  }

  /// Helper method to build a single scrollable list for minutes or seconds.
  Widget _buildPicker({
    required int itemCount,
    required int initialItem,
    required String suffix,
    required ValueChanged<int> onChanged,
  }) {
    return Expanded(
      child: ListWheelScrollView.useDelegate(
        itemExtent: 50,
        // These properties create the flat look instead of a 3D cylinder.
        magnification: 1.0,
        useMagnifier: false,
        // This removes the 3D perspective effect.
        offAxisFraction: 0.0,
        physics: const FixedExtentScrollPhysics(),
        controller: FixedExtentScrollController(initialItem: initialItem),
        onSelectedItemChanged: onChanged,
        childDelegate: ListWheelChildBuilderDelegate(
          builder: (context, index) {
            return Center(
              child: Text(
                '$index$suffix',
                style: AppTheme.typography.title.copyWith(fontSize: 20),
              ),
            );
          },
          childCount: itemCount,
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\presentation\widgets\exercise_list_item.dart ----- 
// ----- lib/src/features/workout/presentation/widgets/exercise_list_item.dart -----
// lib/src/features/workout/presentation/widgets/exercise_list_item.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/workout/application/session_state.dart';
import 'package:fairware_lift/src/features/workout/domain/logged_set.dart';
import 'package:fairware_lift/src/features/workout_import/domain/lift_dsl.dart';
import 'package:fairware_lift/src/features/workout/presentation/widgets/set_sheet.dart';
import 'package:fairware_lift/src/features/workout/presentation/widgets/timed_set_sheet.dart';
import 'package:fairware_lift/src/features/workout/presentation/widgets/reps_only_set_sheet.dart';

// -----------------------------------------------------------------------------
// --- EXERCISE LIST ITEM WIDGET -----------------------------------------------
// -----------------------------------------------------------------------------

class ExerciseListItem extends ConsumerWidget {
  final String displayName;
  final Prescription prescription;
  final Map<String, dynamic> variation;
  final bool isCurrent;
  final List<LoggedSet> loggedSets;
  final VoidCallback onInfoTap;
  final VoidCallback onCardTap;
  final String? setType;

  const ExerciseListItem({
    super.key,
    required this.displayName,
    required this.prescription,
    required this.variation,
    required this.loggedSets,
    required this.onInfoTap,
    required this.onCardTap,
    this.isCurrent = false,
    this.setType,
  });

  String _mmss(int? secs) {
    final s = secs ?? 0;
    final m = s ~/ 60;
    final r = s % 60;
    return '${m.toString().padLeft(1, '0')}:${r.toString().padLeft(2, '0')}';
  }

  String _fmtMetrics(Map<String, dynamic> m) {
    final incline = m['incline'];
    final speed = m['speed_mph'];
    final bits = <String>[];
    if (incline != null) bits.add('incline $incline');
    if (speed != null) bits.add('$speed mph');
    return bits.isEmpty ? '' : ' @ ${bits.join('  ')}';
  }

  void _showSetSheet(BuildContext context, WidgetRef ref, {LoggedSet? setToEdit}) async {
    final effectiveSetType = setToEdit?.setType ?? setType;

    if (effectiveSetType == 'timed') {
      final result = await showModalBottomSheet<Map<String, dynamic>>(
        context: context,
        isScrollControlled: true,
        backgroundColor: AppTheme.colors.surface,
        builder: (context) => TimedSetSheet(set: setToEdit),
      );
      if (result != null) {
        final String? id = result['id'];
        if (id != null && setToEdit != null) {
          final updatedSet = setToEdit.copyWith(
            durationSeconds: result['durationSeconds'] as int,
            metrics: result['metrics'] as Map<String, dynamic>,
          );
          ref.read(sessionStateProvider.notifier).updateSet(updatedSet);
        } else {
          ref.read(sessionStateProvider.notifier).logTimed(
                durationSeconds: result['durationSeconds'] as int,
                metrics: result['metrics'] as Map<String, dynamic>,
              );
        }
      }
    } else if (effectiveSetType == 'reps_only') {
      final result = await showModalBottomSheet<Map<String, dynamic>>(
        context: context,
        isScrollControlled: true,
        backgroundColor: AppTheme.colors.surface,
        builder: (context) => RepsOnlySetSheet(set: setToEdit),
      );
      if (result != null) {
        final String? id = result['id'];
        final reps = result['reps'] as int;
        if (id != null && setToEdit != null) {
          final updatedSet = setToEdit.copyWith(reps: reps);
          ref.read(sessionStateProvider.notifier).updateSet(updatedSet);
        } else {
          final bodyweight = result['weight'] as double;
          ref.read(sessionStateProvider.notifier).logRepsOnlySet(
                reps: reps,
                bodyweight: bodyweight,
              );
        }
      }
    } else { // Default to weight/reps
      final result = await showModalBottomSheet<Map<String, dynamic>>(
        context: context,
        isScrollControlled: true,
        backgroundColor: AppTheme.colors.surface,
        builder: (context) => SetSheet(set: setToEdit),
      );
      if (result != null) {
        final String? id = result['id'];
        final weight = result['weight'] as double;
        final reps = result['reps'] as int;
        if (id != null && setToEdit != null) {
          final updatedSet = setToEdit.copyWith(weight: weight, reps: reps);
          ref.read(sessionStateProvider.notifier).updateSet(updatedSet);
        } else {
          ref.read(sessionStateProvider.notifier).logWeightReps(
                weight: weight,
                reps: reps,
              );
        }
      }
    }
  }

  // --- NEW: Confirmation dialog for deleting a set ---
  Future<bool?> _showDeleteConfirmationDialog(BuildContext context) {
    return showDialog<bool>(
      context: context,
      builder: (context) {
        return AlertDialog(
          backgroundColor: AppTheme.colors.surface,
          title: const Text('Delete Set?'),
          content: const Text('Are you sure you want to delete this set? This action cannot be undone.'),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: Text(
                'Delete',
                style: TextStyle(color: AppTheme.colors.danger),
              ),
            ),
          ],
        );
      },
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final reps = prescription.reps?.toString() ?? '';
    final sets = prescription.sets?.toString() ?? '';
    final targetString = (sets.isNotEmpty && reps.isNotEmpty) ? '$sets x $reps' : reps;

    return Card(
      color: isCurrent ? AppTheme.colors.surfaceAlt : AppTheme.colors.surface,
      elevation: 0,
      margin: const EdgeInsets.symmetric(vertical: 4.0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
        side: isCurrent
            ? BorderSide(color: AppTheme.colors.accent, width: 2)
            : BorderSide.none,
      ),
      child: InkWell(
        onTap: onCardTap,
        borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    child: Text(
                      displayName,
                      style: AppTheme.typography.title.copyWith(fontSize: 20),
                      overflow: TextOverflow.ellipsis,
                      maxLines: 2,
                    ),
                  ),
                  const SizedBox(width: 8),
                  Row(
                    children: [
                      Text(
                        targetString,
                        style: AppTheme.typography.body,
                      ),
                      const SizedBox(width: 4),
                      IconButton(
                        icon: const Icon(Icons.info_outline_rounded),
                        onPressed: onInfoTap,
                        color: AppTheme.colors.textMuted,
                        padding: EdgeInsets.zero,
                        constraints: const BoxConstraints(),
                      ),
                    ],
                  ),
                ],
              ),
              const SizedBox(height: 16),
              ...loggedSets.asMap().entries.map((entry) {
                final index = entry.key;
                final set = entry.value;
                final details = switch (set.setType) {
                  'timed' => '${_mmss(set.durationSeconds)}${_fmtMetrics(set.metrics)}',
                  'reps_only' => '${set.reps} reps',
                  _ => '${set.weight} lb x ${set.reps} reps',
                };
                return _buildSetRow(
                  context: context,
                  set: set,
                  setNumber: index + 1,
                  details: details,
                  onTap: () => _showSetSheet(context, ref, setToEdit: set),
                  onDismissed: () => ref.read(sessionStateProvider.notifier).deleteSet(setId: set.id),
                );
              }),
              if (isCurrent) ...[
                const SizedBox(height: 16),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton.icon(
                    onPressed: () => _showSetSheet(context, ref),
                    icon: const Icon(Icons.add_rounded),
                    label: const Text('Add Set'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppTheme.colors.accent.withOpacity(0.2),
                      foregroundColor: AppTheme.colors.accent,
                      elevation: 0,
                    ),
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSetRow({
    required BuildContext context,
    required LoggedSet set,
    required int setNumber,
    required String details,
    required VoidCallback onTap,
    required VoidCallback onDismissed,
  }) {
    return Dismissible(
      key: ValueKey(set.id),
      direction: DismissDirection.endToStart,
      // --- NEW: Added confirmation dialog ---
      confirmDismiss: (direction) async {
        return await _showDeleteConfirmationDialog(context);
      },
      onDismissed: (_) => onDismissed(),
      background: Container(
        decoration: BoxDecoration(
          color: AppTheme.colors.danger,
          borderRadius: BorderRadius.circular(AppTheme.sizing.chipRadius),
        ),
        margin: const EdgeInsets.symmetric(vertical: 2.0),
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.symmetric(horizontal: 20.0),
        child: const Icon(Icons.delete_sweep_rounded, color: Colors.white),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(AppTheme.sizing.chipRadius),
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 4.0),
          child: Row(
            children: [
              Container(
                width: 32,
                height: 32,
                alignment: Alignment.center,
                decoration: BoxDecoration(
                  color: AppTheme.colors.background,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  setNumber.toString(),
                  style: AppTheme.typography.body.copyWith(
                    color: AppTheme.colors.textSecondary,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Text(
                  details,
                  style: AppTheme.typography.body,
                ),
              ),
              Icon(
                Icons.edit_note_rounded,
                color: AppTheme.colors.surface, // Hidden until hovered
                size: 20,
              ),
            ],
          ),
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\presentation\widgets\keypad_duration_picker.dart ----- 
// lib/src/features/workout/presentation/widgets/keypad_duration_picker.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';

// -----------------------------------------------------------------------------
// --- KEYPAD DURATION PICKER WIDGET -------------------------------------------
// -----------------------------------------------------------------------------

/// A custom bottom sheet for selecting a duration using a keypad interface.
/// This version treats the input as total seconds.
class KeypadDurationPicker extends StatefulWidget {
  const KeypadDurationPicker({super.key});

  @override
  State<KeypadDurationPicker> createState() => _KeypadDurationPickerState();
}

class _KeypadDurationPickerState extends State<KeypadDurationPicker> {
  // Stores the raw digits entered by the user, e.g., "90" for 90 seconds.
  String _input = '';

  /// --- UI/LOGIC FIX ---
  /// Handles when a number button is pressed. Input is now limited to 3 digits.
  void _onDigitPress(int digit) {
    if (_input.length < 3) {
      setState(() {
        _input += digit.toString();
      });
    }
  }

  /// Handles when the backspace button is pressed.
  void _onBackspacePress() {
    if (_input.isNotEmpty) {
      setState(() {
        _input = _input.substring(0, _input.length - 1);
      });
    }
  }

  /// --- UI/LOGIC FIX ---
  /// Formats the input as a simple seconds string, e.g., "90s".
  String _formatDisplayTime() {
    if (_input.isEmpty) {
      return "0s";
    }
    return '${_input}s';
  }

  /// --- UI/LOGIC FIX ---
  /// Parses the input string directly into seconds.
  Duration _parseDuration() {
    if (_input.isEmpty) return Duration.zero;
    final totalSeconds = int.tryParse(_input) ?? 0;
    return Duration(seconds: totalSeconds);
  }

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Container(
        height: 480,
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            // --- TIME DISPLAY ---
            Expanded(
              flex: 2,
              child: Center(
                child: Text(
                  _formatDisplayTime(),
                  style: AppTheme.typography.display.copyWith(
                    fontSize: 64,
                    color: _input.isEmpty
                        ? AppTheme.colors.textMuted
                        : AppTheme.colors.textPrimary,
                  ),
                ),
              ),
            ),
            // --- KEYPAD GRID ---
            GridView.count(
              crossAxisCount: 3,
              childAspectRatio: 2,
              mainAxisSpacing: 12,
              crossAxisSpacing: 12,
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              children: [
                _buildKeypadButton('7'),
                _buildKeypadButton('8'),
                _buildKeypadButton('9'),
                _buildKeypadButton('4'),
                _buildKeypadButton('5'),
                _buildKeypadButton('6'),
                _buildKeypadButton('1'),
                _buildKeypadButton('2'),
                _buildKeypadButton('3'),
                const SizedBox.shrink(),
                _buildKeypadButton('0'),
                _buildKeypadButton(
                  '',
                  onTap: _onBackspacePress,
                  onLongPress: () => setState(() => _input = ''),
                ),
              ],
            ),
            const Spacer(),
            // --- START BUTTON ---
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: _input.isNotEmpty
                    ? () => Navigator.of(context).pop(_parseDuration())
                    : null,
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
                child: const Text('Start Rest'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Helper method to build a single button for the keypad.
  Widget _buildKeypadButton(
    String text, {
    VoidCallback? onTap,
    VoidCallback? onLongPress,
  }) {
    return InkWell(
      onTap: onTap ?? () => _onDigitPress(int.parse(text)),
      onLongPress: onLongPress,
      borderRadius: BorderRadius.circular(100),
      child: Center(
        child: Text(
          text,
          style: AppTheme.typography.title,
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\presentation\widgets\reps_only_set_sheet.dart ----- 
// ----- lib/src/features/workout/presentation/widgets/reps_only_set_sheet.dart -----
// lib/src/features/workout/presentation/widgets/reps_only_set_sheet.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/measurements/data/measurements_repository.dart';
import 'package:fairware_lift/src/features/workout/domain/logged_set.dart';

// -----------------------------------------------------------------------------
// --- REPS ONLY SET SHEET WIDGET ----------------------------------------------
// -----------------------------------------------------------------------------

class RepsOnlySetSheet extends ConsumerStatefulWidget {
  // --- NEW: Accept an optional set to edit ---
  final LoggedSet? set;

  const RepsOnlySetSheet({super.key, this.set});

  @override
  ConsumerState<RepsOnlySetSheet> createState() => _RepsOnlySetSheetState();
}

class _RepsOnlySetSheetState extends ConsumerState<RepsOnlySetSheet> {
  final _repsController = TextEditingController();

  // --- NEW: Pre-fill controller if editing ---
  @override
  void initState() {
    super.initState();
    if (widget.set != null) {
      _repsController.text = widget.set!.reps?.toString() ?? '';
    }
  }

  @override
  void dispose() {
    _repsController.dispose();
    super.dispose();
  }

  void _onLogSet() {
    final reps = int.tryParse(_repsController.text) ?? 0;

    if (mounted) {
      // --- MODIFIED: Handle both add and edit cases ---
      if (widget.set != null) {
        // When editing, just return the ID and new reps.
        Navigator.of(context).pop({'id': widget.set!.id, 'reps': reps});
      } else {
        // When adding, get the current bodyweight and return it.
        final bodyweight = ref.read(latestBodyweightProvider) ?? 0.0;
        Navigator.of(context).pop({'reps': reps, 'weight': bodyweight});
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final asyncRepo = ref.watch(measurementsRepositoryProvider);

    return SafeArea(
      child: Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
          left: 16,
          right: 16,
          top: 16,
        ),
        child: asyncRepo.when(
          loading: () => const Center(child: CircularProgressIndicator()),
          error: (err, stack) => Center(child: Text('Error: $err')),
          data: (_) => Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              _buildTextField(
                controller: _repsController,
                label: 'Reps',
                autofocus: true,
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: _onLogSet,
                style: ElevatedButton.styleFrom(
                  minimumSize: const Size(double.infinity, 50),
                ),
                child: const Text('Save Set'),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTextField({
    required TextEditingController controller,
    required String label,
    bool autofocus = false,
  }) {
    return TextField(
      controller: controller,
      keyboardType: TextInputType.number,
      textAlign: TextAlign.center,
      style: AppTheme.typography.number,
      autofocus: autofocus,
      decoration: InputDecoration(
        labelText: label,
        labelStyle: AppTheme.typography.body,
        filled: true,
        fillColor: AppTheme.colors.surface,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
          borderSide: BorderSide.none,
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\presentation\widgets\set_sheet.dart ----- 
// ----- lib/src/features/workout/presentation/widgets/set_sheet.dart -----
// lib/src/features/workout/presentation/widgets/set_sheet.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/workout/domain/logged_set.dart';

// -----------------------------------------------------------------------------
// --- SET SHEET WIDGET --------------------------------------------------------
// -----------------------------------------------------------------------------

/// A stateful bottom sheet for entering or editing the details of a single set.
class SetSheet extends StatefulWidget {
  // --- NEW: Accept an optional set to edit ---
  final LoggedSet? set;

  const SetSheet({super.key, this.set});

  @override
  State<SetSheet> createState() => _SetSheetState();
}

class _SetSheetState extends State<SetSheet> {
  final _weightController = TextEditingController();
  final _repsController = TextEditingController();

  // --- NEW: Pre-fill controllers if editing an existing set ---
  @override
  void initState() {
    super.initState();
    if (widget.set != null) {
      _weightController.text = widget.set!.weight?.toString() ?? '';
      _repsController.text = widget.set!.reps?.toString() ?? '';
    }
  }

  @override
  void dispose() {
    _weightController.dispose();
    _repsController.dispose();
    super.dispose();
  }

  void _onLogSet() {
    final weight = double.tryParse(_weightController.text) ?? 0.0;
    final reps = int.tryParse(_repsController.text) ?? 0;

    if (mounted) {
      // --- MODIFIED: Return the set's ID if it exists (for updates) ---
      Navigator.of(context).pop({
        'id': widget.set?.id,
        'weight': weight,
        'reps': reps,
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
          left: 16,
          right: 16,
          top: 16,
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Row(
              children: [
                Expanded(
                  child: _buildTextField(
                    controller: _weightController,
                    label: 'Weight (lb)',
                    autofocus: true,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: _buildTextField(
                    controller: _repsController,
                    label: 'Reps',
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: _onLogSet,
              style: ElevatedButton.styleFrom(
                minimumSize: const Size(double.infinity, 50),
              ),
              // --- MODIFIED: More generic button text ---
              child: const Text('Save Set'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTextField({
    required TextEditingController controller,
    required String label,
    bool autofocus = false,
  }) {
    return TextField(
      controller: controller,
      keyboardType: const TextInputType.numberWithOptions(decimal: true),
      textAlign: TextAlign.center,
      style: AppTheme.typography.number,
      autofocus: autofocus,
      decoration: InputDecoration(
        labelText: label,
        labelStyle: AppTheme.typography.body,
        filled: true,
        fillColor: AppTheme.colors.surface,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
          borderSide: BorderSide.none,
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\presentation\widgets\timed_set_sheet.dart ----- 
// ----- lib/src/features/workout/presentation/widgets/timed_set_sheet.dart -----
// lib/src/features/workout/presentation/widgets/timed_set_sheet.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/workout/domain/logged_set.dart';

// -----------------------------------------------------------------------------
// --- TIMED SET SHEET WIDGET --------------------------------------------------
// -----------------------------------------------------------------------------

class TimedSetSheet extends StatefulWidget {
  // --- NEW: Accept an optional set to edit ---
  final LoggedSet? set;

  const TimedSetSheet({super.key, this.set});

  @override
  State<TimedSetSheet> createState() => _TimedSetSheetState();
}

class _TimedSetSheetState extends State<TimedSetSheet> {
  final _durationMinutesController = TextEditingController();
  final _durationSecondsController = TextEditingController();
  final _inclineController = TextEditingController();
  final _speedController = TextEditingController();

  // --- NEW: Pre-fill controllers if editing ---
  @override
  void initState() {
    super.initState();
    if (widget.set != null) {
      final duration = Duration(seconds: widget.set!.durationSeconds ?? 0);
      _durationMinutesController.text = duration.inMinutes.toString();
      _durationSecondsController.text = (duration.inSeconds % 60).toString();
      _inclineController.text = widget.set!.metrics['incline']?.toString() ?? '';
      _speedController.text = widget.set!.metrics['speed_mph']?.toString() ?? '';
    }
  }

  @override
  void dispose() {
    _durationMinutesController.dispose();
    _durationSecondsController.dispose();
    _inclineController.dispose();
    _speedController.dispose();
    super.dispose();
  }

  void _onLogSet() {
    final minutes = int.tryParse(_durationMinutesController.text) ?? 0;
    final seconds = int.tryParse(_durationSecondsController.text) ?? 0;
    final totalDurationSeconds = (minutes * 60) + seconds;

    final incline = double.tryParse(_inclineController.text);
    final speed = double.tryParse(_speedController.text);

    final metrics = <String, dynamic>{};
    if (incline != null) metrics['incline'] = incline;
    if (speed != null) metrics['speed_mph'] = speed;

    if (mounted) {
      // --- MODIFIED: Return the ID if editing ---
      Navigator.of(context).pop({
        'id': widget.set?.id,
        'durationSeconds': totalDurationSeconds,
        'metrics': metrics,
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
          left: 16,
          right: 16,
          top: 16,
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Row(
              children: [
                Expanded(
                  child: _buildTextField(
                    controller: _durationMinutesController,
                    label: 'Minutes',
                    autofocus: true,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: _buildTextField(
                    controller: _durationSecondsController,
                    label: 'Seconds',
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: _buildTextField(
                    controller: _inclineController,
                    label: 'Incline (%)',
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: _buildTextField(
                    controller: _speedController,
                    label: 'Speed (mph)',
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: _onLogSet,
              style: ElevatedButton.styleFrom(
                minimumSize: const Size(double.infinity, 50),
              ),
              child: const Text('Save Set'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTextField({
    required TextEditingController controller,
    required String label,
    bool autofocus = false,
  }) {
    return TextField(
      controller: controller,
      keyboardType: const TextInputType.numberWithOptions(decimal: true),
      textAlign: TextAlign.center,
      style: AppTheme.typography.number,
      autofocus: autofocus,
      decoration: InputDecoration(
        labelText: label,
        labelStyle: AppTheme.typography.body,
        filled: true,
        fillColor: AppTheme.colors.surface,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
          borderSide: BorderSide.none,
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\presentation\widgets\warmup_list_item.dart ----- 
// ----- lib/src/features/workout/presentation/widgets/warmup_list_item.dart -----
// lib/src/features/workout/presentation/widgets/warmup_list_item.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/workout/domain/session_item.dart';

// -----------------------------------------------------------------------------
// --- WARMUP LIST ITEM WIDGET -------------------------------------------------
// -----------------------------------------------------------------------------

class WarmupListItem extends StatelessWidget {
  final SessionWarmupItem warmup;

  const WarmupListItem({
    super.key,
    required this.warmup,
  });

  @override
  Widget build(BuildContext context) {
    // --- BUG FIX ---
    // The subtitle now correctly formats each parameter as "Key: Value".
    // This fixes the issue where only the value was shown (e.g., "5.0" instead
    // of "Incline: 5.0") and ensures all selected parameters are visible.
    final subtitle = warmup.selectedParameters.entries
        .map((e) => '${e.key}: ${e.value}')
        .join('    ');

    return Card(
      color: AppTheme.colors.surface,
      elevation: 0,
      margin: const EdgeInsets.symmetric(vertical: 4.0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppTheme.sizing.cardRadius),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          children: [
            Icon(
              Icons.self_improvement,
              color: AppTheme.colors.textMuted,
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    warmup.item.displayName,
                    style: AppTheme.typography.body
                        .copyWith(color: AppTheme.colors.textSecondary),
                  ),
                  if (subtitle.isNotEmpty) ...[
                    const SizedBox(height: 4),
                    Text(
                      subtitle,
                      style: AppTheme.typography.caption,
                    ),
                  ],
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout\presentation\widgets\workout_dock.dart ----- 
// lib/src/features/workout/presentation/widgets/workout_dock.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/workout/application/timer_state.dart';
import 'package:fairware_lift/src/features/settings/application/settings_provider.dart';
import 'package:fairware_lift/src/features/workout/presentation/widgets/keypad_duration_picker.dart';
// --- NEW IMPORTS ---
import 'package:fairware_lift/src/features/exercises/data/presentation/exercise_picker_screen.dart';
import 'package:fairware_lift/src/features/exercises/domain/exercise.dart' as lib_exercise;
import 'package:fairware_lift/src/features/workout/application/session_state.dart';


// -----------------------------------------------------------------------------
// --- WORKOUT DOCK WIDGET -----------------------------------------------------
// -----------------------------------------------------------------------------

/// A persistent bottom navigation bar for the in-workout session screen.
class WorkoutDock extends ConsumerWidget {
  const WorkoutDock({super.key});

  void _showKeypadPicker(BuildContext context, WidgetRef ref, int timerIndex) async {
    final newDuration = await showModalBottomSheet<Duration>(
      context: context,
      isScrollControlled: true,
      backgroundColor: AppTheme.colors.surface,
      builder: (context) => const KeypadDurationPicker(),
    );

    if (newDuration != null && newDuration.inSeconds > 0) {
      await ref.read(settingsProvider.notifier).updateQuickRestTimer(
            index: timerIndex,
            newDuration: newDuration.inSeconds,
          );
      ref.read(timerStateProvider.notifier).startTimer(duration: newDuration.inSeconds);
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final timerState = ref.watch(timerStateProvider);
    final settings = ref.watch(settingsProvider);

    return BottomAppBar(
      color: AppTheme.colors.background,
      elevation: 0,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),
        // --- MODIFIED: Layout changed to space between ---
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            // --- MODIFIED: Only one quick-select timer ---
            settings.when(
              data: (appSettings) => _buildQuickTimer(
                context: context,
                ref: ref,
                timerIndex: 0, // Always use the first preset
                presetDuration: appSettings.quickRestTimers.isNotEmpty
                    ? appSettings.quickRestTimers[0]
                    : 60, // Fallback
                timerState: timerState,
              ),
              loading: () => const SizedBox(width: 58, height: 40), // Placeholder
              error: (err, stack) => const Text('Error'),
            ),

            // --- NEW: "Add Exercise" button ---
            TextButton.icon(
              onPressed: () async {
                final result = await Navigator.of(context).push<lib_exercise.Exercise>(
                  MaterialPageRoute(
                    fullscreenDialog: true,
                    builder: (context) => const ExercisePickerScreen(),
                  ),
                );
                // Use a mounted check for safety in async gaps
                if (result != null && context.mounted) {
                  ref.read(sessionStateProvider.notifier).addExerciseFromLibrary(result);
                }
              },
              icon: const Icon(Icons.add),
              label: const Text('Add Exercise'),
              style: TextButton.styleFrom(
                foregroundColor: AppTheme.colors.textSecondary,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildQuickTimer({
    required BuildContext context,
    required WidgetRef ref,
    required int timerIndex,
    required int presetDuration,
    required TimerState timerState,
  }) {
    final bool isThisTimerActive =
        timerState.isRunning && timerState.initialDuration == presetDuration;

    // --- FIX: Use the new 'seconds' field name ---
    final double timerProgress = isThisTimerActive && timerState.initialDuration > 0
        ? timerState.seconds / timerState.initialDuration
        : 0.0;

    return GestureDetector(
      onTap: () {
        if (isThisTimerActive) {
          ref.read(timerStateProvider.notifier).stopTimer();
        } else {
          ref.read(timerStateProvider.notifier).startTimer(duration: presetDuration);
        }
      },
      onLongPress: () => _showKeypadPicker(context, ref, timerIndex),
      child: Container(
        width: 58, // Increased width for better touch target
        height: 40,
        margin: const EdgeInsets.symmetric(horizontal: 4),
        child: Stack(
          alignment: Alignment.center,
          children: [
            if (isThisTimerActive)
              SizedBox(
                width: 40,
                height: 40,
                child: CircularProgressIndicator(
                  value: timerProgress,
                  strokeWidth: 2.0,
                  backgroundColor: AppTheme.colors.surface,
                  color: AppTheme.colors.accent,
                ),
              ),
            Text(
              // --- FIX: Use the new 'seconds' field name ---
              isThisTimerActive
                  ? '${timerState.seconds}s'
                  : '${presetDuration}s',
              style: AppTheme.typography.body.copyWith(
                fontSize: 14,
                color: isThisTimerActive
                    ? AppTheme.colors.accent
                    : AppTheme.colors.textMuted,
                fontWeight: FontWeight.bold,
              ),
            ),
          ],
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout_import\application\lift_dsl_schema.dart ----- 
 // lib/src/features/workout_import/application/lift_dsl_schema.dart

// -----------------------------------------------------------------------------
// --- LIFT DSL V1 SCHEMA ------------------------------------------------------
// -----------------------------------------------------------------------------
// This file contains the canonical JSON schema for the `lift.v1` workout DSL.
// It serves as the single source of truth for validating the structure of
// pasted workout text.
// -----------------------------------------------------------------------------

const String liftV1JsonSchema = r'''
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Fairware Lift Workout DSL v1",
  "type": "object",
  "required": ["version", "workout"],
  "properties": {
    "version": { "const": "lift.v1" },
    "workout": {
      "type": "object",
      "required": ["title", "blocks"],
      "properties": {
        "title": { "type": "string", "minLength": 1 },
        "notes": { "type": "string" },
        "blocks": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "object",
            "required": ["type", "exercises"],
            "properties": {
              "type": { "enum": ["straight", "superset", "triset", "warmup", "finisher"] },
              "label": { "type": "string" },
              "rounds": { "type": "integer", "minimum": 1 },
              "exercises": {
                "type": "array",
                "minItems": 1,
                "items": {
                  "type": "object",
                  "required": ["name"],
                  "properties": {
                    "name": { "type": "string", "minLength": 1 },
                    "variation": { "type": "object", "additionalProperties": { "type": ["string","number","boolean"] } },
                    "prescription": {
                      "type": "object",
                      "properties": {
                        "sets": { "type": "integer", "minimum": 1 },
                        "reps": { "type": ["string","integer"] },
                        "intensity": {
                          "type": "object",
                          "properties": {
                            "type": { "enum": ["RPE","percent_1RM","load","rir"] },
                            "target": { "type": "number" },
                            "value": { "type": "number" },
                            "kg": { "type": "number" },
                            "lb": { "type": "number" },
                            "rir": { "type": "number" }
                          },
                          "additionalProperties": false
                        },
                        "rest_seconds": { "type": "integer", "minimum": 0 },
                        "rest_seconds_after": { "type": "integer", "minimum": 0 },
                        "note": { "type": "string" }
                      },
                      "additionalProperties": false
                    },
                    "metadata": {
                      "type": "object",
                      "properties": {
                        "aliases": { "type": "array", "items": { "type": "string" } },
                        "equipment": { "type": "array", "items": { "type": "string" } },
                        "primary_muscles": { "type": "array", "items": { "type": "string" } }
                      },
                      "additionalProperties": false
                    }
                  },
                  "additionalProperties": false
                }
              }
            },
            "additionalProperties": false
          }
        }
      },
      "additionalProperties": false
    }
  },
  "additionalProperties": false
}
''';----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout_import\application\lift_dsl_validator.dart ----- 
// lib/src/features/workout_import/application/lift_dsl_validator.dart

import 'dart:convert';
import 'package:fairware_lift/src/features/workout_import/domain/lift_dsl.dart';

class ValidationResult {
  final LiftWorkout? workout;
  final String? error;
  ValidationResult({this.workout, this.error});
  bool get isValid => workout != null && error == null;
}

class LiftDslValidator {
  ValidationResult parseAndValidate(String jsonString) {
    try {
      final data = json.decode(jsonString) as Map<String, dynamic>;

      if (data['version'] != 'lift.v1') {
        return ValidationResult(error: 'Invalid or missing "version". Must be "lift.v1".');
      }
      if (data['workout'] == null || data['workout'] is! Map) {
        return ValidationResult(error: 'Missing or invalid "workout" object.');
      }

      final workoutData = data['workout'] as Map<String, dynamic>;
      final workout = _parseWorkout(workoutData);

      return ValidationResult(workout: LiftWorkout(version: 'lift.v1', workout: workout));
    } catch (e) {
      return ValidationResult(error: 'Invalid JSON format: ${e.toString()}');
    }
  }

  Workout _parseWorkout(Map<String, dynamic> data) {
    if (data['title'] == null || data['title'] is! String) throw const FormatException('Workout missing required "title".');
    if (data['blocks'] == null || data['blocks'] is! List) throw const FormatException('Workout missing required "blocks" array.');
    final blocks = (data['blocks'] as List).map((b) => _parseBlock(b as Map<String, dynamic>)).toList();
    return Workout(title: data['title'], notes: data['notes'] as String?, blocks: blocks);
  }

  Block _parseBlock(Map<String, dynamic> data) {
    if (data['type'] == null || data['exercises'] == null) throw const FormatException('Block is missing "type" or "exercises".');
    final exercises = (data['exercises'] as List).map((e) => _parseExercise(e as Map<String, dynamic>)).toList();
    return Block(
      type: BlockType.values.firstWhere((e) => e.name == data['type']),
      label: data['label'] as String?,
      rounds: data['rounds'] as int?,
      exercises: exercises,
    );
  }

  Exercise _parseExercise(Map<String, dynamic> data) {
    if (data['name'] == null) throw const FormatException('Exercise is missing required "name".');
    return Exercise(
      name: data['name'],
      variation: data['variation'] as Map<String, dynamic>?,
      prescription: data['prescription'] != null ? _parsePrescription(data['prescription']) : null,
      metadata: data['metadata'] != null ? _parseExerciseMeta(data['metadata']) : null,
      info: data['info'] != null ? _parseInfo(data['info']) : null,
    );
  }

  Prescription _parsePrescription(Map<String, dynamic> data) {
    return Prescription(
      // --- FIX ---
      // Now correctly parsing the new `setType` field from the JSON.
      setType: data['setType'] as String?,
      sets: data['sets'] as int?,
      reps: data['reps'],
      intensity: data['intensity'] != null ? _parseIntensity(data['intensity']) : null,
      restSeconds: data['rest_seconds'] as int?,
      restSecondsAfter: data['rest_seconds_after'] as int?,
      note: data['note'] as String?,
    );
  }

  Intensity _parseIntensity(Map<String, dynamic> data) {
    final typeString = data['type'].toString().toLowerCase().replaceAll('_', '');
    return Intensity(
      type: IntensityType.values.firstWhere((e) => e.name.replaceAll('_', '') == typeString),
      target: (data['target'] as num?)?.toDouble(),
      value: (data['value'] as num?)?.toDouble(),
      kg: (data['kg'] as num?)?.toDouble(),
      lb: (data['lb'] as num?)?.toDouble(),
      rir: (data['rir'] as num?)?.toDouble(),
    );
  }

  ExerciseMeta _parseExerciseMeta(Map<String, dynamic> data) {
    return ExerciseMeta(
      aliases: (data['aliases'] as List?)?.map((e) => e.toString()).toList(),
      equipment: (data['equipment'] as List?)?.map((e) => e.toString()).toList(),
      primaryMuscles: (data['primary_muscles'] as List?)?.map((e) => e.toString()).toList(),
    );
  }

  Info _parseInfo(Map<String, dynamic> data) {
    return Info(
      howTo: data['how_to'] as String?,
      coachingCues: (data['coaching_cues'] as List?)?.map((e) => e.toString()).toList(),
      commonErrors: (data['common_errors'] as List?)?.map((e) => e.toString()).toList(),
      safetyNotes: data['safety_notes'] as String?,
      videoSearchQuery: data['video_search_query'] as String?,
      webSearchQuery: data['web_search_query'] as String?,
      regression: data['regression'] as String?,
      progression: data['progression'] as String?,
      muscles: (data['muscles'] as List?)?.map((e) => e.toString()).toList(),
      equipmentNotes: data['equipment_notes'] as String?,
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout_import\application\lift_hash.dart ----- 
// lib/src/features/workout_import/application/lift_hash.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'dart:convert';
import 'package:crypto/crypto.dart';

// -----------------------------------------------------------------------------
// --- LIFT HASH SERVICE -------------------------------------------------------
// -----------------------------------------------------------------------------
// This service creates a stable, deterministic hash for an exercise based on
// its name and variation. This is crucial for identifying the same conceptual
// exercise over time, even if our internal slug system changes.
// -----------------------------------------------------------------------------

class LiftHash {
  /// Generates a stable SHA-1 hash for an exercise.
  ///
  /// The process is:
  /// 1. Normalize the exercise name to lowercase.
  /// 2. If variation exists, sort its keys alphabetically.
  /// 3. Create a canonical string representation (e.g., "bench press|grip:close|implement:barbell").
  /// 4. Hash this string using SHA-1.
  String exerciseHash(String rawName, Map<String, dynamic>? variation) {
    final normalizedName = rawName.trim().toLowerCase();
    final parts = [normalizedName];

    if (variation != null && variation.isNotEmpty) {
      final sortedKeys = variation.keys.toList()..sort();
      for (final key in sortedKeys) {
        final value = variation[key].toString().trim().toLowerCase();
        parts.add('$key:$value');
      }
    }

    final canonicalString = parts.join('|');
    final bytes = utf8.encode(canonicalString);
    final digest = sha1.convert(bytes);

    return digest.toString();
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout_import\application\lift_importer.dart ----- 
// lib/src/features/workout_import/application/lift_importer.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:fairware_lift/src/features/workout_import/domain/lift_dsl.dart';
import 'package:fairware_lift/src/features/workout_import/application/lift_dsl_validator.dart';
import 'package:fairware_lift/src/features/workout_import/application/lift_normalizer.dart';
import 'package:fairware_lift/src/features/workout_import/application/lift_matcher.dart';
import 'package:fairware_lift/src/features/workout_import/application/lift_hash.dart';
import 'package:fairware_lift/src/features/workout/domain/session_item.dart';
import 'package:fairware_lift/src/features/dxg/application/name_slug_service.dart';

class LowConfidenceIssue {
  final String rawName;
  LowConfidenceIssue({required this.rawName});
}

class LiftImporterOutput {
  final List<SessionItem> sessionItems;
  final List<LowConfidenceIssue> issues;
  final String? error;
  LiftImporterOutput({this.sessionItems = const [], this.issues = const [], this.error});
  bool get hasIssues => issues.isNotEmpty;
  bool get hasError => error != null;
}

class LiftImporter {
  final LiftDslValidator _validator;
  final LiftNormalizer _normalizer;
  final LiftMatcher _matcher;
  final LiftHash _hasher;
  final NameAndSlugService _nameAndSlugService;
  final Uuid _uuid = const Uuid();

  LiftImporter(this._validator, this._normalizer, this._matcher, this._hasher, this._nameAndSlugService);

  Future<LiftImporterOutput> importFromJson(String jsonString) async {
    try {
      final validationResult = _validator.parseAndValidate(jsonString);
      if (!validationResult.isValid) return LiftImporterOutput(error: validationResult.error);

      final normalizedWorkout = _normalizer.normalize(validationResult.workout!);
      final sessionItems = <SessionItem>[];
      final issues = <LowConfidenceIssue>[];

      for (final block in normalizedWorkout.workout.blocks) {
        if (block.type == BlockType.straight || block.type == BlockType.warmup || block.type == BlockType.finisher) {
          for (final exercise in block.exercises) {
            sessionItems.add(await _buildSessionExercise(exercise, issues));
          }
        } else if (block.type == BlockType.superset || block.type == BlockType.triset) {
          final supersetExercises = <SessionExercise>[];
          for (final exercise in block.exercises) {
            supersetExercises.add(await _buildSessionExercise(exercise, issues));
          }
          sessionItems.add(SessionSuperset(id: _uuid.v4(), exercises: supersetExercises));
        }
      }
      return LiftImporterOutput(sessionItems: sessionItems, issues: issues);
    } catch (e) {
      return LiftImporterOutput(error: 'An unexpected error occurred during import: ${e.toString()}');
    }
  }

  Future<SessionExercise> _buildSessionExercise(Exercise exercise, List<LowConfidenceIssue> issues) async {
    final matchResult = await _matcher.match(rawName: exercise.name, aliases: exercise.metadata?.aliases);
    if (matchResult.unmapped) issues.add(LowConfidenceIssue(rawName: exercise.name));

    final exerciseHash = _hasher.exerciseHash(exercise.name, exercise.variation);
    String? canonicalSlug;
    if (matchResult.familyId != null) {
      final discriminators = <String, String>{};
      exercise.variation?.forEach((key, value) { discriminators[key] = value.toString(); });
      canonicalSlug = _nameAndSlugService.toSlug(familyId: matchResult.familyId!, discriminators: discriminators);
    }

    // --- MODIFIED LOGIC: Prioritize explicit setType, then fallback. ---
    String? setType = exercise.prescription?.setType;
    
    if (setType == null) {
        final lowerCaseName = exercise.name.toLowerCase();
        if (lowerCaseName.contains('walk') || lowerCaseName.contains('run') || lowerCaseName.contains('row') || lowerCaseName.contains('bike') || lowerCaseName.contains('plank') || lowerCaseName.contains('carry')) {
            setType = 'timed';
        }
    }

    return SessionExercise(
      id: _uuid.v4(),
      slug: canonicalSlug,
      exerciseHash: exerciseHash,
      displayName: exercise.name,
      prescription: exercise.prescription!,
      variation: exercise.variation ?? {},
      info: exercise.info,
      unmapped: matchResult.unmapped,
      defaultSetType: setType,
    );
  }
}

final liftDslValidatorProvider = Provider((_) => LiftDslValidator());
final liftNormalizerProvider = Provider((_) => LiftNormalizer());
final liftHashProvider = Provider((_) => LiftHash());

final liftImporterProvider = FutureProvider<LiftImporter>((ref) async {
  final matcher = await ref.watch(liftMatcherProvider.future);
  return LiftImporter(
    ref.watch(liftDslValidatorProvider),
    ref.watch(liftNormalizerProvider),
    matcher,
    ref.watch(liftHashProvider),
    ref.watch(nameAndSlugServiceProvider),
  );
});----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout_import\application\lift_matcher.dart ----- 
// lib/src/features/workout_import/application/lift_matcher.dart

import 'dart:convert';
import 'package:flutter/services.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/features/workout_import/application/text_norm.dart';

class MatchResult {
  final String? familyId;
  final double confidence;
  final bool unmapped;

  MatchResult({
    this.familyId,
    required this.confidence,
    this.unmapped = false,
  });
}

abstract class LiftMatcher {
  Future<MatchResult> match({
    required String rawName,
    List<String>? aliases,
  });
}

class RealLiftMatcher implements LiftMatcher {
  final Map<String, String> _lookupIndex;

  RealLiftMatcher(this._lookupIndex) {
    assert(_lookupIndex.isNotEmpty, 'RealLiftMatcher created with an empty lookup index.');
  }

  @override
  Future<MatchResult> match({
    required String rawName,
    List<String>? aliases,
  }) async {
    final namesToCheck = {
      normalize(rawName),
      ...?aliases?.map(normalize)
    };

    if (kDebugMode) {
      debugPrint('[LiftMatcher] Query: "$rawName" -> Normalized Candidates: ${namesToCheck.toList()}');
    }

    for (final name in namesToCheck) {
      if (_lookupIndex.containsKey(name)) {
        final familyId = _lookupIndex[name]!;
        if (kDebugMode) {
          debugPrint('  >>> HIT on "$name" -> familyId: "$familyId"');
        }
        return MatchResult(familyId: familyId, confidence: 1.0);
      }
    }

    if (kDebugMode) {
      debugPrint('  >>> MISS for all candidates.');
    }
    return MatchResult(confidence: 0.0, unmapped: true);
  }
}

final _lookupIndexProvider = FutureProvider<Map<String, String>>((ref) async {
  final jsonString = await rootBundle.loadString('assets/data/lift_aliases.json');
  final jsonMap = json.decode(jsonString) as Map<String, dynamic>;
  
  final index = <String, String>{};

  for (final entry in jsonMap.entries) {
    final familyId = entry.key;
    final strings = List<String>.from(entry.value);
    for (final s in strings) {
      // Use the new variant generator to create a more robust index
      for (final v in variantsFor(s)) {
        index[v] = familyId;
      }
    }
  }

  if (index.isEmpty) {
    throw StateError('lift_aliases.json produced an empty lookup index.');
  }

  if (kDebugMode) {
    debugPrint('[LiftMatcher] Index built. Total unique keys: ${index.length}');
  }
  return index;
});

final liftMatcherProvider = FutureProvider<LiftMatcher>((ref) async {
  final lookupIndex = await ref.watch(_lookupIndexProvider.future);
  return RealLiftMatcher(lookupIndex);
});----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout_import\application\lift_normalizer.dart ----- 
// lib/src/features/workout_import/application/lift_normalizer.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:fairware_lift/src/features/workout_import/domain/lift_dsl.dart';

// -----------------------------------------------------------------------------
// --- LIFT NORMALIZER SERVICE -------------------------------------------------
// -----------------------------------------------------------------------------

class LiftNormalizer {
  LiftWorkout normalize(LiftWorkout rawWorkout) {
    final normalizedBlocks = rawWorkout.workout.blocks.map((block) {
      final bool isMultiExerciseBlock =
          block.type == BlockType.superset || block.type == BlockType.triset;

      final normalizedExercises = block.exercises.map((exercise) {
        final normalizedPrescription = _normalizePrescription(
          exercise.prescription,
          isMultiExerciseBlock: isMultiExerciseBlock,
          rounds: block.rounds,
        );

        // --- FIX ---
        // The `info` block was being dropped here. It is now being correctly
        // passed through to the next step in the import process.
        return Exercise(
          name: exercise.name,
          variation: exercise.variation,
          prescription: normalizedPrescription,
          metadata: exercise.metadata,
          info: exercise.info, // This line was missing.
        );
      }).toList();

      return Block(
        type: block.type,
        label: block.label,
        rounds: block.rounds,
        exercises: normalizedExercises,
      );
    }).toList();

    return LiftWorkout(
      version: rawWorkout.version,
      workout: Workout(
        title: rawWorkout.workout.title,
        notes: rawWorkout.workout.notes,
        blocks: normalizedBlocks,
      ),
    );
  }

  Prescription _normalizePrescription(
    Prescription? rawPrescription, {
    required bool isMultiExerciseBlock,
    int? rounds,
  }) {
    final p = rawPrescription ?? const Prescription();
    final sets = p.sets ?? (isMultiExerciseBlock ? rounds : 3);

    return Prescription(
      sets: sets,
      reps: p.reps ?? '8-12',
      intensity: p.intensity,
      restSeconds: p.restSeconds,
      restSecondsAfter: p.restSecondsAfter,
      note: p.note,
    );
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout_import\application\text_norm.dart ----- 
// lib/src/features/workout_import/application/text_norm.dart

// -----------------------------------------------------------------------------
// --- NORMALIZATION & VARIANT GENERATION --------------------------------------
// -----------------------------------------------------------------------------

/// A robust normalization function to clean up strings for matching.
String normalize(String s) {
  return s
      .toLowerCase()
      // Strip all characters that are not letters, numbers, or spaces.
      .replaceAll(RegExp(r"[^\p{L}\p{N}\s]+", unicode: true), " ")
      // Collapse multiple whitespace characters into a single space.
      .replaceAll(RegExp(r"\s+"), " ")
      .trim();
}

/// Generates multiple searchable variations of a given exercise name.
Iterable<String> variantsFor(String original) sync* {
  final base = normalize(original);
  yield base;

  // Variant with parenthetical notes removed, e.g., "Nordic Curl (Assisted)" -> "nordic curl"
  final noParens = base.replaceAll(RegExp(r"\([^)]*\)"), "").replaceAll(RegExp(r"\s+"), " ").trim();
  if (noParens != base) {
    yield noParens;
  }

  // Variant with common equipment tokens removed.
  final noEquip = noParens.replaceAll(
      RegExp(r"\b(machine|barbell|dumbbell|db|cable|assisted|ez bar|ez-bar|ezbar)\b"),
      "").replaceAll(RegExp(r"\s+"), " ").trim();
  if (noEquip.isNotEmpty && noEquip != noParens) {
    yield noEquip;
  }
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout_import\domain\lift_dsl.dart ----- 
// lib/src/features/workout_import/domain/lift_dsl.dart

import 'package:flutter/foundation.dart';

@immutable
class LiftWorkout {
  final String version;
  final Workout workout;
  const LiftWorkout({required this.version, required this.workout});
}

@immutable
class Workout {
  final String title;
  final String? notes;
  final List<Block> blocks;
  const Workout({required this.title, this.notes, required this.blocks});
}

enum BlockType { straight, superset, triset, warmup, finisher }

@immutable
class Block {
  final BlockType type;
  final String? label;
  final int? rounds;
  final List<Exercise> exercises;
  const Block({required this.type, this.label, this.rounds, required this.exercises});
}

@immutable
class Exercise {
  final String name;
  final Map<String, dynamic>? variation;
  final Prescription? prescription;
  final ExerciseMeta? metadata;
  final Info? info; // NEW
  const Exercise({required this.name, this.variation, this.prescription, this.metadata, this.info});
}

@immutable
class Prescription {
  final String? setType; // NEW
  final int? sets;
  final dynamic reps;
  final Intensity? intensity;
  final int? restSeconds;
  final int? restSecondsAfter;
  final String? note;
  const Prescription({this.setType, this.sets, this.reps, this.intensity, this.restSeconds, this.restSecondsAfter, this.note});
}

enum IntensityType { rpe, percent_1rm, load, rir }

@immutable
class Intensity {
  final IntensityType type;
  final double? target, value, kg, lb, rir;
  const Intensity({required this.type, this.target, this.value, this.kg, this.lb, this.rir});
}

@immutable
class ExerciseMeta {
  final List<String>? aliases, equipment, primaryMuscles;
  const ExerciseMeta({this.aliases, this.equipment, this.primaryMuscles});
}

// --- NEW ---
@immutable
class Info {
  final String? howTo;
  final List<String>? coachingCues;
  final List<String>? commonErrors;
  final String? safetyNotes;
  final String? videoSearchQuery;
  final String? webSearchQuery;
  final String? regression;
  final String? progression;
  final List<String>? muscles;
  final String? equipmentNotes;

  const Info({
    this.howTo,
    this.coachingCues,
    this.commonErrors,
    this.safetyNotes,
    this.videoSearchQuery,
    this.webSearchQuery,
    this.regression,
    this.progression,
    this.muscles,
    this.equipmentNotes,
  });
}----- android\build.gradle ----- 
----- D:\fairware_lift\lib\src\features\workout_import\presentation\paste_workout_screen.dart ----- 
// lib/src/features/workout_import/presentation/paste_workout_screen.dart

// -----------------------------------------------------------------------------
// --- IMPORTS -----------------------------------------------------------------
// -----------------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fairware_lift/src/core/theme/app_theme.dart';
import 'package:fairware_lift/src/features/workout_import/application/lift_importer.dart';
import 'package:fairware_lift/src/features/workout/application/session_state.dart';
import 'package:fairware_lift/src/features/workout/presentation/session_screen.dart';

// -----------------------------------------------------------------------------
// --- LOCAL STATE PROVIDERS ---------------------------------------------------
// -----------------------------------------------------------------------------

// --- FIX: Converted to .autoDispose to ensure state resets on screen exit. ---
final _importStateProvider =
    StateProvider.autoDispose<AsyncValue<void>>((ref) => const AsyncData(null));

// -----------------------------------------------------------------------------
// --- PASTE WORKOUT SCREEN WIDGET ---------------------------------------------
// -----------------------------------------------------------------------------

class PasteWorkoutScreen extends ConsumerStatefulWidget {
  const PasteWorkoutScreen({super.key});

  @override
  ConsumerState<PasteWorkoutScreen> createState() => _PasteWorkoutScreenState();
}

class _PasteWorkoutScreenState extends ConsumerState<PasteWorkoutScreen> {
  final _textController = TextEditingController();

  @override
  void dispose() {
    _textController.dispose();
    super.dispose();
  }

  Future<void> _handleImport() async {
    // We now read the FutureProvider for the importer.
    final importer = await ref.read(liftImporterProvider.future);
    final notifier = ref.read(_importStateProvider.notifier);

    notifier.state = const AsyncLoading();

    final output = await importer.importFromJson(_textController.text);

    if (!mounted) return;

    if (output.hasError) {
      notifier.state = AsyncError(output.error!, StackTrace.current);
    } else if (output.hasIssues) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
              '${output.issues.length} exercises could not be matched and will be unmapped.'),
          backgroundColor: AppTheme.colors.warning,
        ),
      );

      ref.read(sessionStateProvider.notifier).importWorkout(output.sessionItems);
      _navigateToSession();
    } else {
      ref.read(sessionStateProvider.notifier).importWorkout(output.sessionItems);
      _navigateToSession();
    }
  }

  void _navigateToSession() {
    Navigator.of(context).pushReplacement(
      MaterialPageRoute(
        fullscreenDialog: true,
        builder: (context) => const SessionScreen(),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final importState = ref.watch(_importStateProvider);
    // We watch the async provider to show a loading state while the matcher initializes.
    final asyncImporter = ref.watch(liftImporterProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Import Workout'),
        backgroundColor: AppTheme.colors.surface,
      ),
      // --- FIX: Wrapped body in SafeArea to avoid system navigation overlap. ---
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: asyncImporter.when(
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (err, stack) =>
                Center(child: Text('Error initializing importer: $err')),
            data: (_) => Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Text(
                  'Paste the JSON output from your LLM below. The app will build the workout cards for you.',
                  style: AppTheme.typography.body,
                ),
                const SizedBox(height: 16),
                Expanded(
                  child: TextField(
                    controller: _textController,
                    expands: true,
                    maxLines: null,
                    minLines: null,
                    style: AppTheme.typography.body
                        .copyWith(fontFamily: 'monospace'),
                    decoration: InputDecoration(
                      // --- FIX: Changed placeholder text to be more intuitive. ---
                      hintText: 'Paste workout JSON here...',
                      hintStyle: AppTheme.typography.body.copyWith(
                        fontFamily: 'monospace',
                        color: AppTheme.colors.textMuted,
                      ),
                      filled: true,
                      fillColor: AppTheme.colors.surface,
                      border: OutlineInputBorder(
                        borderRadius:
                            BorderRadius.circular(AppTheme.sizing.cardRadius),
                        borderSide: BorderSide.none,
                      ),
                      errorText:
                          importState.whenOrNull(error: (e, s) => e.toString()),
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                ElevatedButton(
                  onPressed: importState.isLoading ? null : _handleImport,
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                  ),
                  child: importState.isLoading
                      ? const SizedBox(
                          height: 24,
                          width: 24,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : const Text('Preview & Build Workout'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}----- android\build.gradle ----- 
